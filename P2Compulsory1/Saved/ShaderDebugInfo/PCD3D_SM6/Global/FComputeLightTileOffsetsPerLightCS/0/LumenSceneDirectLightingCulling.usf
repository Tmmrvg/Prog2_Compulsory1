#line 1 "MoveShaderParametersToRootConstantBuffer"
cbuffer _RootShaderParameters
{
uint NumLights : packoffset(c1);
uint NumViews : packoffset(c1.y);
}

#line 1 "DumpShaderDefinesAsCommentedCode"
// #define __SHADER_TARGET_MAJOR 6
// #define __SHADER_TARGET_MINOR 6
// #define ALLOW_STATIC_LIGHTING 1
// #define AMPLIFICATIONSHADER 0
// #define CLEAR_COAT_BOTTOM_NORMAL 0
// #define COMPILE_SHADERS_FOR_DEVELOPMENT 1
// #define COMPILER_DEFINE #define
// #define COMPILER_DXC 1
// #define COMPILER_SUPPORTS_HLSL2021 1
// #define COMPUTESHADER 1
// #define DO_CHECK 1
// #define DO_GUARD_SLOW 0
// #define DXT5_NORMALMAPS 0
// #define EARLY_Z_PASS_ONLY_MATERIAL_MASKING 0
// #define FORWARD_SHADING 0
// #define GBUFFER_HAS_DIFFUSE_SAMPLE_OCCLUSION 0
// #define GBUFFER_HAS_VELOCITY 1
// #define GBUFFER_REFACTOR 1
// #define GEOMETRYSHADER 0
// #define HAS_INVERTED_Z_BUFFER 1
// #define INSTANCED_STEREO 0
// #define IRIS_NORMAL 0
// #define MATERIAL_ENERGYCONSERVATION 0
// #define MATERIAL_ROUGHDIFFUSE 0
// #define MESHSHADER 0
// #define MOBILE_MULTI_VIEW 0
// #define MULTI_VIEW 0
// #define PIXELSHADER 0
// #define PLATFORM_ALLOW_SCENE_DATA_COMPRESSED_TRANSFORMS 1
// #define PLATFORM_SUPPORTS_BINDLESS 1
// #define PLATFORM_SUPPORTS_DISTANCE_FIELDS 1
// #define PLATFORM_SUPPORTS_MESH_SHADERS_TIER0 1
// #define PLATFORM_SUPPORTS_MESH_SHADERS_TIER1 1
// #define PLATFORM_SUPPORTS_PER_PIXEL_DBUFFER_MASK 0
// #define PLATFORM_SUPPORTS_RENDERTARGET_WRITE_MASK 0
// #define PLATFORM_SUPPORTS_SRV_UB 1
// #define PLATFORM_SUPPORTS_UB_STRUCT 1
// #define POST_PROCESS_ALPHA 0
// #define PROJECT_ALLOW_GLOBAL_CLIP_PLANE 0
// #define PROJECT_MOBILE_DISABLE_VERTEX_FOG 1
// #define PROJECT_OIT 0
// #define PROJECT_STRATA_BACKCOMPATIBILITY 0
// #define PROJECT_SUPPORT_SKY_ATMOSPHERE 1
// #define PROJECT_SUPPORT_SKY_ATMOSPHERE_AFFECTS_HEIGHFOG 1
// #define PROJECT_SUPPORTS_LUMEN 1
// #define PROJECT_VERTEX_FOGGING_FOR_OPAQUE 0
// #define RAYCALLABLESHADER 0
// #define RAYGENSHADER 0
// #define RAYHITGROUPSHADER 0
// #define RAYMISSSHADER 0
// #define SELECTIVE_BASEPASS_OUTPUTS 0
// #define SHADING_PATH_DEFERRED 1
// #define SM6_PROFILE 1
// #define STRATA_ADVANCED_DEBUG_ENABLED 0
// #define STRATA_ENABLED 0
// #define STRATA_OPAQUE_ROUGH_REFRACTION_ENABLED 0
// #define SUPPORT_CLOUD_SHADOW_ON_FORWARD_LIT_TRANSLUCENT 0
// #define SUPPORT_CLOUD_SHADOW_ON_SINGLE_LAYER_WATER 0
// #define THREADGROUP_SIZE 64
// #define UE_LWC_RENDER_TILE_SIZE 2097152.00f
// #define UE_LWC_RENDER_TILE_SIZE_FMOD_2PI 0.673652053f
// #define UE_LWC_RENDER_TILE_SIZE_FMOD_PI 0.673652053f
// #define UE_LWC_RENDER_TILE_SIZE_RCP 4.76837158e-07f
// #define UE_LWC_RENDER_TILE_SIZE_RSQRT 0.000690533954f
// #define UE_LWC_RENDER_TILE_SIZE_SQRT 1448.15466f
// #define USE_DBUFFER 1
// #define VELOCITY_ENCODE_DEPTH 1
// #define VERTEXSHADER 0
// #define VIRTUAL_TEXTURE_ANISOTROPIC_FILTERING 0
#line 1 "/Engine/Private/Lumen/LumenSceneDirectLightingCulling.usf"
#line 3 "/Engine/Private/Lumen/LumenSceneDirectLightingCulling.usf"
#line 1 "../Common.ush"
#line 9 "/Engine/Private/Common.ush"
#line 1 "/Engine/Public/Platform.ush"
#line 9 "/Engine/Public/Platform.ush"
#line 1 "FP16Math.ush"
#line 10 "/Engine/Public/Platform.ush"
#line 36 "/Engine/Public/Platform.ush"
#line 1 "Platform/D3D/D3DCommon.ush"
#line 15 "/Engine/Public/Platform/D3D/D3DCommon.ush"
precise float MakePrecise(float v) { precise float pv = v; return pv; }
precise float2 MakePrecise(float2 v) { precise float2 pv = v; return pv; }
precise float3 MakePrecise(float3 v) { precise float3 pv = v; return pv; }
precise float4 MakePrecise(float4 v) { precise float4 pv = v; return pv; }





SamplerState D3DStaticPointWrappedSampler : register(s0, space1000);
SamplerState D3DStaticPointClampedSampler : register(s1, space1000);
SamplerState D3DStaticBilinearWrappedSampler : register(s2, space1000);
SamplerState D3DStaticBilinearClampedSampler : register(s3, space1000);
SamplerState D3DStaticTrilinearWrappedSampler : register(s4, space1000);
SamplerState D3DStaticTrilinearClampedSampler : register(s5, space1000);
#line 41 "/Engine/Public/Platform/D3D/D3DCommon.ush"
RWStructuredBuffer<uint> UEDiagnosticBuffer : register(u0, space999);

void UEReportAssertWithPayload(uint AssertID, uint4 Payload)
{
	if (WaveIsFirstLane())
	{

		uint OldValue = 0;
		InterlockedAdd(UEDiagnosticBuffer[0], 1, OldValue);
		if (OldValue == 0)
		{
			UEDiagnosticBuffer[1] = AssertID;
			UEDiagnosticBuffer[2] = Payload.x;
			UEDiagnosticBuffer[3] = Payload.y;
			UEDiagnosticBuffer[4] = Payload.z;
			UEDiagnosticBuffer[5] = Payload.w;
		}


		UEDiagnosticBuffer[0xFFFFFFFF] = 0;
	}
}
#line 106 "/Engine/Public/Platform/D3D/D3DCommon.ush"
		uint64_t  PackUlongType(uint2 Value)
		{
			return (( uint64_t )Value.y << 32) | Value.x;
		}

		uint2 UnpackUlongType( uint64_t  Value)
		{
			return uint2(uint(Value), uint(Value >> 32));
		}



		void ImageInterlockedMaxUInt64(RWTexture2D< uint64_t > Dest, uint2 Coord,  uint64_t  Value)
		{
			InterlockedMax(Dest[Coord], Value);
		}





	#define  GetResourceFromHeap(Type, Index) ResourceDescriptorHeap[Index]
	#define  GetSamplerFromHeap(Type, Index) SamplerDescriptorHeap[Index]
#line 37 "/Engine/Public/Platform.ush"
#line 39 "/Engine/Public/Platform.ush"
#line 1 "/Engine/Public/BindlessResources.ush"
#line 40 "/Engine/Public/Platform.ush"
#line 43 "/Engine/Public/Platform.ush"
#line 1 "ShaderVersion.ush"
#line 44 "/Engine/Public/Platform.ush"
#line 498 "/Engine/Public/Platform.ush"
void ShaderYield()
{

}
#line 736 "/Engine/Public/Platform.ush"
float min3( float a, float b, float c )
{
	return min( a, min( b, c ) );
}

float max3( float a, float b, float c )
{
	return max( a, max( b, c ) );
}

float2 min3( float2 a, float2 b, float2 c )
{
	return float2(
		min3( a.x, b.x, c.x ),
		min3( a.y, b.y, c.y )
	);
}

float2 max3( float2 a, float2 b, float2 c )
{
	return float2(
		max3( a.x, b.x, c.x ),
		max3( a.y, b.y, c.y )
	);
}

float3 max3( float3 a, float3 b, float3 c )
{
	return float3(
		max3( a.x, b.x, c.x ),
		max3( a.y, b.y, c.y ),
		max3( a.z, b.z, c.z )
	);
}

float3 min3( float3 a, float3 b, float3 c )
{
	return float3(
		min3( a.x, b.x, c.x ),
		min3( a.y, b.y, c.y ),
		min3( a.z, b.z, c.z )
	);
}

float4 min3( float4 a, float4 b, float4 c )
{
	return float4(
		min3( a.x, b.x, c.x ),
		min3( a.y, b.y, c.y ),
		min3( a.z, b.z, c.z ),
		min3( a.w, b.w, c.w )
	);
}

float4 max3( float4 a, float4 b, float4 c )
{
	return float4(
		max3( a.x, b.x, c.x ),
		max3( a.y, b.y, c.y ),
		max3( a.z, b.z, c.z ),
		max3( a.w, b.w, c.w )
	);
}
#line 901 "/Engine/Public/Platform.ush"
bool select_internal(bool c, bool a, bool b) { return bool (c ? a.x : b.x); } bool2 select_internal(bool c, bool a, bool2 b) { return bool2 (c ? a : b.x, c ? a : b.y); } bool2 select_internal(bool c, bool2 a, bool b) { return bool2 (c ? a.x : b , c ? a.y : b ); } bool2 select_internal(bool c, bool2 a, bool2 b) { return bool2 (c ? a.x : b.x, c ? a.y : b.y); } bool2 select_internal(bool2 c, bool a, bool b) { return bool2 (c.x ? a : b , c.y ? a : b ); } bool2 select_internal(bool2 c, bool a, bool2 b) { return bool2 (c.x ? a : b.x, c.y ? a : b.y); } bool2 select_internal(bool2 c, bool2 a, bool b) { return bool2 (c.x ? a.x : b , c.y ? a.y : b ); } bool2 select_internal(bool2 c, bool2 a, bool2 b) { return bool2 (c.x ? a.x : b.x, c.y ? a.y : b.y); } bool3 select_internal(bool c, bool a, bool3 b) { return bool3 (c ? a : b.x, c ? a : b.y, c ? a : b.z); } bool3 select_internal(bool c, bool3 a, bool b) { return bool3 (c ? a.x : b , c ? a.y : b , c ? a.z : b ); } bool3 select_internal(bool c, bool3 a, bool3 b) { return bool3 (c ? a.x : b.x, c ? a.y : b.y, c ? a.z : b.z); } bool3 select_internal(bool3 c, bool a, bool b) { return bool3 (c.x ? a : b , c.y ? a : b , c.z ? a : b ); } bool3 select_internal(bool3 c, bool a, bool3 b) { return bool3 (c.x ? a : b.x, c.y ? a : b.y, c.z ? a : b.z); } bool3 select_internal(bool3 c, bool3 a, bool b) { return bool3 (c.x ? a.x : b , c.y ? a.y : b , c.z ? a.z : b ); } bool3 select_internal(bool3 c, bool3 a, bool3 b) { return bool3 (c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z); } bool4 select_internal(bool c, bool a, bool4 b) { return bool4 (c ? a : b.x, c ? a : b.y, c ? a : b.z, c ? a : b.w); } bool4 select_internal(bool c, bool4 a, bool b) { return bool4 (c ? a.x : b , c ? a.y : b , c ? a.z : b , c ? a.w : b ); } bool4 select_internal(bool c, bool4 a, bool4 b) { return bool4 (c ? a.x : b.x, c ? a.y : b.y, c ? a.z : b.z, c ? a.w : b.w); } bool4 select_internal(bool4 c, bool a, bool b) { return bool4 (c.x ? a : b , c.y ? a : b , c.z ? a : b , c.w ? a : b ); } bool4 select_internal(bool4 c, bool a, bool4 b) { return bool4 (c.x ? a : b.x, c.y ? a : b.y, c.z ? a : b.z, c.w ? a : b.w); } bool4 select_internal(bool4 c, bool4 a, bool b) { return bool4 (c.x ? a.x : b , c.y ? a.y : b , c.z ? a.z : b , c.w ? a.w : b ); } bool4 select_internal(bool4 c, bool4 a, bool4 b) { return bool4 (c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z, c.w ? a.w : b.w); }
uint select_internal(bool c, uint a, uint b) { return uint (c ? a.x : b.x); } uint2 select_internal(bool c, uint a, uint2 b) { return uint2 (c ? a : b.x, c ? a : b.y); } uint2 select_internal(bool c, uint2 a, uint b) { return uint2 (c ? a.x : b , c ? a.y : b ); } uint2 select_internal(bool c, uint2 a, uint2 b) { return uint2 (c ? a.x : b.x, c ? a.y : b.y); } uint2 select_internal(bool2 c, uint a, uint b) { return uint2 (c.x ? a : b , c.y ? a : b ); } uint2 select_internal(bool2 c, uint a, uint2 b) { return uint2 (c.x ? a : b.x, c.y ? a : b.y); } uint2 select_internal(bool2 c, uint2 a, uint b) { return uint2 (c.x ? a.x : b , c.y ? a.y : b ); } uint2 select_internal(bool2 c, uint2 a, uint2 b) { return uint2 (c.x ? a.x : b.x, c.y ? a.y : b.y); } uint3 select_internal(bool c, uint a, uint3 b) { return uint3 (c ? a : b.x, c ? a : b.y, c ? a : b.z); } uint3 select_internal(bool c, uint3 a, uint b) { return uint3 (c ? a.x : b , c ? a.y : b , c ? a.z : b ); } uint3 select_internal(bool c, uint3 a, uint3 b) { return uint3 (c ? a.x : b.x, c ? a.y : b.y, c ? a.z : b.z); } uint3 select_internal(bool3 c, uint a, uint b) { return uint3 (c.x ? a : b , c.y ? a : b , c.z ? a : b ); } uint3 select_internal(bool3 c, uint a, uint3 b) { return uint3 (c.x ? a : b.x, c.y ? a : b.y, c.z ? a : b.z); } uint3 select_internal(bool3 c, uint3 a, uint b) { return uint3 (c.x ? a.x : b , c.y ? a.y : b , c.z ? a.z : b ); } uint3 select_internal(bool3 c, uint3 a, uint3 b) { return uint3 (c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z); } uint4 select_internal(bool c, uint a, uint4 b) { return uint4 (c ? a : b.x, c ? a : b.y, c ? a : b.z, c ? a : b.w); } uint4 select_internal(bool c, uint4 a, uint b) { return uint4 (c ? a.x : b , c ? a.y : b , c ? a.z : b , c ? a.w : b ); } uint4 select_internal(bool c, uint4 a, uint4 b) { return uint4 (c ? a.x : b.x, c ? a.y : b.y, c ? a.z : b.z, c ? a.w : b.w); } uint4 select_internal(bool4 c, uint a, uint b) { return uint4 (c.x ? a : b , c.y ? a : b , c.z ? a : b , c.w ? a : b ); } uint4 select_internal(bool4 c, uint a, uint4 b) { return uint4 (c.x ? a : b.x, c.y ? a : b.y, c.z ? a : b.z, c.w ? a : b.w); } uint4 select_internal(bool4 c, uint4 a, uint b) { return uint4 (c.x ? a.x : b , c.y ? a.y : b , c.z ? a.z : b , c.w ? a.w : b ); } uint4 select_internal(bool4 c, uint4 a, uint4 b) { return uint4 (c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z, c.w ? a.w : b.w); }
int select_internal(bool c, int a, int b) { return int (c ? a.x : b.x); } int2 select_internal(bool c, int a, int2 b) { return int2 (c ? a : b.x, c ? a : b.y); } int2 select_internal(bool c, int2 a, int b) { return int2 (c ? a.x : b , c ? a.y : b ); } int2 select_internal(bool c, int2 a, int2 b) { return int2 (c ? a.x : b.x, c ? a.y : b.y); } int2 select_internal(bool2 c, int a, int b) { return int2 (c.x ? a : b , c.y ? a : b ); } int2 select_internal(bool2 c, int a, int2 b) { return int2 (c.x ? a : b.x, c.y ? a : b.y); } int2 select_internal(bool2 c, int2 a, int b) { return int2 (c.x ? a.x : b , c.y ? a.y : b ); } int2 select_internal(bool2 c, int2 a, int2 b) { return int2 (c.x ? a.x : b.x, c.y ? a.y : b.y); } int3 select_internal(bool c, int a, int3 b) { return int3 (c ? a : b.x, c ? a : b.y, c ? a : b.z); } int3 select_internal(bool c, int3 a, int b) { return int3 (c ? a.x : b , c ? a.y : b , c ? a.z : b ); } int3 select_internal(bool c, int3 a, int3 b) { return int3 (c ? a.x : b.x, c ? a.y : b.y, c ? a.z : b.z); } int3 select_internal(bool3 c, int a, int b) { return int3 (c.x ? a : b , c.y ? a : b , c.z ? a : b ); } int3 select_internal(bool3 c, int a, int3 b) { return int3 (c.x ? a : b.x, c.y ? a : b.y, c.z ? a : b.z); } int3 select_internal(bool3 c, int3 a, int b) { return int3 (c.x ? a.x : b , c.y ? a.y : b , c.z ? a.z : b ); } int3 select_internal(bool3 c, int3 a, int3 b) { return int3 (c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z); } int4 select_internal(bool c, int a, int4 b) { return int4 (c ? a : b.x, c ? a : b.y, c ? a : b.z, c ? a : b.w); } int4 select_internal(bool c, int4 a, int b) { return int4 (c ? a.x : b , c ? a.y : b , c ? a.z : b , c ? a.w : b ); } int4 select_internal(bool c, int4 a, int4 b) { return int4 (c ? a.x : b.x, c ? a.y : b.y, c ? a.z : b.z, c ? a.w : b.w); } int4 select_internal(bool4 c, int a, int b) { return int4 (c.x ? a : b , c.y ? a : b , c.z ? a : b , c.w ? a : b ); } int4 select_internal(bool4 c, int a, int4 b) { return int4 (c.x ? a : b.x, c.y ? a : b.y, c.z ? a : b.z, c.w ? a : b.w); } int4 select_internal(bool4 c, int4 a, int b) { return int4 (c.x ? a.x : b , c.y ? a.y : b , c.z ? a.z : b , c.w ? a.w : b ); } int4 select_internal(bool4 c, int4 a, int4 b) { return int4 (c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z, c.w ? a.w : b.w); }
float select_internal(bool c, float a, float b) { return float (c ? a.x : b.x); } float2 select_internal(bool c, float a, float2 b) { return float2 (c ? a : b.x, c ? a : b.y); } float2 select_internal(bool c, float2 a, float b) { return float2 (c ? a.x : b , c ? a.y : b ); } float2 select_internal(bool c, float2 a, float2 b) { return float2 (c ? a.x : b.x, c ? a.y : b.y); } float2 select_internal(bool2 c, float a, float b) { return float2 (c.x ? a : b , c.y ? a : b ); } float2 select_internal(bool2 c, float a, float2 b) { return float2 (c.x ? a : b.x, c.y ? a : b.y); } float2 select_internal(bool2 c, float2 a, float b) { return float2 (c.x ? a.x : b , c.y ? a.y : b ); } float2 select_internal(bool2 c, float2 a, float2 b) { return float2 (c.x ? a.x : b.x, c.y ? a.y : b.y); } float3 select_internal(bool c, float a, float3 b) { return float3 (c ? a : b.x, c ? a : b.y, c ? a : b.z); } float3 select_internal(bool c, float3 a, float b) { return float3 (c ? a.x : b , c ? a.y : b , c ? a.z : b ); } float3 select_internal(bool c, float3 a, float3 b) { return float3 (c ? a.x : b.x, c ? a.y : b.y, c ? a.z : b.z); } float3 select_internal(bool3 c, float a, float b) { return float3 (c.x ? a : b , c.y ? a : b , c.z ? a : b ); } float3 select_internal(bool3 c, float a, float3 b) { return float3 (c.x ? a : b.x, c.y ? a : b.y, c.z ? a : b.z); } float3 select_internal(bool3 c, float3 a, float b) { return float3 (c.x ? a.x : b , c.y ? a.y : b , c.z ? a.z : b ); } float3 select_internal(bool3 c, float3 a, float3 b) { return float3 (c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z); } float4 select_internal(bool c, float a, float4 b) { return float4 (c ? a : b.x, c ? a : b.y, c ? a : b.z, c ? a : b.w); } float4 select_internal(bool c, float4 a, float b) { return float4 (c ? a.x : b , c ? a.y : b , c ? a.z : b , c ? a.w : b ); } float4 select_internal(bool c, float4 a, float4 b) { return float4 (c ? a.x : b.x, c ? a.y : b.y, c ? a.z : b.z, c ? a.w : b.w); } float4 select_internal(bool4 c, float a, float b) { return float4 (c.x ? a : b , c.y ? a : b , c.z ? a : b , c.w ? a : b ); } float4 select_internal(bool4 c, float a, float4 b) { return float4 (c.x ? a : b.x, c.y ? a : b.y, c.z ? a : b.z, c.w ? a : b.w); } float4 select_internal(bool4 c, float4 a, float b) { return float4 (c.x ? a.x : b , c.y ? a.y : b , c.z ? a.z : b , c.w ? a.w : b ); } float4 select_internal(bool4 c, float4 a, float4 b) { return float4 (c.x ? a.x : b.x, c.y ? a.y : b.y, c.z ? a.z : b.z, c.w ? a.w : b.w); }
#line 913 "/Engine/Public/Platform.ush"
bool and_internal(bool a, bool b) { return bool(a && b); }
bool2 and_internal(bool2 a, bool2 b) { return bool2(a.x && b.x, a.y && b.y); }
bool3 and_internal(bool3 a, bool3 b) { return bool3(a.x && b.x, a.y && b.y, a.z && b.z); }
bool4 and_internal(bool4 a, bool4 b) { return bool4(a.x && b.x, a.y && b.y, a.z && b.z, a.w && b.w); }

bool or_internal(bool a, bool b) { return bool(a || b); }
bool2 or_internal(bool2 a, bool2 b) { return bool2(a.x || b.x, a.y || b.y); }
bool3 or_internal(bool3 a, bool3 b) { return bool3(a.x || b.x, a.y || b.y, a.z || b.z); }
bool4 or_internal(bool4 a, bool4 b) { return bool4(a.x || b.x, a.y || b.y, a.z || b.z, a.w || b.w); }
#line 949 "/Engine/Public/Platform.ush"
float CondMask(bool Cond, float Src0, float Src1) { return Cond ? Src0 : Src1; }
float2 CondMask(bool Cond, float2 Src0, float2 Src1) { return Cond ? Src0 : Src1; }
float3 CondMask(bool Cond, float3 Src0, float3 Src1) { return Cond ? Src0 : Src1; }
float4 CondMask(bool Cond, float4 Src0, float4 Src1) { return Cond ? Src0 : Src1; }

int CondMask(bool Cond, int Src0, int Src1) { return Cond ? Src0 : Src1; }
int2 CondMask(bool Cond, int2 Src0, int2 Src1) { return Cond ? Src0 : Src1; }
int3 CondMask(bool Cond, int3 Src0, int3 Src1) { return Cond ? Src0 : Src1; }
int4 CondMask(bool Cond, int4 Src0, int4 Src1) { return Cond ? Src0 : Src1; }

uint CondMask(bool Cond, uint Src0, uint Src1) { return Cond ? Src0 : Src1; }
uint2 CondMask(bool Cond, uint2 Src0, uint2 Src1) { return Cond ? Src0 : Src1; }
uint3 CondMask(bool Cond, uint3 Src0, uint3 Src1) { return Cond ? Src0 : Src1; }
uint4 CondMask(bool Cond, uint4 Src0, uint4 Src1) { return Cond ? Src0 : Src1; }




float UnpackByte0(uint v) { return float(v & 0xff); }
float UnpackByte1(uint v) { return float((v >> 8) & 0xff); }
float UnpackByte2(uint v) { return float((v >> 16) & 0xff); }
float UnpackByte3(uint v) { return float(v >> 24); }









uint BitFieldInsertU32(uint Mask, uint Preserve, uint Enable)
{
	return (Preserve & Mask) | (Enable & ~Mask);
}

uint BitFieldExtractU32(uint Data, uint Size, uint Offset)
{


	Size &= 31;
	Offset &= 31;
	return (Data >> Offset) & ((1u << Size) - 1u);
}

int BitFieldExtractI32(int Data, uint Size, uint Offset)
{
	Size &= 31u;
	Offset &= 31u;
	const uint Shift = (32u - Size) & 31u;
	const int Value = (Data >> Offset) & int((1u << Size) - 1u);
	return (Value << Shift) >> Shift;
}

uint BitFieldMaskU32(uint MaskWidth, uint MaskLocation)
{
	MaskWidth &= 31u;
	MaskLocation &= 31u;

	return ((1u << MaskWidth) - 1u) << MaskLocation;
}




uint BitAlignU32(uint High, uint Low, uint Shift)
{
	Shift &= 31u;

	uint Result = Low >> Shift;
	Result |= Shift > 0u ? (High << (32u - Shift)) : 0u;
	return Result;
}




uint ByteAlignU32(uint High, uint Low, uint Shift)
{
	return BitAlignU32(High, Low, Shift * 8);
}
#line 1054 "/Engine/Public/Platform.ush"
uint MaskedBitCount( uint2 Bits, uint Index )
{
	bool bLow = Index < 32;

	uint Mask = 1u << ( Index - ( bLow ? 0 : 32 ) );
	Mask -= 1;

	uint Offset;
	Offset = countbits( Bits.x & ( bLow ? Mask : ~0u ) );
	Offset += countbits( Bits.y & ( bLow ? 0 : Mask ) );
	return Offset;
}
#line 1086 "/Engine/Public/Platform.ush"
uint MaskedBitCount( uint2 Bits )
{
	return MaskedBitCount( Bits, WaveGetLaneIndex() );
}



uint2 WaveBallot( bool Expr )
{
	return WaveActiveBallot( Expr ).xy;
}



uint WaveGetActiveLaneIndexLast()
{
	uint2 ActiveMask = WaveActiveBallot( true ).xy;
	return firstbithigh( ActiveMask.y ? ActiveMask.y : ActiveMask.x ) + ( ActiveMask.y ? 32 : 0 );
}
#line 10 "/Engine/Private/Common.ush"
#line 31 "/Engine/Private/Common.ush"
struct FloatDeriv
{
	float Value;
	float Ddx;
	float Ddy;
};

struct FloatDeriv2
{
	float2 Value;
	float2 Ddx;
	float2 Ddy;
};

struct FloatDeriv3
{
	float3 Value;
	float3 Ddx;
	float3 Ddy;
};

struct FloatDeriv4
{
	float4 Value;
	float4 Ddx;
	float4 Ddy;
};

FloatDeriv ConstructFloatDeriv(float InValue, float InDdx, float InDdy)
{
	FloatDeriv Ret;
	Ret.Value = InValue;
	Ret.Ddx = InDdx;
	Ret.Ddy = InDdy;
	return Ret;
}

FloatDeriv2 ConstructFloatDeriv2(float2 InValue, float2 InDdx, float2 InDdy)
{
	FloatDeriv2 Ret;
	Ret.Value = InValue;
	Ret.Ddx = InDdx;
	Ret.Ddy = InDdy;
	return Ret;
}

FloatDeriv3 ConstructFloatDeriv3(float3 InValue, float3 InDdx, float3 InDdy)
{
	FloatDeriv3 Ret;
	Ret.Value = InValue;
	Ret.Ddx = InDdx;
	Ret.Ddy = InDdy;
	return Ret;
}

FloatDeriv4 ConstructFloatDeriv4(float4 InValue, float4 InDdx, float4 InDdy)
{
	FloatDeriv4 Ret;
	Ret.Value = InValue;
	Ret.Ddx = InDdx;
	Ret.Ddy = InDdy;
	return Ret;
}
#line 109 "/Engine/Private/Common.ush"
const static  float  PI = 3.1415926535897932f;
const static float MaxHalfFloat = 65504.0f;
const static float Max11BitsFloat = 65024.0f;
const static float Max10BitsFloat = 64512.0f;
const static float3 Max111110BitsFloat3 = float3(Max11BitsFloat, Max11BitsFloat, Max10BitsFloat);
#line 166 "/Engine/Private/Common.ush"
#line 1 "GeneratedUniformBufferTypes.ush"
#line 8 "/Engine/Private/GeneratedUniformBufferTypes.ush"
#line 1 "Nanite/NanitePackedNaniteView.ush"
#line 5 "/Engine/Private/Nanite/NanitePackedNaniteView.ush"
struct FPackedNaniteView
{
	float4x4 SVPositionToTranslatedWorld;
	float4x4 ViewToTranslatedWorld;

	float4x4 TranslatedWorldToView;
	float4x4 TranslatedWorldToClip;
	float4x4 TranslatedWorldToSubpixelClip;
	float4x4 ViewToClip;
	float4x4 ClipToRelativeWorld;

	float4x4 PrevTranslatedWorldToView;
	float4x4 PrevTranslatedWorldToClip;
	float4x4 PrevViewToClip;
	float4x4 PrevClipToRelativeWorld;

	int4 ViewRect;
	float4 ViewSizeAndInvSize;
	float4 ClipSpaceScaleOffset;
	float4 PreViewTranslation;
	float4 PrevPreViewTranslation;
	float4 WorldCameraOrigin;
	float4 ViewForwardAndNearPlane;

	float3 ViewTilePosition;
	float RangeBasedCullingDistance;

	float3 MatrixTilePosition;
	float Padding1;

	float2 LODScales;
	float MinBoundsRadiusSq;
	uint StreamingPriorityCategory_AndFlags;

	int4 TargetLayerIdX_AndMipLevelY_AndNumMipLevelsZ;

	int4 HZBTestViewRect;
};
#line 9 "/Engine/Private/GeneratedUniformBufferTypes.ush"
#line 11 "/Engine/Private/GeneratedUniformBufferTypes.ush"
#line 1 "HairStrands/HairStrandsVisibilityCommonStruct.ush"
#line 5 "/Engine/Private/HairStrands/HairStrandsVisibilityCommonStruct.ush"
struct FPackedHairSample
{
	float Depth;
	uint PrimitiveID_MacroGroupID;
	uint Tangent_Coverage8bit;
	uint BaseColor_Roughness;
	uint Specular_LightChannels_Backlit;
};

struct FPackedHairVis
{
	uint Depth_Coverage8bit;
	uint PrimitiveID_MaterialID;
};

struct FPackedHairVisPPLL
{
	uint Depth_Coverage8bit;
	uint PrimitiveID_MaterialID;
	uint NextNodeIndex;
};
#line 12 "/Engine/Private/GeneratedUniformBufferTypes.ush"
#line 1 "HairStrands/HairStrandsVoxelPageCommonStruct.ush"
#line 5 "/Engine/Private/HairStrands/HairStrandsVoxelPageCommonStruct.ush"
struct FPackedVirtualVoxelNodeDesc
{
	float3 TranslatedWorldMinAABB;
	uint PackedPageIndexResolution;
	float3 TranslatedWorldMaxAABB;
	uint PageIndexOffset_VoxelWorldSize;
};

struct FVoxelizationViewInfo
{
	float4x4 TranslatedWorldToClip;
	float3 ViewForward;
	float Pad0;
	uint2 RasterResolution;
	float2 Pad1;
};
#line 13 "/Engine/Private/GeneratedUniformBufferTypes.ush"
#line 1 "HairStrands/HairStrandsDeepShadowCommonStruct.ush"
#line 5 "/Engine/Private/HairStrands/HairStrandsDeepShadowCommonStruct.ush"
struct FDeepShadowViewInfo
{
	float4x4 TranslatedWorldToClipScaledBiased;
	float4x4 TranslatedWorldToClip;
	float4 AtlasScaleBias;
	float3 ViewForward;
	float MinRadiusAtDepth1;
};
#line 14 "/Engine/Private/GeneratedUniformBufferTypes.ush"
#line 167 "/Engine/Private/Common.ush"
#line 169 "/Engine/Private/Common.ush"
#line 1 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/View.ush"


cbuffer  UniformBufferConstants_View
{
	float4x4 View_TranslatedWorldToClip;
	float4x4 View_TranslatedWorldToSubpixelClip;
	float4x4 View_RelativeWorldToClip;
	float4x4 View_ClipToRelativeWorld;
	float4x4 View_TranslatedWorldToView;
	float4x4 View_ViewToTranslatedWorld;
	float4x4 View_TranslatedWorldToCameraView;
	float4x4 View_CameraViewToTranslatedWorld;
	float4x4 View_ViewToClip;
	float4x4 View_ViewToClipNoAA;
	float4x4 View_ClipToView;
	float4x4 View_ClipToTranslatedWorld;
	float4x4 View_SVPositionToTranslatedWorld;
	float4x4 View_ScreenToRelativeWorld;
	float4x4 View_ScreenToTranslatedWorld;
	float4x4 View_MobileMultiviewShadowTransform;
	float3 View_ViewTilePosition;
	float PrePadding_View_1036;
	float3 View_MatrixTilePosition;
	float PrePadding_View_1052;
	float3 View_ViewForward;
	float PrePadding_View_1068;
	float3 View_ViewUp;
	float PrePadding_View_1084;
	float3 View_ViewRight;
	float PrePadding_View_1100;
	float3 View_HMDViewNoRollUp;
	float PrePadding_View_1116;
	float3 View_HMDViewNoRollRight;
	float PrePadding_View_1132;
	float4 View_InvDeviceZToWorldZTransform;
	float4 View_ScreenPositionScaleBias;
	float3 View_RelativeWorldCameraOrigin;
	float PrePadding_View_1180;
	float3 View_TranslatedWorldCameraOrigin;
	float PrePadding_View_1196;
	float3 View_RelativeWorldViewOrigin;
	float PrePadding_View_1212;
	float3 View_RelativePreViewTranslation;
	float PrePadding_View_1228;
	float4x4 View_PrevViewToClip;
	float4x4 View_PrevClipToView;
	float4x4 View_PrevTranslatedWorldToClip;
	float4x4 View_PrevTranslatedWorldToView;
	float4x4 View_PrevViewToTranslatedWorld;
	float4x4 View_PrevTranslatedWorldToCameraView;
	float4x4 View_PrevCameraViewToTranslatedWorld;
	float3 View_PrevTranslatedWorldCameraOrigin;
	float PrePadding_View_1692;
	float3 View_PrevRelativeWorldCameraOrigin;
	float PrePadding_View_1708;
	float3 View_PrevRelativeWorldViewOrigin;
	float PrePadding_View_1724;
	float3 View_RelativePrevPreViewTranslation;
	float PrePadding_View_1740;
	float4x4 View_PrevClipToRelativeWorld;
	float4x4 View_PrevScreenToTranslatedWorld;
	float4x4 View_ClipToPrevClip;
	float4x4 View_ClipToPrevClipWithAA;
	float4 View_TemporalAAJitter;
	float4 View_GlobalClippingPlane;
	float2 View_FieldOfViewWideAngles;
	float2 View_PrevFieldOfViewWideAngles;
	float4 View_ViewRectMin;
	float4 View_ViewSizeAndInvSize;
	uint4 View_ViewRectMinAndSize;
	float4 View_LightProbeSizeRatioAndInvSizeRatio;
	float4 View_BufferSizeAndInvSize;
	float4 View_BufferBilinearUVMinMax;
	float4 View_ScreenToViewSpace;
	float2 View_BufferToSceneTextureScale;
	float2 View_ResolutionFractionAndInv;
	int View_NumSceneColorMSAASamples;
	float View_SeparateWaterMainDirLightLuminance;
	float View_PreExposure;
	float View_OneOverPreExposure;
	float4 View_DiffuseOverrideParameter;
	float4 View_SpecularOverrideParameter;
	float4 View_NormalOverrideParameter;
	float2 View_RoughnessOverrideParameter;
	float View_PrevFrameGameTime;
	float View_PrevFrameRealTime;
	float View_OutOfBoundsMask;
	float PrePadding_View_2260;
	float PrePadding_View_2264;
	float PrePadding_View_2268;
	float3 View_WorldCameraMovementSinceLastFrame;
	float View_CullingSign;
	float View_NearPlane;
	float View_GameTime;
	float View_RealTime;
	float View_DeltaTime;
	float View_MaterialTextureMipBias;
	float View_MaterialTextureDerivativeMultiply;
	uint View_Random;
	uint View_FrameNumber;
	uint View_StateFrameIndexMod8;
	uint View_StateFrameIndex;
	uint View_DebugViewModeMask;
	float View_CameraCut;
	float View_UnlitViewmodeMask;
	float PrePadding_View_2340;
	float PrePadding_View_2344;
	float PrePadding_View_2348;
	float4 View_DirectionalLightColor;
	float3 View_DirectionalLightDirection;
	float PrePadding_View_2380;
	float4 View_TranslucencyLightingVolumeMin[2];
	float4 View_TranslucencyLightingVolumeInvSize[2];
	float4 View_TemporalAAParams;
	float4 View_CircleDOFParams;
	float View_DepthOfFieldSensorWidth;
	float View_DepthOfFieldFocalDistance;
	float View_DepthOfFieldScale;
	float View_DepthOfFieldFocalLength;
	float View_DepthOfFieldFocalRegion;
	float View_DepthOfFieldNearTransitionRegion;
	float View_DepthOfFieldFarTransitionRegion;
	float View_MotionBlurNormalizedToPixel;
	float View_GeneralPurposeTweak;
	float View_GeneralPurposeTweak2;
	float View_DemosaicVposOffset;
	float View_DecalDepthBias;
	float3 View_IndirectLightingColorScale;
	float PrePadding_View_2540;
	float3 View_PrecomputedIndirectLightingColorScale;
	float PrePadding_View_2556;
	float3 View_PrecomputedIndirectSpecularColorScale;
	float PrePadding_View_2572;
	float4 View_AtmosphereLightDirection[2];
	float4 View_AtmosphereLightIlluminanceOnGroundPostTransmittance[2];
	float4 View_AtmosphereLightIlluminanceOuterSpace[2];
	float4 View_AtmosphereLightDiscLuminance[2];
	float4 View_AtmosphereLightDiscCosHalfApexAngle_PPTrans[2];
	float4 View_SkyViewLutSizeAndInvSize;
	float3 View_SkyCameraTranslatedWorldOrigin;
	float PrePadding_View_2764;
	float4 View_SkyPlanetTranslatedWorldCenterAndViewHeight;
	float4x4 View_SkyViewLutReferential;
	float4 View_SkyAtmosphereSkyLuminanceFactor;
	float View_SkyAtmospherePresentInScene;
	float View_SkyAtmosphereHeightFogContribution;
	float View_SkyAtmosphereBottomRadiusKm;
	float View_SkyAtmosphereTopRadiusKm;
	float4 View_SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize;
	float View_SkyAtmosphereAerialPerspectiveStartDepthKm;
	float View_SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution;
	float View_SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv;
	float View_SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm;
	float View_SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv;
	float View_SkyAtmosphereApplyCameraAerialPerspectiveVolume;
	float PrePadding_View_2920;
	float PrePadding_View_2924;
	float3 View_NormalCurvatureToRoughnessScaleBias;
	float View_RenderingReflectionCaptureMask;
	float View_RealTimeReflectionCapture;
	float View_RealTimeReflectionCapturePreExposure;
	float PrePadding_View_2952;
	float PrePadding_View_2956;
	float4 View_AmbientCubemapTint;
	float View_AmbientCubemapIntensity;
	float View_SkyLightApplyPrecomputedBentNormalShadowingFlag;
	float View_SkyLightAffectReflectionFlag;
	float View_SkyLightAffectGlobalIlluminationFlag;
	float4 View_SkyLightColor;
	float4 View_MobileSkyIrradianceEnvironmentMap[8];
	float View_MobilePreviewMode;
	float View_HMDEyePaddingOffset;
	float View_ReflectionCubemapMaxMip;
	float View_ShowDecalsMask;
	uint View_DistanceFieldAOSpecularOcclusionMode;
	float View_IndirectCapsuleSelfShadowingIntensity;
	float PrePadding_View_3160;
	float PrePadding_View_3164;
	float3 View_ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	int View_StereoPassIndex;
	float4 View_GlobalVolumeCenterAndExtent[6];
	float4 View_GlobalVolumeWorldToUVAddAndMul[6];
	float4 View_GlobalDistanceFieldMipWorldToUVScale[6];
	float4 View_GlobalDistanceFieldMipWorldToUVBias[6];
	float View_GlobalDistanceFieldMipFactor;
	float View_GlobalDistanceFieldMipTransition;
	int View_GlobalDistanceFieldClipmapSizeInPages;
	int PrePadding_View_3580;
	float3 View_GlobalDistanceFieldInvPageAtlasSize;
	float PrePadding_View_3596;
	float3 View_GlobalDistanceFieldInvCoverageAtlasSize;
	float View_GlobalVolumeDimension;
	float View_GlobalVolumeTexelSize;
	float View_MaxGlobalDFAOConeDistance;
	uint View_NumGlobalSDFClipmaps;
	float View_CoveredExpandSurfaceScale;
	float View_NotCoveredExpandSurfaceScale;
	float View_NotCoveredMinStepScale;
	float View_DitheredTransparencyStepThreshold;
	float View_DitheredTransparencyTraceThreshold;
	int2 View_CursorPosition;
	float View_bCheckerboardSubsurfaceProfileRendering;
	float PrePadding_View_3660;
	float3 View_VolumetricFogInvGridSize;
	float PrePadding_View_3676;
	float3 View_VolumetricFogGridZParams;
	float PrePadding_View_3692;
	float2 View_VolumetricFogSVPosToVolumeUV;
	float View_VolumetricFogMaxDistance;
	float PrePadding_View_3708;
	float3 View_VolumetricLightmapWorldToUVScale;
	float PrePadding_View_3724;
	float3 View_VolumetricLightmapWorldToUVAdd;
	float PrePadding_View_3740;
	float3 View_VolumetricLightmapIndirectionTextureSize;
	float View_VolumetricLightmapBrickSize;
	float3 View_VolumetricLightmapBrickTexelSize;
	float View_IndirectLightingCacheShowFlag;
	float View_EyeToPixelSpreadAngle;
	float PrePadding_View_3780;
	float PrePadding_View_3784;
	float PrePadding_View_3788;
	float4 View_XRPassthroughCameraUVs[2];
	float View_GlobalVirtualTextureMipBias;
	uint View_VirtualTextureFeedbackShift;
	uint View_VirtualTextureFeedbackMask;
	uint View_VirtualTextureFeedbackStride;
	uint View_VirtualTextureFeedbackJitterOffset;
	uint View_VirtualTextureFeedbackSampleOffset;
	uint PrePadding_View_3848;
	uint PrePadding_View_3852;
	float4 View_RuntimeVirtualTextureMipLevel;
	float2 View_RuntimeVirtualTexturePackHeight;
	float PrePadding_View_3880;
	float PrePadding_View_3884;
	float4 View_RuntimeVirtualTextureDebugParams;
	float View_OverrideLandscapeLOD;
	int View_FarShadowStaticMeshLODBias;
	float View_MinRoughness;
	float PrePadding_View_3916;
	float4 View_HairRenderInfo;
	uint View_EnableSkyLight;
	uint View_HairRenderInfoBits;
	uint View_HairComponents;
	float View_bSubsurfacePostprocessEnabled;
	float4 View_SSProfilesTextureSizeAndInvSize;
	float4 View_SSProfilesPreIntegratedTextureSizeAndInvSize;
	float3 View_PhysicsFieldClipmapCenter;
	float View_PhysicsFieldClipmapDistance;
	int View_PhysicsFieldClipmapResolution;
	int View_PhysicsFieldClipmapExponent;
	int View_PhysicsFieldClipmapCount;
	int View_PhysicsFieldTargetCount;
	int4 View_PhysicsFieldTargets[32];
	uint View_InstanceSceneDataSOAStride;
	uint View_GPUSceneViewId;
	float View_ViewResolutionFraction;
	float View_SubSurfaceColorAsTransmittanceAtDistanceInMeters;
	uint BindlessSampler_View_MaterialTextureBilinearWrapedSampler ;
	uint PrePadding_View_4548;
	uint BindlessSampler_View_MaterialTextureBilinearClampedSampler ;
	uint PrePadding_View_4556;
	uint BindlessResource_View_VolumetricLightmapIndirectionTexture ;
	uint PrePadding_View_4564;
	uint BindlessResource_View_VolumetricLightmapBrickAmbientVector ;
	uint PrePadding_View_4572;
	uint BindlessResource_View_VolumetricLightmapBrickSHCoefficients0 ;
	uint PrePadding_View_4580;
	uint BindlessResource_View_VolumetricLightmapBrickSHCoefficients1 ;
	uint PrePadding_View_4588;
	uint BindlessResource_View_VolumetricLightmapBrickSHCoefficients2 ;
	uint PrePadding_View_4596;
	uint BindlessResource_View_VolumetricLightmapBrickSHCoefficients3 ;
	uint PrePadding_View_4604;
	uint BindlessResource_View_VolumetricLightmapBrickSHCoefficients4 ;
	uint PrePadding_View_4612;
	uint BindlessResource_View_VolumetricLightmapBrickSHCoefficients5 ;
	uint PrePadding_View_4620;
	uint BindlessResource_View_SkyBentNormalBrickTexture ;
	uint PrePadding_View_4628;
	uint BindlessResource_View_DirectionalLightShadowingBrickTexture ;
	uint PrePadding_View_4636;
	uint BindlessSampler_View_VolumetricLightmapBrickAmbientVectorSampler ;
	uint PrePadding_View_4644;
	uint BindlessSampler_View_VolumetricLightmapTextureSampler0 ;
	uint PrePadding_View_4652;
	uint BindlessSampler_View_VolumetricLightmapTextureSampler1 ;
	uint PrePadding_View_4660;
	uint BindlessSampler_View_VolumetricLightmapTextureSampler2 ;
	uint PrePadding_View_4668;
	uint BindlessSampler_View_VolumetricLightmapTextureSampler3 ;
	uint PrePadding_View_4676;
	uint BindlessSampler_View_VolumetricLightmapTextureSampler4 ;
	uint PrePadding_View_4684;
	uint BindlessSampler_View_VolumetricLightmapTextureSampler5 ;
	uint PrePadding_View_4692;
	uint BindlessSampler_View_SkyBentNormalTextureSampler ;
	uint PrePadding_View_4700;
	uint BindlessSampler_View_DirectionalLightShadowingTextureSampler ;
	uint PrePadding_View_4708;
	uint BindlessResource_View_GlobalDistanceFieldPageAtlasTexture ;
	uint PrePadding_View_4716;
	uint BindlessResource_View_GlobalDistanceFieldCoverageAtlasTexture ;
	uint PrePadding_View_4724;
	uint BindlessResource_View_GlobalDistanceFieldPageTableTexture ;
	uint PrePadding_View_4732;
	uint BindlessResource_View_GlobalDistanceFieldMipTexture ;
	uint PrePadding_View_4740;
	uint BindlessResource_View_AtmosphereTransmittanceTexture ;
	uint PrePadding_View_4748;
	uint BindlessSampler_View_AtmosphereTransmittanceTextureSampler ;
	uint PrePadding_View_4756;
	uint BindlessResource_View_AtmosphereIrradianceTexture ;
	uint PrePadding_View_4764;
	uint BindlessSampler_View_AtmosphereIrradianceTextureSampler ;
	uint PrePadding_View_4772;
	uint BindlessResource_View_AtmosphereInscatterTexture ;
	uint PrePadding_View_4780;
	uint BindlessSampler_View_AtmosphereInscatterTextureSampler ;
	uint PrePadding_View_4788;
	uint BindlessResource_View_PerlinNoiseGradientTexture ;
	uint PrePadding_View_4796;
	uint BindlessSampler_View_PerlinNoiseGradientTextureSampler ;
	uint PrePadding_View_4804;
	uint BindlessResource_View_PerlinNoise3DTexture ;
	uint PrePadding_View_4812;
	uint BindlessSampler_View_PerlinNoise3DTextureSampler ;
	uint PrePadding_View_4820;
	uint BindlessResource_View_SobolSamplingTexture ;
	uint PrePadding_View_4828;
	uint BindlessSampler_View_SharedPointWrappedSampler ;
	uint PrePadding_View_4836;
	uint BindlessSampler_View_SharedPointClampedSampler ;
	uint PrePadding_View_4844;
	uint BindlessSampler_View_SharedBilinearWrappedSampler ;
	uint PrePadding_View_4852;
	uint BindlessSampler_View_SharedBilinearClampedSampler ;
	uint PrePadding_View_4860;
	uint BindlessSampler_View_SharedBilinearAnisoClampedSampler ;
	uint PrePadding_View_4868;
	uint BindlessSampler_View_SharedTrilinearWrappedSampler ;
	uint PrePadding_View_4876;
	uint BindlessSampler_View_SharedTrilinearClampedSampler ;
	uint PrePadding_View_4884;
	uint BindlessResource_View_PreIntegratedBRDF ;
	uint PrePadding_View_4892;
	uint BindlessSampler_View_PreIntegratedBRDFSampler ;
	uint PrePadding_View_4900;
	uint BindlessResource_View_PrimitiveSceneData ;
	uint PrePadding_View_4908;
	uint BindlessResource_View_InstanceSceneData ;
	uint PrePadding_View_4916;
	uint BindlessResource_View_InstancePayloadData ;
	uint PrePadding_View_4924;
	uint BindlessResource_View_LightmapSceneData ;
	uint PrePadding_View_4932;
	uint BindlessResource_View_SkyIrradianceEnvironmentMap ;
	uint PrePadding_View_4940;
	uint BindlessResource_View_TransmittanceLutTexture ;
	uint PrePadding_View_4948;
	uint BindlessSampler_View_TransmittanceLutTextureSampler ;
	uint PrePadding_View_4956;
	uint BindlessResource_View_SkyViewLutTexture ;
	uint PrePadding_View_4964;
	uint BindlessSampler_View_SkyViewLutTextureSampler ;
	uint PrePadding_View_4972;
	uint BindlessResource_View_DistantSkyLightLutTexture ;
	uint PrePadding_View_4980;
	uint BindlessSampler_View_DistantSkyLightLutTextureSampler ;
	uint PrePadding_View_4988;
	uint BindlessResource_View_CameraAerialPerspectiveVolume ;
	uint PrePadding_View_4996;
	uint BindlessSampler_View_CameraAerialPerspectiveVolumeSampler ;
	uint PrePadding_View_5004;
	uint BindlessResource_View_HairScatteringLUTTexture ;
	uint PrePadding_View_5012;
	uint BindlessSampler_View_HairScatteringLUTSampler ;
	uint PrePadding_View_5020;
	uint BindlessResource_View_LTCMatTexture ;
	uint PrePadding_View_5028;
	uint BindlessSampler_View_LTCMatSampler ;
	uint PrePadding_View_5036;
	uint BindlessResource_View_LTCAmpTexture ;
	uint PrePadding_View_5044;
	uint BindlessSampler_View_LTCAmpSampler ;
	uint PrePadding_View_5052;
	uint View_bShadingEnergyConservation;
	uint View_bShadingEnergyPreservation;
	uint BindlessResource_View_ShadingEnergyGGXSpecTexture ;
	uint PrePadding_View_5068;
	uint BindlessResource_View_ShadingEnergyGGXGlassTexture ;
	uint PrePadding_View_5076;
	uint BindlessResource_View_ShadingEnergyClothSpecTexture ;
	uint PrePadding_View_5084;
	uint BindlessResource_View_ShadingEnergyDiffuseTexture ;
	uint PrePadding_View_5092;
	uint BindlessSampler_View_ShadingEnergySampler ;
	uint PrePadding_View_5100;
	uint BindlessResource_View_SSProfilesTexture ;
	uint PrePadding_View_5108;
	uint BindlessSampler_View_SSProfilesSampler ;
	uint PrePadding_View_5116;
	uint BindlessSampler_View_SSProfilesTransmissionSampler ;
	uint PrePadding_View_5124;
	uint BindlessResource_View_SSProfilesPreIntegratedTexture ;
	uint PrePadding_View_5132;
	uint BindlessSampler_View_SSProfilesPreIntegratedSampler ;
	uint PrePadding_View_5140;
	uint BindlessResource_View_WaterIndirection ;
	uint PrePadding_View_5148;
	uint BindlessResource_View_WaterData ;
	uint PrePadding_View_5156;
	uint PrePadding_View_5160;
	uint PrePadding_View_5164;
	float4 View_RectLightAtlasSizeAndInvSize;
	float View_RectLightAtlasMaxMipLevel;
	float PrePadding_View_5188;
	uint BindlessResource_View_RectLightAtlasTexture ;
	uint PrePadding_View_5196;
	uint BindlessSampler_View_RectLightAtlasSampler ;
	uint PrePadding_View_5204;
	uint BindlessSampler_View_LandscapeWeightmapSampler ;
	uint PrePadding_View_5212;
	uint BindlessResource_View_LandscapeIndirection ;
	uint PrePadding_View_5220;
	uint BindlessResource_View_LandscapePerComponentData ;
	uint PrePadding_View_5228;
	uint BindlessResource_View_VTFeedbackBuffer ;
	uint PrePadding_View_5236;
	uint BindlessResource_View_EditorVisualizeLevelInstanceIds ;
	uint PrePadding_View_5244;
	uint BindlessResource_View_EditorSelectedHitProxyIds ;
	uint PrePadding_View_5252;
	uint BindlessResource_View_PhysicsFieldClipmapBuffer ;
	uint PrePadding_View_5260;
	float3 View_TLASRelativePreViewTranslation;
	float PrePadding_View_5276;
	float3 View_TLASViewTilePosition;
}
SamplerState View_MaterialTextureBilinearWrapedSampler ;
SamplerState View_MaterialTextureBilinearClampedSampler ;
Texture3D<uint4> View_VolumetricLightmapIndirectionTexture ;
Texture3D View_VolumetricLightmapBrickAmbientVector ;
Texture3D View_VolumetricLightmapBrickSHCoefficients0 ;
Texture3D View_VolumetricLightmapBrickSHCoefficients1 ;
Texture3D View_VolumetricLightmapBrickSHCoefficients2 ;
Texture3D View_VolumetricLightmapBrickSHCoefficients3 ;
Texture3D View_VolumetricLightmapBrickSHCoefficients4 ;
Texture3D View_VolumetricLightmapBrickSHCoefficients5 ;
Texture3D View_SkyBentNormalBrickTexture ;
Texture3D View_DirectionalLightShadowingBrickTexture ;
SamplerState View_VolumetricLightmapBrickAmbientVectorSampler ;
SamplerState View_VolumetricLightmapTextureSampler0 ;
SamplerState View_VolumetricLightmapTextureSampler1 ;
SamplerState View_VolumetricLightmapTextureSampler2 ;
SamplerState View_VolumetricLightmapTextureSampler3 ;
SamplerState View_VolumetricLightmapTextureSampler4 ;
SamplerState View_VolumetricLightmapTextureSampler5 ;
SamplerState View_SkyBentNormalTextureSampler ;
SamplerState View_DirectionalLightShadowingTextureSampler ;
Texture3D View_GlobalDistanceFieldPageAtlasTexture ;
Texture3D View_GlobalDistanceFieldCoverageAtlasTexture ;
Texture3D<uint> View_GlobalDistanceFieldPageTableTexture ;
Texture3D View_GlobalDistanceFieldMipTexture ;
Texture2D View_AtmosphereTransmittanceTexture ;
SamplerState View_AtmosphereTransmittanceTextureSampler ;
Texture2D View_AtmosphereIrradianceTexture ;
SamplerState View_AtmosphereIrradianceTextureSampler ;
Texture3D View_AtmosphereInscatterTexture ;
SamplerState View_AtmosphereInscatterTextureSampler ;
Texture2D View_PerlinNoiseGradientTexture ;
SamplerState View_PerlinNoiseGradientTextureSampler ;
Texture3D View_PerlinNoise3DTexture ;
SamplerState View_PerlinNoise3DTextureSampler ;
Texture2D<uint> View_SobolSamplingTexture ;
SamplerState View_SharedPointWrappedSampler ;
SamplerState View_SharedPointClampedSampler ;
SamplerState View_SharedBilinearWrappedSampler ;
SamplerState View_SharedBilinearClampedSampler ;
SamplerState View_SharedBilinearAnisoClampedSampler ;
SamplerState View_SharedTrilinearWrappedSampler ;
SamplerState View_SharedTrilinearClampedSampler ;
Texture2D View_PreIntegratedBRDF ;
SamplerState View_PreIntegratedBRDFSampler ;
StructuredBuffer<float4> View_PrimitiveSceneData ;
StructuredBuffer<float4> View_InstanceSceneData ;
StructuredBuffer<float4> View_InstancePayloadData ;
StructuredBuffer<float4> View_LightmapSceneData ;
StructuredBuffer<float4> View_SkyIrradianceEnvironmentMap ;
Texture2D View_TransmittanceLutTexture ;
SamplerState View_TransmittanceLutTextureSampler ;
Texture2D View_SkyViewLutTexture ;
SamplerState View_SkyViewLutTextureSampler ;
Texture2D View_DistantSkyLightLutTexture ;
SamplerState View_DistantSkyLightLutTextureSampler ;
Texture3D View_CameraAerialPerspectiveVolume ;
SamplerState View_CameraAerialPerspectiveVolumeSampler ;
Texture3D View_HairScatteringLUTTexture ;
SamplerState View_HairScatteringLUTSampler ;
Texture2D View_LTCMatTexture ;
SamplerState View_LTCMatSampler ;
Texture2D View_LTCAmpTexture ;
SamplerState View_LTCAmpSampler ;
Texture2D<float2> View_ShadingEnergyGGXSpecTexture ;
Texture3D<float2> View_ShadingEnergyGGXGlassTexture ;
Texture2D<float2> View_ShadingEnergyClothSpecTexture ;
Texture2D<float> View_ShadingEnergyDiffuseTexture ;
SamplerState View_ShadingEnergySampler ;
Texture2D View_SSProfilesTexture ;
SamplerState View_SSProfilesSampler ;
SamplerState View_SSProfilesTransmissionSampler ;
Texture2DArray View_SSProfilesPreIntegratedTexture ;
SamplerState View_SSProfilesPreIntegratedSampler ;
Buffer<float4> View_WaterIndirection ;
Buffer<float4> View_WaterData ;
Texture2D<float4> View_RectLightAtlasTexture ;
SamplerState View_RectLightAtlasSampler ;
SamplerState View_LandscapeWeightmapSampler ;
Buffer<uint> View_LandscapeIndirection ;
Buffer<float> View_LandscapePerComponentData ;
RWBuffer<uint> View_VTFeedbackBuffer ;
Buffer<uint> View_EditorVisualizeLevelInstanceIds ;
Buffer<uint> View_EditorSelectedHitProxyIds ;
Buffer<float> View_PhysicsFieldClipmapBuffer ;
static const struct
{
	float4x4 TranslatedWorldToClip;
	float4x4 TranslatedWorldToSubpixelClip;
	float4x4 RelativeWorldToClip;
	float4x4 ClipToRelativeWorld;
	float4x4 TranslatedWorldToView;
	float4x4 ViewToTranslatedWorld;
	float4x4 TranslatedWorldToCameraView;
	float4x4 CameraViewToTranslatedWorld;
	float4x4 ViewToClip;
	float4x4 ViewToClipNoAA;
	float4x4 ClipToView;
	float4x4 ClipToTranslatedWorld;
	float4x4 SVPositionToTranslatedWorld;
	float4x4 ScreenToRelativeWorld;
	float4x4 ScreenToTranslatedWorld;
	float4x4 MobileMultiviewShadowTransform;
	float3 ViewTilePosition;
	float3 MatrixTilePosition;
	float3 ViewForward;
	float3 ViewUp;
	float3 ViewRight;
	float3 HMDViewNoRollUp;
	float3 HMDViewNoRollRight;
	float4 InvDeviceZToWorldZTransform;
	float4 ScreenPositionScaleBias;
	float3 RelativeWorldCameraOrigin;
	float3 TranslatedWorldCameraOrigin;
	float3 RelativeWorldViewOrigin;
	float3 RelativePreViewTranslation;
	float4x4 PrevViewToClip;
	float4x4 PrevClipToView;
	float4x4 PrevTranslatedWorldToClip;
	float4x4 PrevTranslatedWorldToView;
	float4x4 PrevViewToTranslatedWorld;
	float4x4 PrevTranslatedWorldToCameraView;
	float4x4 PrevCameraViewToTranslatedWorld;
	float3 PrevTranslatedWorldCameraOrigin;
	float3 PrevRelativeWorldCameraOrigin;
	float3 PrevRelativeWorldViewOrigin;
	float3 RelativePrevPreViewTranslation;
	float4x4 PrevClipToRelativeWorld;
	float4x4 PrevScreenToTranslatedWorld;
	float4x4 ClipToPrevClip;
	float4x4 ClipToPrevClipWithAA;
	float4 TemporalAAJitter;
	float4 GlobalClippingPlane;
	float2 FieldOfViewWideAngles;
	float2 PrevFieldOfViewWideAngles;
	float4 ViewRectMin;
	float4 ViewSizeAndInvSize;
	uint4 ViewRectMinAndSize;
	float4 LightProbeSizeRatioAndInvSizeRatio;
	float4 BufferSizeAndInvSize;
	float4 BufferBilinearUVMinMax;
	float4 ScreenToViewSpace;
	float2 BufferToSceneTextureScale;
	float2 ResolutionFractionAndInv;
	int NumSceneColorMSAASamples;
	float SeparateWaterMainDirLightLuminance;
	float PreExposure;
	float OneOverPreExposure;
	float4 DiffuseOverrideParameter;
	float4 SpecularOverrideParameter;
	float4 NormalOverrideParameter;
	float2 RoughnessOverrideParameter;
	float PrevFrameGameTime;
	float PrevFrameRealTime;
	float OutOfBoundsMask;
	float3 WorldCameraMovementSinceLastFrame;
	float CullingSign;
	float NearPlane;
	float GameTime;
	float RealTime;
	float DeltaTime;
	float MaterialTextureMipBias;
	float MaterialTextureDerivativeMultiply;
	uint Random;
	uint FrameNumber;
	uint StateFrameIndexMod8;
	uint StateFrameIndex;
	uint DebugViewModeMask;
	float CameraCut;
	float UnlitViewmodeMask;
	float4 DirectionalLightColor;
	float3 DirectionalLightDirection;
	float4 TranslucencyLightingVolumeMin[2];
	float4 TranslucencyLightingVolumeInvSize[2];
	float4 TemporalAAParams;
	float4 CircleDOFParams;
	float DepthOfFieldSensorWidth;
	float DepthOfFieldFocalDistance;
	float DepthOfFieldScale;
	float DepthOfFieldFocalLength;
	float DepthOfFieldFocalRegion;
	float DepthOfFieldNearTransitionRegion;
	float DepthOfFieldFarTransitionRegion;
	float MotionBlurNormalizedToPixel;
	float GeneralPurposeTweak;
	float GeneralPurposeTweak2;
	float DemosaicVposOffset;
	float DecalDepthBias;
	float3 IndirectLightingColorScale;
	float3 PrecomputedIndirectLightingColorScale;
	float3 PrecomputedIndirectSpecularColorScale;
	float4 AtmosphereLightDirection[2];
	float4 AtmosphereLightIlluminanceOnGroundPostTransmittance[2];
	float4 AtmosphereLightIlluminanceOuterSpace[2];
	float4 AtmosphereLightDiscLuminance[2];
	float4 AtmosphereLightDiscCosHalfApexAngle_PPTrans[2];
	float4 SkyViewLutSizeAndInvSize;
	float3 SkyCameraTranslatedWorldOrigin;
	float4 SkyPlanetTranslatedWorldCenterAndViewHeight;
	float4x4 SkyViewLutReferential;
	float4 SkyAtmosphereSkyLuminanceFactor;
	float SkyAtmospherePresentInScene;
	float SkyAtmosphereHeightFogContribution;
	float SkyAtmosphereBottomRadiusKm;
	float SkyAtmosphereTopRadiusKm;
	float4 SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize;
	float SkyAtmosphereAerialPerspectiveStartDepthKm;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv;
	float SkyAtmosphereApplyCameraAerialPerspectiveVolume;
	float3 NormalCurvatureToRoughnessScaleBias;
	float RenderingReflectionCaptureMask;
	float RealTimeReflectionCapture;
	float RealTimeReflectionCapturePreExposure;
	float4 AmbientCubemapTint;
	float AmbientCubemapIntensity;
	float SkyLightApplyPrecomputedBentNormalShadowingFlag;
	float SkyLightAffectReflectionFlag;
	float SkyLightAffectGlobalIlluminationFlag;
	float4 SkyLightColor;
	float4 MobileSkyIrradianceEnvironmentMap[8];
	float MobilePreviewMode;
	float HMDEyePaddingOffset;
	float ReflectionCubemapMaxMip;
	float ShowDecalsMask;
	uint DistanceFieldAOSpecularOcclusionMode;
	float IndirectCapsuleSelfShadowingIntensity;
	float3 ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	int StereoPassIndex;
	float4 GlobalVolumeCenterAndExtent[6];
	float4 GlobalVolumeWorldToUVAddAndMul[6];
	float4 GlobalDistanceFieldMipWorldToUVScale[6];
	float4 GlobalDistanceFieldMipWorldToUVBias[6];
	float GlobalDistanceFieldMipFactor;
	float GlobalDistanceFieldMipTransition;
	int GlobalDistanceFieldClipmapSizeInPages;
	float3 GlobalDistanceFieldInvPageAtlasSize;
	float3 GlobalDistanceFieldInvCoverageAtlasSize;
	float GlobalVolumeDimension;
	float GlobalVolumeTexelSize;
	float MaxGlobalDFAOConeDistance;
	uint NumGlobalSDFClipmaps;
	float CoveredExpandSurfaceScale;
	float NotCoveredExpandSurfaceScale;
	float NotCoveredMinStepScale;
	float DitheredTransparencyStepThreshold;
	float DitheredTransparencyTraceThreshold;
	int2 CursorPosition;
	float bCheckerboardSubsurfaceProfileRendering;
	float3 VolumetricFogInvGridSize;
	float3 VolumetricFogGridZParams;
	float2 VolumetricFogSVPosToVolumeUV;
	float VolumetricFogMaxDistance;
	float3 VolumetricLightmapWorldToUVScale;
	float3 VolumetricLightmapWorldToUVAdd;
	float3 VolumetricLightmapIndirectionTextureSize;
	float VolumetricLightmapBrickSize;
	float3 VolumetricLightmapBrickTexelSize;
	float IndirectLightingCacheShowFlag;
	float EyeToPixelSpreadAngle;
	float4 XRPassthroughCameraUVs[2];
	float GlobalVirtualTextureMipBias;
	uint VirtualTextureFeedbackShift;
	uint VirtualTextureFeedbackMask;
	uint VirtualTextureFeedbackStride;
	uint VirtualTextureFeedbackJitterOffset;
	uint VirtualTextureFeedbackSampleOffset;
	float4 RuntimeVirtualTextureMipLevel;
	float2 RuntimeVirtualTexturePackHeight;
	float4 RuntimeVirtualTextureDebugParams;
	float OverrideLandscapeLOD;
	int FarShadowStaticMeshLODBias;
	float MinRoughness;
	float4 HairRenderInfo;
	uint EnableSkyLight;
	uint HairRenderInfoBits;
	uint HairComponents;
	float bSubsurfacePostprocessEnabled;
	float4 SSProfilesTextureSizeAndInvSize;
	float4 SSProfilesPreIntegratedTextureSizeAndInvSize;
	float3 PhysicsFieldClipmapCenter;
	float PhysicsFieldClipmapDistance;
	int PhysicsFieldClipmapResolution;
	int PhysicsFieldClipmapExponent;
	int PhysicsFieldClipmapCount;
	int PhysicsFieldTargetCount;
	int4 PhysicsFieldTargets[32];
	uint InstanceSceneDataSOAStride;
	uint GPUSceneViewId;
	float ViewResolutionFraction;
	float SubSurfaceColorAsTransmittanceAtDistanceInMeters;
	uint bShadingEnergyConservation;
	uint bShadingEnergyPreservation;
	float4 RectLightAtlasSizeAndInvSize;
	float RectLightAtlasMaxMipLevel;
	float3 TLASRelativePreViewTranslation;
	float3 TLASViewTilePosition;
	SamplerState MaterialTextureBilinearWrapedSampler;
	SamplerState MaterialTextureBilinearClampedSampler;
	Texture3D<uint4> VolumetricLightmapIndirectionTexture;
	Texture3D VolumetricLightmapBrickAmbientVector;
	Texture3D VolumetricLightmapBrickSHCoefficients0;
	Texture3D VolumetricLightmapBrickSHCoefficients1;
	Texture3D VolumetricLightmapBrickSHCoefficients2;
	Texture3D VolumetricLightmapBrickSHCoefficients3;
	Texture3D VolumetricLightmapBrickSHCoefficients4;
	Texture3D VolumetricLightmapBrickSHCoefficients5;
	Texture3D SkyBentNormalBrickTexture;
	Texture3D DirectionalLightShadowingBrickTexture;
	SamplerState VolumetricLightmapBrickAmbientVectorSampler;
	SamplerState VolumetricLightmapTextureSampler0;
	SamplerState VolumetricLightmapTextureSampler1;
	SamplerState VolumetricLightmapTextureSampler2;
	SamplerState VolumetricLightmapTextureSampler3;
	SamplerState VolumetricLightmapTextureSampler4;
	SamplerState VolumetricLightmapTextureSampler5;
	SamplerState SkyBentNormalTextureSampler;
	SamplerState DirectionalLightShadowingTextureSampler;
	Texture3D GlobalDistanceFieldPageAtlasTexture;
	Texture3D GlobalDistanceFieldCoverageAtlasTexture;
	Texture3D<uint> GlobalDistanceFieldPageTableTexture;
	Texture3D GlobalDistanceFieldMipTexture;
	Texture2D AtmosphereTransmittanceTexture;
	SamplerState AtmosphereTransmittanceTextureSampler;
	Texture2D AtmosphereIrradianceTexture;
	SamplerState AtmosphereIrradianceTextureSampler;
	Texture3D AtmosphereInscatterTexture;
	SamplerState AtmosphereInscatterTextureSampler;
	Texture2D PerlinNoiseGradientTexture;
	SamplerState PerlinNoiseGradientTextureSampler;
	Texture3D PerlinNoise3DTexture;
	SamplerState PerlinNoise3DTextureSampler;
	Texture2D<uint> SobolSamplingTexture;
	SamplerState SharedPointWrappedSampler;
	SamplerState SharedPointClampedSampler;
	SamplerState SharedBilinearWrappedSampler;
	SamplerState SharedBilinearClampedSampler;
	SamplerState SharedBilinearAnisoClampedSampler;
	SamplerState SharedTrilinearWrappedSampler;
	SamplerState SharedTrilinearClampedSampler;
	Texture2D PreIntegratedBRDF;
	SamplerState PreIntegratedBRDFSampler;
	StructuredBuffer<float4> PrimitiveSceneData;
	StructuredBuffer<float4> InstanceSceneData;
	StructuredBuffer<float4> InstancePayloadData;
	StructuredBuffer<float4> LightmapSceneData;
	StructuredBuffer<float4> SkyIrradianceEnvironmentMap;
	Texture2D TransmittanceLutTexture;
	SamplerState TransmittanceLutTextureSampler;
	Texture2D SkyViewLutTexture;
	SamplerState SkyViewLutTextureSampler;
	Texture2D DistantSkyLightLutTexture;
	SamplerState DistantSkyLightLutTextureSampler;
	Texture3D CameraAerialPerspectiveVolume;
	SamplerState CameraAerialPerspectiveVolumeSampler;
	Texture3D HairScatteringLUTTexture;
	SamplerState HairScatteringLUTSampler;
	Texture2D LTCMatTexture;
	SamplerState LTCMatSampler;
	Texture2D LTCAmpTexture;
	SamplerState LTCAmpSampler;
	Texture2D<float2> ShadingEnergyGGXSpecTexture;
	Texture3D<float2> ShadingEnergyGGXGlassTexture;
	Texture2D<float2> ShadingEnergyClothSpecTexture;
	Texture2D<float> ShadingEnergyDiffuseTexture;
	SamplerState ShadingEnergySampler;
	Texture2D SSProfilesTexture;
	SamplerState SSProfilesSampler;
	SamplerState SSProfilesTransmissionSampler;
	Texture2DArray SSProfilesPreIntegratedTexture;
	SamplerState SSProfilesPreIntegratedSampler;
	Buffer<float4> WaterIndirection;
	Buffer<float4> WaterData;
	Texture2D<float4> RectLightAtlasTexture;
	SamplerState RectLightAtlasSampler;
	SamplerState LandscapeWeightmapSampler;
	Buffer<uint> LandscapeIndirection;
	Buffer<float> LandscapePerComponentData;
	RWBuffer<uint> VTFeedbackBuffer;
	Buffer<uint> EditorVisualizeLevelInstanceIds;
	Buffer<uint> EditorSelectedHitProxyIds;
	Buffer<float> PhysicsFieldClipmapBuffer;
} View = {View_TranslatedWorldToClip,View_TranslatedWorldToSubpixelClip,View_RelativeWorldToClip,View_ClipToRelativeWorld,View_TranslatedWorldToView,View_ViewToTranslatedWorld,View_TranslatedWorldToCameraView,View_CameraViewToTranslatedWorld,View_ViewToClip,View_ViewToClipNoAA,View_ClipToView,View_ClipToTranslatedWorld,View_SVPositionToTranslatedWorld,View_ScreenToRelativeWorld,View_ScreenToTranslatedWorld,View_MobileMultiviewShadowTransform,View_ViewTilePosition,View_MatrixTilePosition,View_ViewForward,View_ViewUp,View_ViewRight,View_HMDViewNoRollUp,View_HMDViewNoRollRight,View_InvDeviceZToWorldZTransform,View_ScreenPositionScaleBias,View_RelativeWorldCameraOrigin,View_TranslatedWorldCameraOrigin,View_RelativeWorldViewOrigin,View_RelativePreViewTranslation,View_PrevViewToClip,View_PrevClipToView,View_PrevTranslatedWorldToClip,View_PrevTranslatedWorldToView,View_PrevViewToTranslatedWorld,View_PrevTranslatedWorldToCameraView,View_PrevCameraViewToTranslatedWorld,View_PrevTranslatedWorldCameraOrigin,View_PrevRelativeWorldCameraOrigin,View_PrevRelativeWorldViewOrigin,View_RelativePrevPreViewTranslation,View_PrevClipToRelativeWorld,View_PrevScreenToTranslatedWorld,View_ClipToPrevClip,View_ClipToPrevClipWithAA,View_TemporalAAJitter,View_GlobalClippingPlane,View_FieldOfViewWideAngles,View_PrevFieldOfViewWideAngles,View_ViewRectMin,View_ViewSizeAndInvSize,View_ViewRectMinAndSize,View_LightProbeSizeRatioAndInvSizeRatio,View_BufferSizeAndInvSize,View_BufferBilinearUVMinMax,View_ScreenToViewSpace,View_BufferToSceneTextureScale,View_ResolutionFractionAndInv,View_NumSceneColorMSAASamples,View_SeparateWaterMainDirLightLuminance,View_PreExposure,View_OneOverPreExposure,View_DiffuseOverrideParameter,View_SpecularOverrideParameter,View_NormalOverrideParameter,View_RoughnessOverrideParameter,View_PrevFrameGameTime,View_PrevFrameRealTime,View_OutOfBoundsMask,View_WorldCameraMovementSinceLastFrame,View_CullingSign,View_NearPlane,View_GameTime,View_RealTime,View_DeltaTime,View_MaterialTextureMipBias,View_MaterialTextureDerivativeMultiply,View_Random,View_FrameNumber,View_StateFrameIndexMod8,View_StateFrameIndex,View_DebugViewModeMask,View_CameraCut,View_UnlitViewmodeMask,View_DirectionalLightColor,View_DirectionalLightDirection,View_TranslucencyLightingVolumeMin,View_TranslucencyLightingVolumeInvSize,View_TemporalAAParams,View_CircleDOFParams,View_DepthOfFieldSensorWidth,View_DepthOfFieldFocalDistance,View_DepthOfFieldScale,View_DepthOfFieldFocalLength,View_DepthOfFieldFocalRegion,View_DepthOfFieldNearTransitionRegion,View_DepthOfFieldFarTransitionRegion,View_MotionBlurNormalizedToPixel,View_GeneralPurposeTweak,View_GeneralPurposeTweak2,View_DemosaicVposOffset,View_DecalDepthBias,View_IndirectLightingColorScale,View_PrecomputedIndirectLightingColorScale,View_PrecomputedIndirectSpecularColorScale,View_AtmosphereLightDirection,View_AtmosphereLightIlluminanceOnGroundPostTransmittance,View_AtmosphereLightIlluminanceOuterSpace,View_AtmosphereLightDiscLuminance,View_AtmosphereLightDiscCosHalfApexAngle_PPTrans,View_SkyViewLutSizeAndInvSize,View_SkyCameraTranslatedWorldOrigin,View_SkyPlanetTranslatedWorldCenterAndViewHeight,View_SkyViewLutReferential,View_SkyAtmosphereSkyLuminanceFactor,View_SkyAtmospherePresentInScene,View_SkyAtmosphereHeightFogContribution,View_SkyAtmosphereBottomRadiusKm,View_SkyAtmosphereTopRadiusKm,View_SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize,View_SkyAtmosphereAerialPerspectiveStartDepthKm,View_SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution,View_SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv,View_SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm,View_SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv,View_SkyAtmosphereApplyCameraAerialPerspectiveVolume,View_NormalCurvatureToRoughnessScaleBias,View_RenderingReflectionCaptureMask,View_RealTimeReflectionCapture,View_RealTimeReflectionCapturePreExposure,View_AmbientCubemapTint,View_AmbientCubemapIntensity,View_SkyLightApplyPrecomputedBentNormalShadowingFlag,View_SkyLightAffectReflectionFlag,View_SkyLightAffectGlobalIlluminationFlag,View_SkyLightColor,View_MobileSkyIrradianceEnvironmentMap,View_MobilePreviewMode,View_HMDEyePaddingOffset,View_ReflectionCubemapMaxMip,View_ShowDecalsMask,View_DistanceFieldAOSpecularOcclusionMode,View_IndirectCapsuleSelfShadowingIntensity,View_ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight,View_StereoPassIndex,View_GlobalVolumeCenterAndExtent,View_GlobalVolumeWorldToUVAddAndMul,View_GlobalDistanceFieldMipWorldToUVScale,View_GlobalDistanceFieldMipWorldToUVBias,View_GlobalDistanceFieldMipFactor,View_GlobalDistanceFieldMipTransition,View_GlobalDistanceFieldClipmapSizeInPages,View_GlobalDistanceFieldInvPageAtlasSize,View_GlobalDistanceFieldInvCoverageAtlasSize,View_GlobalVolumeDimension,View_GlobalVolumeTexelSize,View_MaxGlobalDFAOConeDistance,View_NumGlobalSDFClipmaps,View_CoveredExpandSurfaceScale,View_NotCoveredExpandSurfaceScale,View_NotCoveredMinStepScale,View_DitheredTransparencyStepThreshold,View_DitheredTransparencyTraceThreshold,View_CursorPosition,View_bCheckerboardSubsurfaceProfileRendering,View_VolumetricFogInvGridSize,View_VolumetricFogGridZParams,View_VolumetricFogSVPosToVolumeUV,View_VolumetricFogMaxDistance,View_VolumetricLightmapWorldToUVScale,View_VolumetricLightmapWorldToUVAdd,View_VolumetricLightmapIndirectionTextureSize,View_VolumetricLightmapBrickSize,View_VolumetricLightmapBrickTexelSize,View_IndirectLightingCacheShowFlag,View_EyeToPixelSpreadAngle,View_XRPassthroughCameraUVs,View_GlobalVirtualTextureMipBias,View_VirtualTextureFeedbackShift,View_VirtualTextureFeedbackMask,View_VirtualTextureFeedbackStride,View_VirtualTextureFeedbackJitterOffset,View_VirtualTextureFeedbackSampleOffset,View_RuntimeVirtualTextureMipLevel,View_RuntimeVirtualTexturePackHeight,View_RuntimeVirtualTextureDebugParams,View_OverrideLandscapeLOD,View_FarShadowStaticMeshLODBias,View_MinRoughness,View_HairRenderInfo,View_EnableSkyLight,View_HairRenderInfoBits,View_HairComponents,View_bSubsurfacePostprocessEnabled,View_SSProfilesTextureSizeAndInvSize,View_SSProfilesPreIntegratedTextureSizeAndInvSize,View_PhysicsFieldClipmapCenter,View_PhysicsFieldClipmapDistance,View_PhysicsFieldClipmapResolution,View_PhysicsFieldClipmapExponent,View_PhysicsFieldClipmapCount,View_PhysicsFieldTargetCount,View_PhysicsFieldTargets,View_InstanceSceneDataSOAStride,View_GPUSceneViewId,View_ViewResolutionFraction,View_SubSurfaceColorAsTransmittanceAtDistanceInMeters,View_bShadingEnergyConservation,View_bShadingEnergyPreservation,View_RectLightAtlasSizeAndInvSize,View_RectLightAtlasMaxMipLevel,View_TLASRelativePreViewTranslation,View_TLASViewTilePosition,View_MaterialTextureBilinearWrapedSampler,View_MaterialTextureBilinearClampedSampler,View_VolumetricLightmapIndirectionTexture,View_VolumetricLightmapBrickAmbientVector,View_VolumetricLightmapBrickSHCoefficients0,View_VolumetricLightmapBrickSHCoefficients1,View_VolumetricLightmapBrickSHCoefficients2,View_VolumetricLightmapBrickSHCoefficients3,View_VolumetricLightmapBrickSHCoefficients4,View_VolumetricLightmapBrickSHCoefficients5,View_SkyBentNormalBrickTexture,View_DirectionalLightShadowingBrickTexture,View_VolumetricLightmapBrickAmbientVectorSampler,View_VolumetricLightmapTextureSampler0,View_VolumetricLightmapTextureSampler1,View_VolumetricLightmapTextureSampler2,View_VolumetricLightmapTextureSampler3,View_VolumetricLightmapTextureSampler4,View_VolumetricLightmapTextureSampler5,View_SkyBentNormalTextureSampler,View_DirectionalLightShadowingTextureSampler,View_GlobalDistanceFieldPageAtlasTexture,View_GlobalDistanceFieldCoverageAtlasTexture,View_GlobalDistanceFieldPageTableTexture,View_GlobalDistanceFieldMipTexture,View_AtmosphereTransmittanceTexture,View_AtmosphereTransmittanceTextureSampler,View_AtmosphereIrradianceTexture,View_AtmosphereIrradianceTextureSampler,View_AtmosphereInscatterTexture,View_AtmosphereInscatterTextureSampler,View_PerlinNoiseGradientTexture,View_PerlinNoiseGradientTextureSampler,View_PerlinNoise3DTexture,View_PerlinNoise3DTextureSampler,View_SobolSamplingTexture,View_SharedPointWrappedSampler,View_SharedPointClampedSampler,View_SharedBilinearWrappedSampler,View_SharedBilinearClampedSampler,View_SharedBilinearAnisoClampedSampler,View_SharedTrilinearWrappedSampler,View_SharedTrilinearClampedSampler,View_PreIntegratedBRDF,View_PreIntegratedBRDFSampler,  View_PrimitiveSceneData,   View_InstanceSceneData,   View_InstancePayloadData,   View_LightmapSceneData,   View_SkyIrradianceEnvironmentMap,  View_TransmittanceLutTexture,View_TransmittanceLutTextureSampler,View_SkyViewLutTexture,View_SkyViewLutTextureSampler,View_DistantSkyLightLutTexture,View_DistantSkyLightLutTextureSampler,View_CameraAerialPerspectiveVolume,View_CameraAerialPerspectiveVolumeSampler,View_HairScatteringLUTTexture,View_HairScatteringLUTSampler,View_LTCMatTexture,View_LTCMatSampler,View_LTCAmpTexture,View_LTCAmpSampler,View_ShadingEnergyGGXSpecTexture,View_ShadingEnergyGGXGlassTexture,View_ShadingEnergyClothSpecTexture,View_ShadingEnergyDiffuseTexture,View_ShadingEnergySampler,View_SSProfilesTexture,View_SSProfilesSampler,View_SSProfilesTransmissionSampler,View_SSProfilesPreIntegratedTexture,View_SSProfilesPreIntegratedSampler,  View_WaterIndirection,   View_WaterData,  View_RectLightAtlasTexture,View_RectLightAtlasSampler,View_LandscapeWeightmapSampler,  View_LandscapeIndirection,   View_LandscapePerComponentData,  View_VTFeedbackBuffer,  View_EditorVisualizeLevelInstanceIds,   View_EditorSelectedHitProxyIds,   View_PhysicsFieldClipmapBuffer,  };
#line 2 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/Strata.ush"


cbuffer  UniformBufferConstants_Strata
{
	uint Strata_MaxBytesPerPixel;
	uint Strata_bRoughDiffuse;
	uint Strata_PeelLayersAboveDepth;
	int Strata_SliceStoringDebugStrataTree;
	int Strata_FirstSliceStoringStrataSSSData;
	uint Strata_TileSize;
	uint Strata_TileSizeLog2;
	uint PrePadding_Strata_28;
	int2 Strata_TileCount;
	int2 Strata_TileOffset;
	int2 Strata_OverflowTileCount;
	int2 Strata_OverflowTileOffset;
	uint BindlessResource_Strata_MaterialTextureArray ;
	uint PrePadding_Strata_68;
	uint BindlessResource_Strata_TopLayerTexture ;
	uint PrePadding_Strata_76;
	uint BindlessResource_Strata_OpaqueRoughRefractionTexture ;
	uint PrePadding_Strata_84;
	uint BindlessResource_Strata_BSDFOffsetTexture ;
	uint PrePadding_Strata_92;
	uint BindlessResource_Strata_BSDFTileTexture ;
	uint PrePadding_Strata_100;
	uint BindlessResource_Strata_BSDFTileCountBuffer ;
}
Texture2DArray<uint> Strata_MaterialTextureArray ;
Texture2D<uint> Strata_TopLayerTexture ;
Texture2D<float3> Strata_OpaqueRoughRefractionTexture ;
Texture2D<uint> Strata_BSDFOffsetTexture ;
Texture2D<uint> Strata_BSDFTileTexture ;
Buffer<uint> Strata_BSDFTileCountBuffer ;
static const struct
{
	uint MaxBytesPerPixel;
	uint bRoughDiffuse;
	uint PeelLayersAboveDepth;
	int SliceStoringDebugStrataTree;
	int FirstSliceStoringStrataSSSData;
	uint TileSize;
	uint TileSizeLog2;
	int2 TileCount;
	int2 TileOffset;
	int2 OverflowTileCount;
	int2 OverflowTileOffset;
	Texture2DArray<uint> MaterialTextureArray;
	Texture2D<uint> TopLayerTexture;
	Texture2D<float3> OpaqueRoughRefractionTexture;
	Texture2D<uint> BSDFOffsetTexture;
	Texture2D<uint> BSDFTileTexture;
	Buffer<uint> BSDFTileCountBuffer;
} Strata = {Strata_MaxBytesPerPixel,Strata_bRoughDiffuse,Strata_PeelLayersAboveDepth,Strata_SliceStoringDebugStrataTree,Strata_FirstSliceStoringStrataSSSData,Strata_TileSize,Strata_TileSizeLog2,Strata_TileCount,Strata_TileOffset,Strata_OverflowTileCount,Strata_OverflowTileOffset,Strata_MaterialTextureArray,Strata_TopLayerTexture,Strata_OpaqueRoughRefractionTexture,Strata_BSDFOffsetTexture,Strata_BSDFTileTexture,Strata_BSDFTileCountBuffer,};
#line 3 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/DrawRectangleParameters.ush"


cbuffer  UniformBufferConstants_DrawRectangleParameters
{
	float4 DrawRectangleParameters_PosScaleBias;
	float4 DrawRectangleParameters_UVScaleBias;
	float4 DrawRectangleParameters_InvTargetSizeAndTextureSize;
}
static const struct
{
	float4 PosScaleBias;
	float4 UVScaleBias;
	float4 InvTargetSizeAndTextureSize;
} DrawRectangleParameters = {DrawRectangleParameters_PosScaleBias,DrawRectangleParameters_UVScaleBias,DrawRectangleParameters_InvTargetSizeAndTextureSize,};
#line 4 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/InstancedView.ush"


cbuffer  UniformBufferConstants_InstancedView
{
	float4x4 InstancedView_TranslatedWorldToClip;
	float4x4 InstancedView_TranslatedWorldToSubpixelClip;
	float4x4 InstancedView_RelativeWorldToClip;
	float4x4 InstancedView_ClipToRelativeWorld;
	float4x4 InstancedView_TranslatedWorldToView;
	float4x4 InstancedView_ViewToTranslatedWorld;
	float4x4 InstancedView_TranslatedWorldToCameraView;
	float4x4 InstancedView_CameraViewToTranslatedWorld;
	float4x4 InstancedView_ViewToClip;
	float4x4 InstancedView_ViewToClipNoAA;
	float4x4 InstancedView_ClipToView;
	float4x4 InstancedView_ClipToTranslatedWorld;
	float4x4 InstancedView_SVPositionToTranslatedWorld;
	float4x4 InstancedView_ScreenToRelativeWorld;
	float4x4 InstancedView_ScreenToTranslatedWorld;
	float4x4 InstancedView_MobileMultiviewShadowTransform;
	float3 InstancedView_ViewTilePosition;
	float PrePadding_InstancedView_1036;
	float3 InstancedView_MatrixTilePosition;
	float PrePadding_InstancedView_1052;
	float3 InstancedView_ViewForward;
	float PrePadding_InstancedView_1068;
	float3 InstancedView_ViewUp;
	float PrePadding_InstancedView_1084;
	float3 InstancedView_ViewRight;
	float PrePadding_InstancedView_1100;
	float3 InstancedView_HMDViewNoRollUp;
	float PrePadding_InstancedView_1116;
	float3 InstancedView_HMDViewNoRollRight;
	float PrePadding_InstancedView_1132;
	float4 InstancedView_InvDeviceZToWorldZTransform;
	float4 InstancedView_ScreenPositionScaleBias;
	float3 InstancedView_RelativeWorldCameraOrigin;
	float PrePadding_InstancedView_1180;
	float3 InstancedView_TranslatedWorldCameraOrigin;
	float PrePadding_InstancedView_1196;
	float3 InstancedView_RelativeWorldViewOrigin;
	float PrePadding_InstancedView_1212;
	float3 InstancedView_RelativePreViewTranslation;
	float PrePadding_InstancedView_1228;
	float4x4 InstancedView_PrevViewToClip;
	float4x4 InstancedView_PrevClipToView;
	float4x4 InstancedView_PrevTranslatedWorldToClip;
	float4x4 InstancedView_PrevTranslatedWorldToView;
	float4x4 InstancedView_PrevViewToTranslatedWorld;
	float4x4 InstancedView_PrevTranslatedWorldToCameraView;
	float4x4 InstancedView_PrevCameraViewToTranslatedWorld;
	float3 InstancedView_PrevTranslatedWorldCameraOrigin;
	float PrePadding_InstancedView_1692;
	float3 InstancedView_PrevRelativeWorldCameraOrigin;
	float PrePadding_InstancedView_1708;
	float3 InstancedView_PrevRelativeWorldViewOrigin;
	float PrePadding_InstancedView_1724;
	float3 InstancedView_RelativePrevPreViewTranslation;
	float PrePadding_InstancedView_1740;
	float4x4 InstancedView_PrevClipToRelativeWorld;
	float4x4 InstancedView_PrevScreenToTranslatedWorld;
	float4x4 InstancedView_ClipToPrevClip;
	float4x4 InstancedView_ClipToPrevClipWithAA;
	float4 InstancedView_TemporalAAJitter;
	float4 InstancedView_GlobalClippingPlane;
	float2 InstancedView_FieldOfViewWideAngles;
	float2 InstancedView_PrevFieldOfViewWideAngles;
	float4 InstancedView_ViewRectMin;
	float4 InstancedView_ViewSizeAndInvSize;
	uint4 InstancedView_ViewRectMinAndSize;
	float4 InstancedView_LightProbeSizeRatioAndInvSizeRatio;
	float4 InstancedView_BufferSizeAndInvSize;
	float4 InstancedView_BufferBilinearUVMinMax;
	float4 InstancedView_ScreenToViewSpace;
	float2 InstancedView_BufferToSceneTextureScale;
	float2 InstancedView_ResolutionFractionAndInv;
	int InstancedView_NumSceneColorMSAASamples;
	float InstancedView_SeparateWaterMainDirLightLuminance;
	float InstancedView_PreExposure;
	float InstancedView_OneOverPreExposure;
	float4 InstancedView_DiffuseOverrideParameter;
	float4 InstancedView_SpecularOverrideParameter;
	float4 InstancedView_NormalOverrideParameter;
	float2 InstancedView_RoughnessOverrideParameter;
	float InstancedView_PrevFrameGameTime;
	float InstancedView_PrevFrameRealTime;
	float InstancedView_OutOfBoundsMask;
	float PrePadding_InstancedView_2260;
	float PrePadding_InstancedView_2264;
	float PrePadding_InstancedView_2268;
	float3 InstancedView_WorldCameraMovementSinceLastFrame;
	float InstancedView_CullingSign;
	float InstancedView_NearPlane;
	float InstancedView_GameTime;
	float InstancedView_RealTime;
	float InstancedView_DeltaTime;
	float InstancedView_MaterialTextureMipBias;
	float InstancedView_MaterialTextureDerivativeMultiply;
	uint InstancedView_Random;
	uint InstancedView_FrameNumber;
	uint InstancedView_StateFrameIndexMod8;
	uint InstancedView_StateFrameIndex;
	uint InstancedView_DebugViewModeMask;
	float InstancedView_CameraCut;
	float InstancedView_UnlitViewmodeMask;
	float PrePadding_InstancedView_2340;
	float PrePadding_InstancedView_2344;
	float PrePadding_InstancedView_2348;
	float4 InstancedView_DirectionalLightColor;
	float3 InstancedView_DirectionalLightDirection;
	float PrePadding_InstancedView_2380;
	float4 InstancedView_TranslucencyLightingVolumeMin[2];
	float4 InstancedView_TranslucencyLightingVolumeInvSize[2];
	float4 InstancedView_TemporalAAParams;
	float4 InstancedView_CircleDOFParams;
	float InstancedView_DepthOfFieldSensorWidth;
	float InstancedView_DepthOfFieldFocalDistance;
	float InstancedView_DepthOfFieldScale;
	float InstancedView_DepthOfFieldFocalLength;
	float InstancedView_DepthOfFieldFocalRegion;
	float InstancedView_DepthOfFieldNearTransitionRegion;
	float InstancedView_DepthOfFieldFarTransitionRegion;
	float InstancedView_MotionBlurNormalizedToPixel;
	float InstancedView_GeneralPurposeTweak;
	float InstancedView_GeneralPurposeTweak2;
	float InstancedView_DemosaicVposOffset;
	float InstancedView_DecalDepthBias;
	float3 InstancedView_IndirectLightingColorScale;
	float PrePadding_InstancedView_2540;
	float3 InstancedView_PrecomputedIndirectLightingColorScale;
	float PrePadding_InstancedView_2556;
	float3 InstancedView_PrecomputedIndirectSpecularColorScale;
	float PrePadding_InstancedView_2572;
	float4 InstancedView_AtmosphereLightDirection[2];
	float4 InstancedView_AtmosphereLightIlluminanceOnGroundPostTransmittance[2];
	float4 InstancedView_AtmosphereLightIlluminanceOuterSpace[2];
	float4 InstancedView_AtmosphereLightDiscLuminance[2];
	float4 InstancedView_AtmosphereLightDiscCosHalfApexAngle_PPTrans[2];
	float4 InstancedView_SkyViewLutSizeAndInvSize;
	float3 InstancedView_SkyCameraTranslatedWorldOrigin;
	float PrePadding_InstancedView_2764;
	float4 InstancedView_SkyPlanetTranslatedWorldCenterAndViewHeight;
	float4x4 InstancedView_SkyViewLutReferential;
	float4 InstancedView_SkyAtmosphereSkyLuminanceFactor;
	float InstancedView_SkyAtmospherePresentInScene;
	float InstancedView_SkyAtmosphereHeightFogContribution;
	float InstancedView_SkyAtmosphereBottomRadiusKm;
	float InstancedView_SkyAtmosphereTopRadiusKm;
	float4 InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize;
	float InstancedView_SkyAtmosphereAerialPerspectiveStartDepthKm;
	float InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution;
	float InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv;
	float InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm;
	float InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv;
	float InstancedView_SkyAtmosphereApplyCameraAerialPerspectiveVolume;
	float PrePadding_InstancedView_2920;
	float PrePadding_InstancedView_2924;
	float3 InstancedView_NormalCurvatureToRoughnessScaleBias;
	float InstancedView_RenderingReflectionCaptureMask;
	float InstancedView_RealTimeReflectionCapture;
	float InstancedView_RealTimeReflectionCapturePreExposure;
	float PrePadding_InstancedView_2952;
	float PrePadding_InstancedView_2956;
	float4 InstancedView_AmbientCubemapTint;
	float InstancedView_AmbientCubemapIntensity;
	float InstancedView_SkyLightApplyPrecomputedBentNormalShadowingFlag;
	float InstancedView_SkyLightAffectReflectionFlag;
	float InstancedView_SkyLightAffectGlobalIlluminationFlag;
	float4 InstancedView_SkyLightColor;
	float4 InstancedView_MobileSkyIrradianceEnvironmentMap[8];
	float InstancedView_MobilePreviewMode;
	float InstancedView_HMDEyePaddingOffset;
	float InstancedView_ReflectionCubemapMaxMip;
	float InstancedView_ShowDecalsMask;
	uint InstancedView_DistanceFieldAOSpecularOcclusionMode;
	float InstancedView_IndirectCapsuleSelfShadowingIntensity;
	float PrePadding_InstancedView_3160;
	float PrePadding_InstancedView_3164;
	float3 InstancedView_ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	int InstancedView_StereoPassIndex;
	float4 InstancedView_GlobalVolumeCenterAndExtent[6];
	float4 InstancedView_GlobalVolumeWorldToUVAddAndMul[6];
	float4 InstancedView_GlobalDistanceFieldMipWorldToUVScale[6];
	float4 InstancedView_GlobalDistanceFieldMipWorldToUVBias[6];
	float InstancedView_GlobalDistanceFieldMipFactor;
	float InstancedView_GlobalDistanceFieldMipTransition;
	int InstancedView_GlobalDistanceFieldClipmapSizeInPages;
	int PrePadding_InstancedView_3580;
	float3 InstancedView_GlobalDistanceFieldInvPageAtlasSize;
	float PrePadding_InstancedView_3596;
	float3 InstancedView_GlobalDistanceFieldInvCoverageAtlasSize;
	float InstancedView_GlobalVolumeDimension;
	float InstancedView_GlobalVolumeTexelSize;
	float InstancedView_MaxGlobalDFAOConeDistance;
	uint InstancedView_NumGlobalSDFClipmaps;
	float InstancedView_CoveredExpandSurfaceScale;
	float InstancedView_NotCoveredExpandSurfaceScale;
	float InstancedView_NotCoveredMinStepScale;
	float InstancedView_DitheredTransparencyStepThreshold;
	float InstancedView_DitheredTransparencyTraceThreshold;
	int2 InstancedView_CursorPosition;
	float InstancedView_bCheckerboardSubsurfaceProfileRendering;
	float PrePadding_InstancedView_3660;
	float3 InstancedView_VolumetricFogInvGridSize;
	float PrePadding_InstancedView_3676;
	float3 InstancedView_VolumetricFogGridZParams;
	float PrePadding_InstancedView_3692;
	float2 InstancedView_VolumetricFogSVPosToVolumeUV;
	float InstancedView_VolumetricFogMaxDistance;
	float PrePadding_InstancedView_3708;
	float3 InstancedView_VolumetricLightmapWorldToUVScale;
	float PrePadding_InstancedView_3724;
	float3 InstancedView_VolumetricLightmapWorldToUVAdd;
	float PrePadding_InstancedView_3740;
	float3 InstancedView_VolumetricLightmapIndirectionTextureSize;
	float InstancedView_VolumetricLightmapBrickSize;
	float3 InstancedView_VolumetricLightmapBrickTexelSize;
	float InstancedView_IndirectLightingCacheShowFlag;
	float InstancedView_EyeToPixelSpreadAngle;
	float PrePadding_InstancedView_3780;
	float PrePadding_InstancedView_3784;
	float PrePadding_InstancedView_3788;
	float4 InstancedView_XRPassthroughCameraUVs[2];
	float InstancedView_GlobalVirtualTextureMipBias;
	uint InstancedView_VirtualTextureFeedbackShift;
	uint InstancedView_VirtualTextureFeedbackMask;
	uint InstancedView_VirtualTextureFeedbackStride;
	uint InstancedView_VirtualTextureFeedbackJitterOffset;
	uint InstancedView_VirtualTextureFeedbackSampleOffset;
	uint PrePadding_InstancedView_3848;
	uint PrePadding_InstancedView_3852;
	float4 InstancedView_RuntimeVirtualTextureMipLevel;
	float2 InstancedView_RuntimeVirtualTexturePackHeight;
	float PrePadding_InstancedView_3880;
	float PrePadding_InstancedView_3884;
	float4 InstancedView_RuntimeVirtualTextureDebugParams;
	float InstancedView_OverrideLandscapeLOD;
	int InstancedView_FarShadowStaticMeshLODBias;
	float InstancedView_MinRoughness;
	float PrePadding_InstancedView_3916;
	float4 InstancedView_HairRenderInfo;
	uint InstancedView_EnableSkyLight;
	uint InstancedView_HairRenderInfoBits;
	uint InstancedView_HairComponents;
	float InstancedView_bSubsurfacePostprocessEnabled;
	float4 InstancedView_SSProfilesTextureSizeAndInvSize;
	float4 InstancedView_SSProfilesPreIntegratedTextureSizeAndInvSize;
	float3 InstancedView_PhysicsFieldClipmapCenter;
	float InstancedView_PhysicsFieldClipmapDistance;
	int InstancedView_PhysicsFieldClipmapResolution;
	int InstancedView_PhysicsFieldClipmapExponent;
	int InstancedView_PhysicsFieldClipmapCount;
	int InstancedView_PhysicsFieldTargetCount;
	int4 InstancedView_PhysicsFieldTargets[32];
	uint InstancedView_InstanceSceneDataSOAStride;
	uint InstancedView_GPUSceneViewId;
	float InstancedView_ViewResolutionFraction;
	float InstancedView_SubSurfaceColorAsTransmittanceAtDistanceInMeters;
}
static const struct
{
	float4x4 TranslatedWorldToClip;
	float4x4 TranslatedWorldToSubpixelClip;
	float4x4 RelativeWorldToClip;
	float4x4 ClipToRelativeWorld;
	float4x4 TranslatedWorldToView;
	float4x4 ViewToTranslatedWorld;
	float4x4 TranslatedWorldToCameraView;
	float4x4 CameraViewToTranslatedWorld;
	float4x4 ViewToClip;
	float4x4 ViewToClipNoAA;
	float4x4 ClipToView;
	float4x4 ClipToTranslatedWorld;
	float4x4 SVPositionToTranslatedWorld;
	float4x4 ScreenToRelativeWorld;
	float4x4 ScreenToTranslatedWorld;
	float4x4 MobileMultiviewShadowTransform;
	float3 ViewTilePosition;
	float3 MatrixTilePosition;
	float3 ViewForward;
	float3 ViewUp;
	float3 ViewRight;
	float3 HMDViewNoRollUp;
	float3 HMDViewNoRollRight;
	float4 InvDeviceZToWorldZTransform;
	float4 ScreenPositionScaleBias;
	float3 RelativeWorldCameraOrigin;
	float3 TranslatedWorldCameraOrigin;
	float3 RelativeWorldViewOrigin;
	float3 RelativePreViewTranslation;
	float4x4 PrevViewToClip;
	float4x4 PrevClipToView;
	float4x4 PrevTranslatedWorldToClip;
	float4x4 PrevTranslatedWorldToView;
	float4x4 PrevViewToTranslatedWorld;
	float4x4 PrevTranslatedWorldToCameraView;
	float4x4 PrevCameraViewToTranslatedWorld;
	float3 PrevTranslatedWorldCameraOrigin;
	float3 PrevRelativeWorldCameraOrigin;
	float3 PrevRelativeWorldViewOrigin;
	float3 RelativePrevPreViewTranslation;
	float4x4 PrevClipToRelativeWorld;
	float4x4 PrevScreenToTranslatedWorld;
	float4x4 ClipToPrevClip;
	float4x4 ClipToPrevClipWithAA;
	float4 TemporalAAJitter;
	float4 GlobalClippingPlane;
	float2 FieldOfViewWideAngles;
	float2 PrevFieldOfViewWideAngles;
	float4 ViewRectMin;
	float4 ViewSizeAndInvSize;
	uint4 ViewRectMinAndSize;
	float4 LightProbeSizeRatioAndInvSizeRatio;
	float4 BufferSizeAndInvSize;
	float4 BufferBilinearUVMinMax;
	float4 ScreenToViewSpace;
	float2 BufferToSceneTextureScale;
	float2 ResolutionFractionAndInv;
	int NumSceneColorMSAASamples;
	float SeparateWaterMainDirLightLuminance;
	float PreExposure;
	float OneOverPreExposure;
	float4 DiffuseOverrideParameter;
	float4 SpecularOverrideParameter;
	float4 NormalOverrideParameter;
	float2 RoughnessOverrideParameter;
	float PrevFrameGameTime;
	float PrevFrameRealTime;
	float OutOfBoundsMask;
	float3 WorldCameraMovementSinceLastFrame;
	float CullingSign;
	float NearPlane;
	float GameTime;
	float RealTime;
	float DeltaTime;
	float MaterialTextureMipBias;
	float MaterialTextureDerivativeMultiply;
	uint Random;
	uint FrameNumber;
	uint StateFrameIndexMod8;
	uint StateFrameIndex;
	uint DebugViewModeMask;
	float CameraCut;
	float UnlitViewmodeMask;
	float4 DirectionalLightColor;
	float3 DirectionalLightDirection;
	float4 TranslucencyLightingVolumeMin[2];
	float4 TranslucencyLightingVolumeInvSize[2];
	float4 TemporalAAParams;
	float4 CircleDOFParams;
	float DepthOfFieldSensorWidth;
	float DepthOfFieldFocalDistance;
	float DepthOfFieldScale;
	float DepthOfFieldFocalLength;
	float DepthOfFieldFocalRegion;
	float DepthOfFieldNearTransitionRegion;
	float DepthOfFieldFarTransitionRegion;
	float MotionBlurNormalizedToPixel;
	float GeneralPurposeTweak;
	float GeneralPurposeTweak2;
	float DemosaicVposOffset;
	float DecalDepthBias;
	float3 IndirectLightingColorScale;
	float3 PrecomputedIndirectLightingColorScale;
	float3 PrecomputedIndirectSpecularColorScale;
	float4 AtmosphereLightDirection[2];
	float4 AtmosphereLightIlluminanceOnGroundPostTransmittance[2];
	float4 AtmosphereLightIlluminanceOuterSpace[2];
	float4 AtmosphereLightDiscLuminance[2];
	float4 AtmosphereLightDiscCosHalfApexAngle_PPTrans[2];
	float4 SkyViewLutSizeAndInvSize;
	float3 SkyCameraTranslatedWorldOrigin;
	float4 SkyPlanetTranslatedWorldCenterAndViewHeight;
	float4x4 SkyViewLutReferential;
	float4 SkyAtmosphereSkyLuminanceFactor;
	float SkyAtmospherePresentInScene;
	float SkyAtmosphereHeightFogContribution;
	float SkyAtmosphereBottomRadiusKm;
	float SkyAtmosphereTopRadiusKm;
	float4 SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize;
	float SkyAtmosphereAerialPerspectiveStartDepthKm;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv;
	float SkyAtmosphereApplyCameraAerialPerspectiveVolume;
	float3 NormalCurvatureToRoughnessScaleBias;
	float RenderingReflectionCaptureMask;
	float RealTimeReflectionCapture;
	float RealTimeReflectionCapturePreExposure;
	float4 AmbientCubemapTint;
	float AmbientCubemapIntensity;
	float SkyLightApplyPrecomputedBentNormalShadowingFlag;
	float SkyLightAffectReflectionFlag;
	float SkyLightAffectGlobalIlluminationFlag;
	float4 SkyLightColor;
	float4 MobileSkyIrradianceEnvironmentMap[8];
	float MobilePreviewMode;
	float HMDEyePaddingOffset;
	float ReflectionCubemapMaxMip;
	float ShowDecalsMask;
	uint DistanceFieldAOSpecularOcclusionMode;
	float IndirectCapsuleSelfShadowingIntensity;
	float3 ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	int StereoPassIndex;
	float4 GlobalVolumeCenterAndExtent[6];
	float4 GlobalVolumeWorldToUVAddAndMul[6];
	float4 GlobalDistanceFieldMipWorldToUVScale[6];
	float4 GlobalDistanceFieldMipWorldToUVBias[6];
	float GlobalDistanceFieldMipFactor;
	float GlobalDistanceFieldMipTransition;
	int GlobalDistanceFieldClipmapSizeInPages;
	float3 GlobalDistanceFieldInvPageAtlasSize;
	float3 GlobalDistanceFieldInvCoverageAtlasSize;
	float GlobalVolumeDimension;
	float GlobalVolumeTexelSize;
	float MaxGlobalDFAOConeDistance;
	uint NumGlobalSDFClipmaps;
	float CoveredExpandSurfaceScale;
	float NotCoveredExpandSurfaceScale;
	float NotCoveredMinStepScale;
	float DitheredTransparencyStepThreshold;
	float DitheredTransparencyTraceThreshold;
	int2 CursorPosition;
	float bCheckerboardSubsurfaceProfileRendering;
	float3 VolumetricFogInvGridSize;
	float3 VolumetricFogGridZParams;
	float2 VolumetricFogSVPosToVolumeUV;
	float VolumetricFogMaxDistance;
	float3 VolumetricLightmapWorldToUVScale;
	float3 VolumetricLightmapWorldToUVAdd;
	float3 VolumetricLightmapIndirectionTextureSize;
	float VolumetricLightmapBrickSize;
	float3 VolumetricLightmapBrickTexelSize;
	float IndirectLightingCacheShowFlag;
	float EyeToPixelSpreadAngle;
	float4 XRPassthroughCameraUVs[2];
	float GlobalVirtualTextureMipBias;
	uint VirtualTextureFeedbackShift;
	uint VirtualTextureFeedbackMask;
	uint VirtualTextureFeedbackStride;
	uint VirtualTextureFeedbackJitterOffset;
	uint VirtualTextureFeedbackSampleOffset;
	float4 RuntimeVirtualTextureMipLevel;
	float2 RuntimeVirtualTexturePackHeight;
	float4 RuntimeVirtualTextureDebugParams;
	float OverrideLandscapeLOD;
	int FarShadowStaticMeshLODBias;
	float MinRoughness;
	float4 HairRenderInfo;
	uint EnableSkyLight;
	uint HairRenderInfoBits;
	uint HairComponents;
	float bSubsurfacePostprocessEnabled;
	float4 SSProfilesTextureSizeAndInvSize;
	float4 SSProfilesPreIntegratedTextureSizeAndInvSize;
	float3 PhysicsFieldClipmapCenter;
	float PhysicsFieldClipmapDistance;
	int PhysicsFieldClipmapResolution;
	int PhysicsFieldClipmapExponent;
	int PhysicsFieldClipmapCount;
	int PhysicsFieldTargetCount;
	int4 PhysicsFieldTargets[32];
	uint InstanceSceneDataSOAStride;
	uint GPUSceneViewId;
	float ViewResolutionFraction;
	float SubSurfaceColorAsTransmittanceAtDistanceInMeters;
} InstancedView = {InstancedView_TranslatedWorldToClip,InstancedView_TranslatedWorldToSubpixelClip,InstancedView_RelativeWorldToClip,InstancedView_ClipToRelativeWorld,InstancedView_TranslatedWorldToView,InstancedView_ViewToTranslatedWorld,InstancedView_TranslatedWorldToCameraView,InstancedView_CameraViewToTranslatedWorld,InstancedView_ViewToClip,InstancedView_ViewToClipNoAA,InstancedView_ClipToView,InstancedView_ClipToTranslatedWorld,InstancedView_SVPositionToTranslatedWorld,InstancedView_ScreenToRelativeWorld,InstancedView_ScreenToTranslatedWorld,InstancedView_MobileMultiviewShadowTransform,InstancedView_ViewTilePosition,InstancedView_MatrixTilePosition,InstancedView_ViewForward,InstancedView_ViewUp,InstancedView_ViewRight,InstancedView_HMDViewNoRollUp,InstancedView_HMDViewNoRollRight,InstancedView_InvDeviceZToWorldZTransform,InstancedView_ScreenPositionScaleBias,InstancedView_RelativeWorldCameraOrigin,InstancedView_TranslatedWorldCameraOrigin,InstancedView_RelativeWorldViewOrigin,InstancedView_RelativePreViewTranslation,InstancedView_PrevViewToClip,InstancedView_PrevClipToView,InstancedView_PrevTranslatedWorldToClip,InstancedView_PrevTranslatedWorldToView,InstancedView_PrevViewToTranslatedWorld,InstancedView_PrevTranslatedWorldToCameraView,InstancedView_PrevCameraViewToTranslatedWorld,InstancedView_PrevTranslatedWorldCameraOrigin,InstancedView_PrevRelativeWorldCameraOrigin,InstancedView_PrevRelativeWorldViewOrigin,InstancedView_RelativePrevPreViewTranslation,InstancedView_PrevClipToRelativeWorld,InstancedView_PrevScreenToTranslatedWorld,InstancedView_ClipToPrevClip,InstancedView_ClipToPrevClipWithAA,InstancedView_TemporalAAJitter,InstancedView_GlobalClippingPlane,InstancedView_FieldOfViewWideAngles,InstancedView_PrevFieldOfViewWideAngles,InstancedView_ViewRectMin,InstancedView_ViewSizeAndInvSize,InstancedView_ViewRectMinAndSize,InstancedView_LightProbeSizeRatioAndInvSizeRatio,InstancedView_BufferSizeAndInvSize,InstancedView_BufferBilinearUVMinMax,InstancedView_ScreenToViewSpace,InstancedView_BufferToSceneTextureScale,InstancedView_ResolutionFractionAndInv,InstancedView_NumSceneColorMSAASamples,InstancedView_SeparateWaterMainDirLightLuminance,InstancedView_PreExposure,InstancedView_OneOverPreExposure,InstancedView_DiffuseOverrideParameter,InstancedView_SpecularOverrideParameter,InstancedView_NormalOverrideParameter,InstancedView_RoughnessOverrideParameter,InstancedView_PrevFrameGameTime,InstancedView_PrevFrameRealTime,InstancedView_OutOfBoundsMask,InstancedView_WorldCameraMovementSinceLastFrame,InstancedView_CullingSign,InstancedView_NearPlane,InstancedView_GameTime,InstancedView_RealTime,InstancedView_DeltaTime,InstancedView_MaterialTextureMipBias,InstancedView_MaterialTextureDerivativeMultiply,InstancedView_Random,InstancedView_FrameNumber,InstancedView_StateFrameIndexMod8,InstancedView_StateFrameIndex,InstancedView_DebugViewModeMask,InstancedView_CameraCut,InstancedView_UnlitViewmodeMask,InstancedView_DirectionalLightColor,InstancedView_DirectionalLightDirection,InstancedView_TranslucencyLightingVolumeMin,InstancedView_TranslucencyLightingVolumeInvSize,InstancedView_TemporalAAParams,InstancedView_CircleDOFParams,InstancedView_DepthOfFieldSensorWidth,InstancedView_DepthOfFieldFocalDistance,InstancedView_DepthOfFieldScale,InstancedView_DepthOfFieldFocalLength,InstancedView_DepthOfFieldFocalRegion,InstancedView_DepthOfFieldNearTransitionRegion,InstancedView_DepthOfFieldFarTransitionRegion,InstancedView_MotionBlurNormalizedToPixel,InstancedView_GeneralPurposeTweak,InstancedView_GeneralPurposeTweak2,InstancedView_DemosaicVposOffset,InstancedView_DecalDepthBias,InstancedView_IndirectLightingColorScale,InstancedView_PrecomputedIndirectLightingColorScale,InstancedView_PrecomputedIndirectSpecularColorScale,InstancedView_AtmosphereLightDirection,InstancedView_AtmosphereLightIlluminanceOnGroundPostTransmittance,InstancedView_AtmosphereLightIlluminanceOuterSpace,InstancedView_AtmosphereLightDiscLuminance,InstancedView_AtmosphereLightDiscCosHalfApexAngle_PPTrans,InstancedView_SkyViewLutSizeAndInvSize,InstancedView_SkyCameraTranslatedWorldOrigin,InstancedView_SkyPlanetTranslatedWorldCenterAndViewHeight,InstancedView_SkyViewLutReferential,InstancedView_SkyAtmosphereSkyLuminanceFactor,InstancedView_SkyAtmospherePresentInScene,InstancedView_SkyAtmosphereHeightFogContribution,InstancedView_SkyAtmosphereBottomRadiusKm,InstancedView_SkyAtmosphereTopRadiusKm,InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize,InstancedView_SkyAtmosphereAerialPerspectiveStartDepthKm,InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution,InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv,InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm,InstancedView_SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv,InstancedView_SkyAtmosphereApplyCameraAerialPerspectiveVolume,InstancedView_NormalCurvatureToRoughnessScaleBias,InstancedView_RenderingReflectionCaptureMask,InstancedView_RealTimeReflectionCapture,InstancedView_RealTimeReflectionCapturePreExposure,InstancedView_AmbientCubemapTint,InstancedView_AmbientCubemapIntensity,InstancedView_SkyLightApplyPrecomputedBentNormalShadowingFlag,InstancedView_SkyLightAffectReflectionFlag,InstancedView_SkyLightAffectGlobalIlluminationFlag,InstancedView_SkyLightColor,InstancedView_MobileSkyIrradianceEnvironmentMap,InstancedView_MobilePreviewMode,InstancedView_HMDEyePaddingOffset,InstancedView_ReflectionCubemapMaxMip,InstancedView_ShowDecalsMask,InstancedView_DistanceFieldAOSpecularOcclusionMode,InstancedView_IndirectCapsuleSelfShadowingIntensity,InstancedView_ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight,InstancedView_StereoPassIndex,InstancedView_GlobalVolumeCenterAndExtent,InstancedView_GlobalVolumeWorldToUVAddAndMul,InstancedView_GlobalDistanceFieldMipWorldToUVScale,InstancedView_GlobalDistanceFieldMipWorldToUVBias,InstancedView_GlobalDistanceFieldMipFactor,InstancedView_GlobalDistanceFieldMipTransition,InstancedView_GlobalDistanceFieldClipmapSizeInPages,InstancedView_GlobalDistanceFieldInvPageAtlasSize,InstancedView_GlobalDistanceFieldInvCoverageAtlasSize,InstancedView_GlobalVolumeDimension,InstancedView_GlobalVolumeTexelSize,InstancedView_MaxGlobalDFAOConeDistance,InstancedView_NumGlobalSDFClipmaps,InstancedView_CoveredExpandSurfaceScale,InstancedView_NotCoveredExpandSurfaceScale,InstancedView_NotCoveredMinStepScale,InstancedView_DitheredTransparencyStepThreshold,InstancedView_DitheredTransparencyTraceThreshold,InstancedView_CursorPosition,InstancedView_bCheckerboardSubsurfaceProfileRendering,InstancedView_VolumetricFogInvGridSize,InstancedView_VolumetricFogGridZParams,InstancedView_VolumetricFogSVPosToVolumeUV,InstancedView_VolumetricFogMaxDistance,InstancedView_VolumetricLightmapWorldToUVScale,InstancedView_VolumetricLightmapWorldToUVAdd,InstancedView_VolumetricLightmapIndirectionTextureSize,InstancedView_VolumetricLightmapBrickSize,InstancedView_VolumetricLightmapBrickTexelSize,InstancedView_IndirectLightingCacheShowFlag,InstancedView_EyeToPixelSpreadAngle,InstancedView_XRPassthroughCameraUVs,InstancedView_GlobalVirtualTextureMipBias,InstancedView_VirtualTextureFeedbackShift,InstancedView_VirtualTextureFeedbackMask,InstancedView_VirtualTextureFeedbackStride,InstancedView_VirtualTextureFeedbackJitterOffset,InstancedView_VirtualTextureFeedbackSampleOffset,InstancedView_RuntimeVirtualTextureMipLevel,InstancedView_RuntimeVirtualTexturePackHeight,InstancedView_RuntimeVirtualTextureDebugParams,InstancedView_OverrideLandscapeLOD,InstancedView_FarShadowStaticMeshLODBias,InstancedView_MinRoughness,InstancedView_HairRenderInfo,InstancedView_EnableSkyLight,InstancedView_HairRenderInfoBits,InstancedView_HairComponents,InstancedView_bSubsurfacePostprocessEnabled,InstancedView_SSProfilesTextureSizeAndInvSize,InstancedView_SSProfilesPreIntegratedTextureSizeAndInvSize,InstancedView_PhysicsFieldClipmapCenter,InstancedView_PhysicsFieldClipmapDistance,InstancedView_PhysicsFieldClipmapResolution,InstancedView_PhysicsFieldClipmapExponent,InstancedView_PhysicsFieldClipmapCount,InstancedView_PhysicsFieldTargetCount,InstancedView_PhysicsFieldTargets,InstancedView_InstanceSceneDataSOAStride,InstancedView_GPUSceneViewId,InstancedView_ViewResolutionFraction,InstancedView_SubSurfaceColorAsTransmittanceAtDistanceInMeters,};
#line 5 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/SceneTexturesStruct.ush"


cbuffer  UniformBufferConstants_SceneTexturesStruct
{
	uint BindlessResource_SceneTexturesStruct_SceneColorTexture ;
	uint PrePadding_SceneTexturesStruct_4;
	uint BindlessResource_SceneTexturesStruct_SceneDepthTexture ;
	uint PrePadding_SceneTexturesStruct_12;
	uint BindlessResource_SceneTexturesStruct_GBufferATexture ;
	uint PrePadding_SceneTexturesStruct_20;
	uint BindlessResource_SceneTexturesStruct_GBufferBTexture ;
	uint PrePadding_SceneTexturesStruct_28;
	uint BindlessResource_SceneTexturesStruct_GBufferCTexture ;
	uint PrePadding_SceneTexturesStruct_36;
	uint BindlessResource_SceneTexturesStruct_GBufferDTexture ;
	uint PrePadding_SceneTexturesStruct_44;
	uint BindlessResource_SceneTexturesStruct_GBufferETexture ;
	uint PrePadding_SceneTexturesStruct_52;
	uint BindlessResource_SceneTexturesStruct_GBufferFTexture ;
	uint PrePadding_SceneTexturesStruct_60;
	uint BindlessResource_SceneTexturesStruct_GBufferVelocityTexture ;
	uint PrePadding_SceneTexturesStruct_68;
	uint BindlessResource_SceneTexturesStruct_ScreenSpaceAOTexture ;
	uint PrePadding_SceneTexturesStruct_76;
	uint BindlessResource_SceneTexturesStruct_CustomDepthTexture ;
	uint PrePadding_SceneTexturesStruct_84;
	uint BindlessResource_SceneTexturesStruct_CustomStencilTexture ;
	uint PrePadding_SceneTexturesStruct_92;
	uint BindlessSampler_SceneTexturesStruct_PointClampSampler ;
}
Texture2D SceneTexturesStruct_SceneColorTexture ;
Texture2D SceneTexturesStruct_SceneDepthTexture ;
Texture2D SceneTexturesStruct_GBufferATexture ;
Texture2D SceneTexturesStruct_GBufferBTexture ;
Texture2D SceneTexturesStruct_GBufferCTexture ;
Texture2D SceneTexturesStruct_GBufferDTexture ;
Texture2D SceneTexturesStruct_GBufferETexture ;
Texture2D SceneTexturesStruct_GBufferFTexture ;
Texture2D SceneTexturesStruct_GBufferVelocityTexture ;
Texture2D SceneTexturesStruct_ScreenSpaceAOTexture ;
Texture2D SceneTexturesStruct_CustomDepthTexture ;
Texture2D<uint2> SceneTexturesStruct_CustomStencilTexture ;
SamplerState SceneTexturesStruct_PointClampSampler ;
static const struct
{
	Texture2D SceneColorTexture;
	Texture2D SceneDepthTexture;
	Texture2D GBufferATexture;
	Texture2D GBufferBTexture;
	Texture2D GBufferCTexture;
	Texture2D GBufferDTexture;
	Texture2D GBufferETexture;
	Texture2D GBufferFTexture;
	Texture2D GBufferVelocityTexture;
	Texture2D ScreenSpaceAOTexture;
	Texture2D CustomDepthTexture;
	Texture2D<uint2> CustomStencilTexture;
	SamplerState PointClampSampler;
} SceneTexturesStruct = {SceneTexturesStruct_SceneColorTexture,SceneTexturesStruct_SceneDepthTexture,SceneTexturesStruct_GBufferATexture,SceneTexturesStruct_GBufferBTexture,SceneTexturesStruct_GBufferCTexture,SceneTexturesStruct_GBufferDTexture,SceneTexturesStruct_GBufferETexture,SceneTexturesStruct_GBufferFTexture,SceneTexturesStruct_GBufferVelocityTexture,SceneTexturesStruct_ScreenSpaceAOTexture,SceneTexturesStruct_CustomDepthTexture,SceneTexturesStruct_CustomStencilTexture,SceneTexturesStruct_PointClampSampler,};
#line 6 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/MobileSceneTextures.ush"


cbuffer  UniformBufferConstants_MobileSceneTextures
{
	uint BindlessResource_MobileSceneTextures_SceneColorTexture ;
	uint PrePadding_MobileSceneTextures_4;
	uint BindlessSampler_MobileSceneTextures_SceneColorTextureSampler ;
	uint PrePadding_MobileSceneTextures_12;
	uint BindlessResource_MobileSceneTextures_SceneDepthTexture ;
	uint PrePadding_MobileSceneTextures_20;
	uint BindlessSampler_MobileSceneTextures_SceneDepthTextureSampler ;
	uint PrePadding_MobileSceneTextures_28;
	uint BindlessResource_MobileSceneTextures_CustomDepthTexture ;
	uint PrePadding_MobileSceneTextures_36;
	uint BindlessSampler_MobileSceneTextures_CustomDepthTextureSampler ;
	uint PrePadding_MobileSceneTextures_44;
	uint BindlessResource_MobileSceneTextures_CustomStencilTexture ;
	uint PrePadding_MobileSceneTextures_52;
	uint BindlessResource_MobileSceneTextures_SceneVelocityTexture ;
	uint PrePadding_MobileSceneTextures_60;
	uint BindlessSampler_MobileSceneTextures_SceneVelocityTextureSampler ;
	uint PrePadding_MobileSceneTextures_68;
	uint BindlessResource_MobileSceneTextures_GBufferATexture ;
	uint PrePadding_MobileSceneTextures_76;
	uint BindlessResource_MobileSceneTextures_GBufferBTexture ;
	uint PrePadding_MobileSceneTextures_84;
	uint BindlessResource_MobileSceneTextures_GBufferCTexture ;
	uint PrePadding_MobileSceneTextures_92;
	uint BindlessResource_MobileSceneTextures_GBufferDTexture ;
	uint PrePadding_MobileSceneTextures_100;
	uint BindlessResource_MobileSceneTextures_SceneDepthAuxTexture ;
	uint PrePadding_MobileSceneTextures_108;
	uint BindlessSampler_MobileSceneTextures_GBufferATextureSampler ;
	uint PrePadding_MobileSceneTextures_116;
	uint BindlessSampler_MobileSceneTextures_GBufferBTextureSampler ;
	uint PrePadding_MobileSceneTextures_124;
	uint BindlessSampler_MobileSceneTextures_GBufferCTextureSampler ;
	uint PrePadding_MobileSceneTextures_132;
	uint BindlessSampler_MobileSceneTextures_GBufferDTextureSampler ;
	uint PrePadding_MobileSceneTextures_140;
	uint BindlessSampler_MobileSceneTextures_SceneDepthAuxTextureSampler ;
}
Texture2D MobileSceneTextures_SceneColorTexture ;
SamplerState MobileSceneTextures_SceneColorTextureSampler ;
Texture2D MobileSceneTextures_SceneDepthTexture ;
SamplerState MobileSceneTextures_SceneDepthTextureSampler ;
Texture2D MobileSceneTextures_CustomDepthTexture ;
SamplerState MobileSceneTextures_CustomDepthTextureSampler ;
Texture2D<uint2> MobileSceneTextures_CustomStencilTexture ;
Texture2D MobileSceneTextures_SceneVelocityTexture ;
SamplerState MobileSceneTextures_SceneVelocityTextureSampler ;
Texture2D MobileSceneTextures_GBufferATexture ;
Texture2D MobileSceneTextures_GBufferBTexture ;
Texture2D MobileSceneTextures_GBufferCTexture ;
Texture2D MobileSceneTextures_GBufferDTexture ;
Texture2D MobileSceneTextures_SceneDepthAuxTexture ;
SamplerState MobileSceneTextures_GBufferATextureSampler ;
SamplerState MobileSceneTextures_GBufferBTextureSampler ;
SamplerState MobileSceneTextures_GBufferCTextureSampler ;
SamplerState MobileSceneTextures_GBufferDTextureSampler ;
SamplerState MobileSceneTextures_SceneDepthAuxTextureSampler ;
static const struct
{
	Texture2D SceneColorTexture;
	SamplerState SceneColorTextureSampler;
	Texture2D SceneDepthTexture;
	SamplerState SceneDepthTextureSampler;
	Texture2D CustomDepthTexture;
	SamplerState CustomDepthTextureSampler;
	Texture2D<uint2> CustomStencilTexture;
	Texture2D SceneVelocityTexture;
	SamplerState SceneVelocityTextureSampler;
	Texture2D GBufferATexture;
	Texture2D GBufferBTexture;
	Texture2D GBufferCTexture;
	Texture2D GBufferDTexture;
	Texture2D SceneDepthAuxTexture;
	SamplerState GBufferATextureSampler;
	SamplerState GBufferBTextureSampler;
	SamplerState GBufferCTextureSampler;
	SamplerState GBufferDTextureSampler;
	SamplerState SceneDepthAuxTextureSampler;
} MobileSceneTextures = {MobileSceneTextures_SceneColorTexture,MobileSceneTextures_SceneColorTextureSampler,MobileSceneTextures_SceneDepthTexture,MobileSceneTextures_SceneDepthTextureSampler,MobileSceneTextures_CustomDepthTexture,MobileSceneTextures_CustomDepthTextureSampler,MobileSceneTextures_CustomStencilTexture,MobileSceneTextures_SceneVelocityTexture,MobileSceneTextures_SceneVelocityTextureSampler,MobileSceneTextures_GBufferATexture,MobileSceneTextures_GBufferBTexture,MobileSceneTextures_GBufferCTexture,MobileSceneTextures_GBufferDTexture,MobileSceneTextures_SceneDepthAuxTexture,MobileSceneTextures_GBufferATextureSampler,MobileSceneTextures_GBufferBTextureSampler,MobileSceneTextures_GBufferCTextureSampler,MobileSceneTextures_GBufferDTextureSampler,MobileSceneTextures_SceneDepthAuxTextureSampler,};
#line 7 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/DeferredLightUniforms.ush"


cbuffer  UniformBufferConstants_DeferredLightUniforms
{
	float4 DeferredLightUniforms_ShadowMapChannelMask;
	float2 DeferredLightUniforms_DistanceFadeMAD;
	float DeferredLightUniforms_ContactShadowLength;
	float DeferredLightUniforms_ContactShadowNonShadowCastingIntensity;
	float DeferredLightUniforms_VolumetricScatteringIntensity;
	uint DeferredLightUniforms_ShadowedBits;
	uint DeferredLightUniforms_LightingChannelMask;
	float PrePadding_DeferredLightUniforms_44;
	float3 DeferredLightUniforms_TranslatedWorldPosition;
	float DeferredLightUniforms_InvRadius;
	float3 DeferredLightUniforms_Color;
	float DeferredLightUniforms_FalloffExponent;
	float3 DeferredLightUniforms_Direction;
	float DeferredLightUniforms_SpecularScale;
	float3 DeferredLightUniforms_Tangent;
	float DeferredLightUniforms_SourceRadius;
	float2 DeferredLightUniforms_SpotAngles;
	float DeferredLightUniforms_SoftSourceRadius;
	float DeferredLightUniforms_SourceLength;
	float DeferredLightUniforms_RectLightBarnCosAngle;
	float DeferredLightUniforms_RectLightBarnLength;
	float2 DeferredLightUniforms_RectLightAtlasUVOffset;
	float2 DeferredLightUniforms_RectLightAtlasUVScale;
	float DeferredLightUniforms_RectLightAtlasMaxLevel;
}
static const struct
{
	float4 ShadowMapChannelMask;
	float2 DistanceFadeMAD;
	float ContactShadowLength;
	float ContactShadowNonShadowCastingIntensity;
	float VolumetricScatteringIntensity;
	uint ShadowedBits;
	uint LightingChannelMask;
	float3 TranslatedWorldPosition;
	float InvRadius;
	float3 Color;
	float FalloffExponent;
	float3 Direction;
	float SpecularScale;
	float3 Tangent;
	float SourceRadius;
	float2 SpotAngles;
	float SoftSourceRadius;
	float SourceLength;
	float RectLightBarnCosAngle;
	float RectLightBarnLength;
	float2 RectLightAtlasUVOffset;
	float2 RectLightAtlasUVScale;
	float RectLightAtlasMaxLevel;
} DeferredLightUniforms = {DeferredLightUniforms_ShadowMapChannelMask,DeferredLightUniforms_DistanceFadeMAD,DeferredLightUniforms_ContactShadowLength,DeferredLightUniforms_ContactShadowNonShadowCastingIntensity,DeferredLightUniforms_VolumetricScatteringIntensity,DeferredLightUniforms_ShadowedBits,DeferredLightUniforms_LightingChannelMask,DeferredLightUniforms_TranslatedWorldPosition,DeferredLightUniforms_InvRadius,DeferredLightUniforms_Color,DeferredLightUniforms_FalloffExponent,DeferredLightUniforms_Direction,DeferredLightUniforms_SpecularScale,DeferredLightUniforms_Tangent,DeferredLightUniforms_SourceRadius,DeferredLightUniforms_SpotAngles,DeferredLightUniforms_SoftSourceRadius,DeferredLightUniforms_SourceLength,DeferredLightUniforms_RectLightBarnCosAngle,DeferredLightUniforms_RectLightBarnLength,DeferredLightUniforms_RectLightAtlasUVOffset,DeferredLightUniforms_RectLightAtlasUVScale,DeferredLightUniforms_RectLightAtlasMaxLevel,};
#line 8 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/RaytracingLightsDataPacked.ush"


cbuffer  UniformBufferConstants_RaytracingLightsDataPacked
{
	uint RaytracingLightsDataPacked_Count;
	float RaytracingLightsDataPacked_IESLightProfileInvCount;
	uint RaytracingLightsDataPacked_CellCount;
	float RaytracingLightsDataPacked_CellScale;
	uint BindlessSampler_RaytracingLightsDataPacked_IESLightProfileTextureSampler ;
	uint PrePadding_RaytracingLightsDataPacked_20;
	uint BindlessResource_RaytracingLightsDataPacked_IESLightProfileTexture ;
	uint PrePadding_RaytracingLightsDataPacked_28;
	uint BindlessResource_RaytracingLightsDataPacked_LightDataBuffer ;
	uint PrePadding_RaytracingLightsDataPacked_36;
	uint BindlessResource_RaytracingLightsDataPacked_LightIndices ;
	uint PrePadding_RaytracingLightsDataPacked_44;
	uint BindlessResource_RaytracingLightsDataPacked_LightCullingVolume ;
}
SamplerState RaytracingLightsDataPacked_IESLightProfileTextureSampler ;
Texture2D RaytracingLightsDataPacked_IESLightProfileTexture ;
StructuredBuffer<uint4> RaytracingLightsDataPacked_LightDataBuffer ;
Buffer<uint> RaytracingLightsDataPacked_LightIndices ;
StructuredBuffer<uint4> RaytracingLightsDataPacked_LightCullingVolume ;
static const struct
{
	uint Count;
	float IESLightProfileInvCount;
	uint CellCount;
	float CellScale;
	SamplerState IESLightProfileTextureSampler;
	Texture2D IESLightProfileTexture;
	StructuredBuffer<uint4> LightDataBuffer;
	Buffer<uint> LightIndices;
	StructuredBuffer<uint4> LightCullingVolume;
} RaytracingLightsDataPacked = {RaytracingLightsDataPacked_Count,RaytracingLightsDataPacked_IESLightProfileInvCount,RaytracingLightsDataPacked_CellCount,RaytracingLightsDataPacked_CellScale,RaytracingLightsDataPacked_IESLightProfileTextureSampler,RaytracingLightsDataPacked_IESLightProfileTexture,RaytracingLightsDataPacked_LightDataBuffer,RaytracingLightsDataPacked_LightIndices,RaytracingLightsDataPacked_LightCullingVolume,};
#line 9 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/LumenCardScene.ush"


cbuffer  UniformBufferConstants_LumenCardScene
{
	uint LumenCardScene_NumCards;
	uint LumenCardScene_NumMeshCards;
	uint LumenCardScene_NumCardPages;
	uint LumenCardScene_NumHeightfields;
	uint LumenCardScene_MaxConeSteps;
	uint PrePadding_LumenCardScene_20;
	float2 LumenCardScene_PhysicalAtlasSize;
	float2 LumenCardScene_InvPhysicalAtlasSize;
	float LumenCardScene_IndirectLightingAtlasDownsampleFactor;
	uint LumenCardScene_NumDistantCards;
	float LumenCardScene_DistantSceneMaxTraceDistance;
	float PrePadding_LumenCardScene_52;
	float PrePadding_LumenCardScene_56;
	float PrePadding_LumenCardScene_60;
	float3 LumenCardScene_DistantSceneDirection;
	float PrePadding_LumenCardScene_76;
	uint4 LumenCardScene_DistantCardIndices[2];
	uint BindlessResource_LumenCardScene_CardData ;
	uint PrePadding_LumenCardScene_116;
	uint BindlessResource_LumenCardScene_CardPageData ;
	uint PrePadding_LumenCardScene_124;
	uint BindlessResource_LumenCardScene_MeshCardsData ;
	uint PrePadding_LumenCardScene_132;
	uint BindlessResource_LumenCardScene_HeightfieldData ;
	uint PrePadding_LumenCardScene_140;
	uint BindlessResource_LumenCardScene_PageTableBuffer ;
	uint PrePadding_LumenCardScene_148;
	uint BindlessResource_LumenCardScene_SceneInstanceIndexToMeshCardsIndexBuffer ;
	uint PrePadding_LumenCardScene_156;
	uint BindlessResource_LumenCardScene_AlbedoAtlas ;
	uint PrePadding_LumenCardScene_164;
	uint BindlessResource_LumenCardScene_OpacityAtlas ;
	uint PrePadding_LumenCardScene_172;
	uint BindlessResource_LumenCardScene_NormalAtlas ;
	uint PrePadding_LumenCardScene_180;
	uint BindlessResource_LumenCardScene_EmissiveAtlas ;
	uint PrePadding_LumenCardScene_188;
	uint BindlessResource_LumenCardScene_DepthAtlas ;
}
StructuredBuffer<float4> LumenCardScene_CardData ;
StructuredBuffer<float4> LumenCardScene_CardPageData ;
StructuredBuffer<float4> LumenCardScene_MeshCardsData ;
StructuredBuffer<float4> LumenCardScene_HeightfieldData ;
ByteAddressBuffer LumenCardScene_PageTableBuffer ;
ByteAddressBuffer LumenCardScene_SceneInstanceIndexToMeshCardsIndexBuffer ;
Texture2D LumenCardScene_AlbedoAtlas ;
Texture2D LumenCardScene_OpacityAtlas ;
Texture2D LumenCardScene_NormalAtlas ;
Texture2D LumenCardScene_EmissiveAtlas ;
Texture2D LumenCardScene_DepthAtlas ;
static const struct
{
	uint NumCards;
	uint NumMeshCards;
	uint NumCardPages;
	uint NumHeightfields;
	uint MaxConeSteps;
	float2 PhysicalAtlasSize;
	float2 InvPhysicalAtlasSize;
	float IndirectLightingAtlasDownsampleFactor;
	uint NumDistantCards;
	float DistantSceneMaxTraceDistance;
	float3 DistantSceneDirection;
	uint4 DistantCardIndices[2];
	StructuredBuffer<float4> CardData;
	StructuredBuffer<float4> CardPageData;
	StructuredBuffer<float4> MeshCardsData;
	StructuredBuffer<float4> HeightfieldData;
	ByteAddressBuffer PageTableBuffer;
	ByteAddressBuffer SceneInstanceIndexToMeshCardsIndexBuffer;
	Texture2D AlbedoAtlas;
	Texture2D OpacityAtlas;
	Texture2D NormalAtlas;
	Texture2D EmissiveAtlas;
	Texture2D DepthAtlas;
} LumenCardScene = {LumenCardScene_NumCards,LumenCardScene_NumMeshCards,LumenCardScene_NumCardPages,LumenCardScene_NumHeightfields,LumenCardScene_MaxConeSteps,LumenCardScene_PhysicalAtlasSize,LumenCardScene_InvPhysicalAtlasSize,LumenCardScene_IndirectLightingAtlasDownsampleFactor,LumenCardScene_NumDistantCards,LumenCardScene_DistantSceneMaxTraceDistance,LumenCardScene_DistantSceneDirection,LumenCardScene_DistantCardIndices,LumenCardScene_CardData,LumenCardScene_CardPageData,LumenCardScene_MeshCardsData,LumenCardScene_HeightfieldData,LumenCardScene_PageTableBuffer,LumenCardScene_SceneInstanceIndexToMeshCardsIndexBuffer,LumenCardScene_AlbedoAtlas,LumenCardScene_OpacityAtlas,LumenCardScene_NormalAtlas,LumenCardScene_EmissiveAtlas,LumenCardScene_DepthAtlas,};
#line 10 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 170 "/Engine/Private/Common.ush"
#line 172 "/Engine/Private/Common.ush"
#line 1 "CommonViewUniformBuffer.ush"
#line 12 "/Engine/Private/CommonViewUniformBuffer.ush"
float2 GetTanHalfFieldOfView()
{
	return float2(View.ClipToView[0][0], View.ClipToView[1][1]);
}

float2 GetPrevTanHalfFieldOfView()
{
	return float2(View.PrevClipToView[0][0], View.PrevClipToView[1][1]);
}



float2 GetCotanHalfFieldOfView()
{
	return float2(View.ViewToClip[0][0], View.ViewToClip[1][1]);
}



float2 GetPrevCotanHalfFieldOfView()
{
	return float2(View.PrevViewToClip[0][0], View.PrevViewToClip[1][1]);
}


uint GetPowerOfTwoModulatedFrameIndex(uint Pow2Modulus)
{

	return View.StateFrameIndex & uint(Pow2Modulus - 1);
}
#line 173 "/Engine/Private/Common.ush"



float FmodFloor(float Lhs, float Rhs)
{
	return Lhs - floor(Lhs / Rhs) * Rhs;
}

float2 FmodFloor(float2 Lhs, float2 Rhs)
{
	return Lhs - floor(Lhs / Rhs) * Rhs;
}

float3 FmodFloor(float3 Lhs, float3 Rhs)
{
	return Lhs - floor(Lhs / Rhs) * Rhs;
}

float4 FmodFloor(float4 Lhs, float4 Rhs)
{
	return Lhs - floor(Lhs / Rhs) * Rhs;
}

float VectorSum(float V) { return V; }
float VectorSum(float2 V) { return V.x + V.y; }
float VectorSum(float3 V) { return V.x + V.y + V.z; }
float VectorSum(float4 V) { return V.x + V.y + V.z + V.w; }
#line 201 "/Engine/Private/Common.ush"
#line 1 "LargeWorldCoordinates.ush"
#line 5 "/Engine/Private/LargeWorldCoordinates.ush"
struct FLWCScalar
{
	float Tile;
	float Offset;
};

struct FLWCVector2
{
	float2 Tile;
	float2 Offset;
};

struct FLWCVector3
{
	float3 Tile;
	float3 Offset;
};

struct FLWCVector4
{
	float4 Tile;
	float4 Offset;
};

struct FLWCScalarDeriv
{
	FLWCScalar Value;
	float Ddx;
	float Ddy;
};

struct FLWCVector2Deriv
{
	FLWCVector2 Value;
	float2 Ddx;
	float2 Ddy;
};

struct FLWCVector3Deriv
{
	FLWCVector3 Value;
	float3 Ddx;
	float3 Ddy;
};

struct FLWCVector4Deriv
{
	FLWCVector4 Value;
	float4 Ddx;
	float4 Ddy;
};


struct FLWCMatrix
{
	float4x4 M;
	float3 Tile;
};


struct FLWCInverseMatrix
{
	float4x4 M;
	float3 Tile;
	int Dummy;
};




float LWCGetTileOffset(FLWCScalar V) { return  ((V).Tile)  *  2097152.00f ; }
float2 LWCGetTileOffset(FLWCVector2 V) { return  ((V).Tile)  *  2097152.00f ; }
float3 LWCGetTileOffset(FLWCVector3 V) { return  ((V).Tile)  *  2097152.00f ; }
float4 LWCGetTileOffset(FLWCVector4 V) { return  ((V).Tile)  *  2097152.00f ; }
float3 LWCGetTileOffset(FLWCMatrix V) { return  ((V).Tile)  *  2097152.00f ; }
float3 LWCGetTileOffset(FLWCInverseMatrix V) { return  ((V).Tile)  *  2097152.00f ; }

float4x4 Make4x3Matrix(float4x4 M)
{

	float4x4 Result;
	Result[0] = float4(M[0].xyz, 0.0f);
	Result[1] = float4(M[1].xyz, 0.0f);
	Result[2] = float4(M[2].xyz, 0.0f);
	Result[3] = float4(M[3].xyz, 1.0f);
	return Result;
}

float4x4 MakeTranslationMatrix(float3 Offset)
{
	float4x4 Result;
	Result[0] = float4(1.0f, 0.0f, 0.0f, 0.0f);
	Result[1] = float4(0.0f, 1.0f, 0.0f, 0.0f);
	Result[2] = float4(0.0f, 0.0f, 1.0f, 0.0f);
	Result[3] = float4(Offset, 1.0f);
	return Result;
}

FLWCScalar MakeLWCScalar(float Tile, float Offset)
{
	FLWCScalar Result;
	(Result).Tile = (Tile) ;
	Result.Offset = Offset;
	return Result;
}

FLWCVector2 MakeLWCVector2(float2 Tile, float2 Offset)
{
	FLWCVector2 Result;
	(Result).Tile = (Tile) ;
	Result.Offset = Offset;
	return Result;
}

FLWCVector3 MakeLWCVector3(float3 Tile, float3 Offset)
{
	FLWCVector3 Result;
	(Result).Tile = (Tile) ;
	Result.Offset = Offset;
	return Result;
}

FLWCVector4 MakeLWCVector4(float4 Tile, float4 Offset)
{
	FLWCVector4 Result;
	(Result).Tile = (Tile) ;
	Result.Offset = Offset;
	return Result;
}

FLWCVector4 MakeLWCVector4(float3 Tile, float4 Offset)
{
	return MakeLWCVector4(float4(Tile, 0), Offset);
}

FLWCVector4 MakeLWCVector4(FLWCVector3 XYZ, float W)
{
	return MakeLWCVector4( ((XYZ).Tile) , float4(XYZ.Offset, W));
}

FLWCScalar MakeLWCVector(FLWCScalar X) { return X; }

FLWCVector2 MakeLWCVector(FLWCScalar X, FLWCScalar Y) { return MakeLWCVector2(float2( ((X).Tile) ,  ((Y).Tile) ), float2(X.Offset, Y.Offset)); }

FLWCVector3 MakeLWCVector(FLWCScalar X, FLWCScalar Y, FLWCScalar Z) { return MakeLWCVector3(float3( ((X).Tile) ,  ((Y).Tile) ,  ((Z).Tile) ), float3(X.Offset, Y.Offset, Z.Offset)); }
FLWCVector3 MakeLWCVector(FLWCScalar X, FLWCVector2 YZ) { return MakeLWCVector3(float3( ((X).Tile) ,  ((YZ).Tile) ), float3(X.Offset, YZ.Offset)); }
FLWCVector3 MakeLWCVector(FLWCVector2 XY, FLWCScalar Z) { return MakeLWCVector3(float3( ((XY).Tile) ,  ((Z).Tile) ), float3(XY.Offset, Z.Offset)); }

FLWCVector4 MakeLWCVector(FLWCScalar X, FLWCScalar Y, FLWCScalar Z, FLWCScalar W) { return MakeLWCVector4(float4( ((X).Tile) ,  ((Y).Tile) ,  ((Z).Tile) ,  ((W).Tile) ), float4(X.Offset, Y.Offset, Z.Offset, W.Offset)); }
FLWCVector4 MakeLWCVector(FLWCScalar X, FLWCScalar Y, FLWCVector2 ZW) { return MakeLWCVector4(float4( ((X).Tile) ,  ((Y).Tile) ,  ((ZW).Tile) ), float4(X.Offset, Y.Offset, ZW.Offset)); }
FLWCVector4 MakeLWCVector(FLWCScalar X, FLWCVector2 YZ, FLWCScalar W) { return MakeLWCVector4(float4( ((X).Tile) ,  ((YZ).Tile) ,  ((W).Tile) ), float4(X.Offset, YZ.Offset, W.Offset)); }
FLWCVector4 MakeLWCVector(FLWCVector2 XY, FLWCScalar Z, FLWCScalar W) { return MakeLWCVector4(float4( ((XY).Tile) ,  ((Z).Tile) ,  ((W).Tile) ), float4(XY.Offset, Z.Offset, W.Offset)); }
FLWCVector4 MakeLWCVector(FLWCVector2 XY, FLWCVector2 ZW) { return MakeLWCVector4(float4( ((XY).Tile) ,  ((ZW).Tile) ), float4(XY.Offset, ZW.Offset)); }
FLWCVector4 MakeLWCVector(FLWCScalar X, FLWCVector3 YZW) { return MakeLWCVector4(float4( ((X).Tile) ,  ((YZW).Tile) ), float4(X.Offset, YZW.Offset)); }
FLWCVector4 MakeLWCVector(FLWCVector3 XYZ, FLWCScalar W) { return MakeLWCVector4(float4( ((XYZ).Tile) ,  ((W).Tile) ), float4(XYZ.Offset, W.Offset)); }

FLWCMatrix MakeLWCMatrix(float3 Tile, float4x4 InMatrix)
{
	FLWCMatrix Result;
	(Result).Tile = (Tile) ;
	Result.M = InMatrix;
	return Result;
}

FLWCMatrix MakeLWCMatrix4x3(float3 Tile, float4x4 InMatrix)
{
	FLWCMatrix Result;
	(Result).Tile = (Tile) ;
	Result.M = Make4x3Matrix(InMatrix);
	return Result;
}

FLWCInverseMatrix MakeLWCInverseMatrix(float3 Tile, float4x4 InMatrix)
{
	FLWCInverseMatrix Result;
	(Result).Tile = (-Tile) ;
	Result.M = InMatrix;
	Result.Dummy = 0;
	return Result;
}

FLWCInverseMatrix MakeLWCInverseMatrix4x3(float3 Tile, float4x4 InMatrix)
{
	FLWCInverseMatrix Result;
	(Result).Tile = (-Tile) ;
	Result.M = Make4x3Matrix(InMatrix);
	Result.Dummy = 0;
	return Result;
}



FLWCScalar LWCGetComponent(FLWCScalar V, int C) { return V; }
FLWCScalar LWCGetComponent(FLWCVector2 V, int C) { return MakeLWCScalar( ((V).Tile) [C], V.Offset[C]); }
FLWCScalar LWCGetComponent(FLWCVector3 V, int C) { return MakeLWCScalar( ((V).Tile) [C], V.Offset[C]); }
FLWCScalar LWCGetComponent(FLWCVector4 V, int C) { return MakeLWCScalar( ((V).Tile) [C], V.Offset[C]); }






FLWCScalar LWCSwizzle(FLWCScalar V, int C0) { return V; }
FLWCScalar LWCSwizzle(FLWCVector2 V, int C0) { return LWCGetComponent(V, C0); }
FLWCScalar LWCSwizzle(FLWCVector3 V, int C0) { return LWCGetComponent(V, C0); }
FLWCScalar LWCSwizzle(FLWCVector4 V, int C0) { return LWCGetComponent(V, C0); }

FLWCVector2 LWCSwizzle(FLWCScalar V, int C0, int C1) { return MakeLWCVector(V, V); }
FLWCVector2 LWCSwizzle(FLWCVector2 V, int C0, int C1) { return MakeLWCVector(LWCGetComponent(V, C0), LWCGetComponent(V, C1)); }
FLWCVector2 LWCSwizzle(FLWCVector3 V, int C0, int C1) { return MakeLWCVector(LWCGetComponent(V, C0), LWCGetComponent(V, C1)); }
FLWCVector2 LWCSwizzle(FLWCVector4 V, int C0, int C1) { return MakeLWCVector(LWCGetComponent(V, C0), LWCGetComponent(V, C1)); }

FLWCVector3 LWCSwizzle(FLWCScalar V, int C0, int C1, int C2) { return MakeLWCVector(V, V, V); }
FLWCVector3 LWCSwizzle(FLWCVector2 V, int C0, int C1, int C2) { return MakeLWCVector(LWCGetComponent(V, C0), LWCGetComponent(V, C1), LWCGetComponent(V, C2)); }
FLWCVector3 LWCSwizzle(FLWCVector3 V, int C0, int C1, int C2) { return MakeLWCVector(LWCGetComponent(V, C0), LWCGetComponent(V, C1), LWCGetComponent(V, C2)); }
FLWCVector3 LWCSwizzle(FLWCVector4 V, int C0, int C1, int C2) { return MakeLWCVector(LWCGetComponent(V, C0), LWCGetComponent(V, C1), LWCGetComponent(V, C2)); }

FLWCVector4 LWCSwizzle(FLWCScalar V, int C0, int C1, int C2, int C3) { return MakeLWCVector(V, V, V, V); }
FLWCVector4 LWCSwizzle(FLWCVector2 V, int C0, int C1, int C2, int C3) { return MakeLWCVector(LWCGetComponent(V, C0), LWCGetComponent(V, C1), LWCGetComponent(V, C2), LWCGetComponent(V, C3)); }
FLWCVector4 LWCSwizzle(FLWCVector3 V, int C0, int C1, int C2, int C3) { return MakeLWCVector(LWCGetComponent(V, C0), LWCGetComponent(V, C1), LWCGetComponent(V, C2), LWCGetComponent(V, C3)); }
FLWCVector4 LWCSwizzle(FLWCVector4 V, int C0, int C1, int C2, int C3) { return MakeLWCVector(LWCGetComponent(V, C0), LWCGetComponent(V, C1), LWCGetComponent(V, C2), LWCGetComponent(V, C3)); }

float LWCToFloat(FLWCScalar Value) { return LWCGetTileOffset(Value) + Value.Offset; }
float2 LWCToFloat(FLWCVector2 Value) { return LWCGetTileOffset(Value) + Value.Offset; }
float3 LWCToFloat(FLWCVector3 Value) { return LWCGetTileOffset(Value) + Value.Offset; }
float4 LWCToFloat(FLWCVector4 Value) { return LWCGetTileOffset(Value) + Value.Offset; }

float4x4 LWCToFloat(FLWCMatrix Value)
{
	float4x4 Result = Value.M;
	Result[3].xyz = LWCGetTileOffset(Value) + Result[3].xyz;
	return Result;
}

float4x4 LWCToFloat(FLWCInverseMatrix Value)
{
	float4x4 TileOffset = MakeTranslationMatrix(LWCGetTileOffset(Value));
	return mul(TileOffset, Value.M);
}

float3x3 LWCToFloat3x3(FLWCMatrix Value)
{
	return (float3x3)Value.M;
}

float3x3 LWCToFloat3x3(FLWCInverseMatrix Value)
{
	return (float3x3)Value.M;
}


float LWCToFloat(float Value) { return Value; }
float2 LWCToFloat(float2 Value) { return Value; }
float3 LWCToFloat(float3 Value) { return Value; }
float4 LWCToFloat(float4 Value) { return Value; }
float4x4 LWCToFloat(float4x4 Value) { return Value; }


FLWCScalar LWCPromote(FLWCScalar Value) { return Value; }
FLWCVector2 LWCPromote(FLWCVector2 Value) { return Value; }
FLWCVector3 LWCPromote(FLWCVector3 Value) { return Value; }
FLWCVector4 LWCPromote(FLWCVector4 Value) { return Value; }
FLWCMatrix LWCPromote(FLWCMatrix Value) { return Value; }
FLWCInverseMatrix LWCPromote(FLWCInverseMatrix Value) { return Value; }

FLWCScalar LWCPromote(float Value) { return MakeLWCScalar(0, Value); }
FLWCVector2 LWCPromote(float2 Value) { return MakeLWCVector2((float2)0, Value); }
FLWCVector3 LWCPromote(float3 Value) { return MakeLWCVector3((float3)0, Value); }
FLWCVector4 LWCPromote(float4 Value) { return MakeLWCVector4((float4)0, Value); }
FLWCMatrix LWCPromote(float4x4 Value) { return MakeLWCMatrix((float3)0, Value); }
FLWCInverseMatrix LWCPromoteInverse(float4x4 Value) { return MakeLWCInverseMatrix((float3)0, Value); }

FLWCVector3 LWCMultiply(float3 Position, FLWCMatrix InMatrix)
{

	float3 Offset = (Position.xxx * InMatrix.M[0].xyz + Position.yyy * InMatrix.M[1].xyz + Position.zzz * InMatrix.M[2].xyz) + InMatrix.M[3].xyz;
	return MakeLWCVector3( ((InMatrix).Tile) , Offset);
}

FLWCVector4 LWCMultiply(float4 Position, FLWCMatrix InMatrix)
{
	float4 Offset = mul(Position, InMatrix.M);
	return MakeLWCVector4( ((InMatrix).Tile) , Offset);
}

float3 LWCMultiply(FLWCVector3 Position, FLWCInverseMatrix InMatrix)
{
	float3 LocalPosition = LWCToFloat(MakeLWCVector3( ((Position).Tile)  +  ((InMatrix).Tile) , Position.Offset));
	return (LocalPosition.xxx * InMatrix.M[0].xyz + LocalPosition.yyy * InMatrix.M[1].xyz + LocalPosition.zzz * InMatrix.M[2].xyz) + InMatrix.M[3].xyz;
}

float4 LWCMultiply(FLWCVector4 Position, FLWCInverseMatrix InMatrix)
{
	float4 LocalPosition = LWCToFloat(MakeLWCVector4( ((Position).Tile)  + float4( ((InMatrix).Tile) , 0), Position.Offset));
	return mul(LocalPosition, InMatrix.M);
}

float3 LWCMultiplyVector(float3 Vector, FLWCMatrix InMatrix)
{
	return mul(Vector, (float3x3)InMatrix.M);
}

float3 LWCMultiplyVector(float3 Vector, FLWCInverseMatrix InMatrix)
{
	return mul(Vector, (float3x3)InMatrix.M);
}

FLWCMatrix LWCMultiply(float4x4 Lhs, FLWCMatrix Rhs)
{
	float4x4 ResultMatrix = mul(Lhs, Rhs.M);
	return MakeLWCMatrix( ((Rhs).Tile) , ResultMatrix);
}

FLWCInverseMatrix LWCMultiply(FLWCInverseMatrix Lhs, float4x4 Rhs)
{
	float4x4 ResultMatrix = mul(Lhs.M, Rhs);
	return MakeLWCInverseMatrix(- ((Lhs).Tile) , ResultMatrix);
}

float4x4 LWCMultiply(FLWCMatrix Lhs, FLWCInverseMatrix Rhs)
{

	float4x4 Result = Lhs.M;
	Result = mul(Result, MakeTranslationMatrix(( ((Lhs).Tile)  +  ((Rhs).Tile) ) *  2097152.00f ));
	Result = mul(Result, Rhs.M);
	return Result;
}

float4x4 LWCMultiplyTranslation(FLWCMatrix Lhs, FLWCVector3 Rhs)
{
	float4x4 Result = Lhs.M;
	Result[3].xyz += ( ((Lhs).Tile)  +  ((Rhs).Tile) ) *  2097152.00f ;
	Result[3].xyz += Rhs.Offset;
	return Result;
}

FLWCMatrix LWCMultiplyTranslation(float4x4 Lhs, FLWCVector3 Rhs)
{
	FLWCMatrix Result = MakeLWCMatrix( ((Rhs).Tile) , Lhs);
	Result.M[3].xyz += Rhs.Offset;
	return Result;
}

float4x4 LWCMultiplyTranslation(FLWCVector3 Lhs, FLWCInverseMatrix Rhs)
{
	float3 Offset = ( ((Lhs).Tile)  +  ((Rhs).Tile) ) *  2097152.00f  + Lhs.Offset;
	return mul(MakeTranslationMatrix(Offset), Rhs.M);
}

FLWCInverseMatrix LWCMultiplyTranslation(FLWCVector3 Lhs, float4x4 Rhs)
{
	FLWCInverseMatrix Result = MakeLWCInverseMatrix(- ((Lhs).Tile) , Rhs);
	Result.M = mul(MakeTranslationMatrix(Lhs.Offset), Result.M);
	return Result;
}

FLWCVector3 LWCGetOrigin(FLWCMatrix InMatrix)
{
	return MakeLWCVector3( ((InMatrix).Tile) , InMatrix.M[3].xyz);
}

void LWCSetOrigin(inout FLWCMatrix InOutMatrix, FLWCVector3 Origin)
{
	(InOutMatrix).Tile = ( ((Origin).Tile) ) ;
	InOutMatrix.M[3].xyz = Origin.Offset;
}
#line 376 "/Engine/Private/LargeWorldCoordinates.ush"
#line 1 "LWCOperations.ush"




FLWCScalar  LWCNormalizeTile( FLWCScalar  V)
{
	float  IntTile = floor(V.Tile + (V.Offset *  4.76837158e-07f  + 0.5f));
	return  MakeLWCScalar (IntTile, (V.Tile - IntTile) *  2097152.00f  + V.Offset);
}


FLWCScalar  LWCMakeIntTile( FLWCScalar  V)
{
	float  IntTile = floor(V.Tile);
	return  MakeLWCScalar (IntTile, (V.Tile - IntTile) *  2097152.00f  + V.Offset);
}

float  LWCSqrtUnscaled( FLWCScalar  V) { return sqrt(V.Offset *  4.76837158e-07f  +  ((V).Tile) ); }
float  LWCRsqrtUnscaled( FLWCScalar  V) { return rsqrt(V.Offset *  4.76837158e-07f  +  ((V).Tile) ); }
float  LWCRcpUnscaled( FLWCScalar  V) { return rcp(V.Offset *  4.76837158e-07f  +  ((V).Tile) ); }
float  LWCSqrtScaled( FLWCScalar  V, float Scale) { return LWCSqrtUnscaled(V) * Scale; }
float  LWCRsqrtScaled( FLWCScalar  V, float Scale) { return LWCRsqrtUnscaled(V) * Scale; }
float  LWCRcpScaled( FLWCScalar  V, float Scale) { return LWCRcpUnscaled(V) * Scale; }
float  LWCSqrt( FLWCScalar  V) { return LWCSqrtScaled(V,  1448.15466f ); }
float  LWCRsqrt( FLWCScalar  V) { return LWCRsqrtScaled(V,  0.000690533954f ); }
float  LWCRcp( FLWCScalar  V) { return LWCRcpScaled(V,  4.76837158e-07f ); }
#line 36 "/Engine/Private/LWCOperations.ush"
bool LWCGreater( FLWCScalar Lhs, FLWCScalar Rhs) { return ( ((Lhs).Tile) - ((Rhs).Tile) ) * 2097152.00f > Rhs.Offset - Lhs.Offset; } bool LWCGreater( float Lhs, FLWCScalar Rhs) { return - ((Rhs).Tile) * 2097152.00f > Rhs.Offset - Lhs; } bool LWCGreater( FLWCScalar Lhs, float Rhs) { return ((Lhs).Tile) * 2097152.00f > Rhs - Lhs.Offset; }
bool LWCGreaterEqual( FLWCScalar Lhs, FLWCScalar Rhs) { return ( ((Lhs).Tile) - ((Rhs).Tile) ) * 2097152.00f >= Rhs.Offset - Lhs.Offset; } bool LWCGreaterEqual( float Lhs, FLWCScalar Rhs) { return - ((Rhs).Tile) * 2097152.00f >= Rhs.Offset - Lhs; } bool LWCGreaterEqual( FLWCScalar Lhs, float Rhs) { return ((Lhs).Tile) * 2097152.00f >= Rhs - Lhs.Offset; }
bool LWCLess( FLWCScalar Lhs, FLWCScalar Rhs) { return ( ((Lhs).Tile) - ((Rhs).Tile) ) * 2097152.00f < Rhs.Offset - Lhs.Offset; } bool LWCLess( float Lhs, FLWCScalar Rhs) { return - ((Rhs).Tile) * 2097152.00f < Rhs.Offset - Lhs; } bool LWCLess( FLWCScalar Lhs, float Rhs) { return ((Lhs).Tile) * 2097152.00f < Rhs - Lhs.Offset; }
bool LWCLessEqual( FLWCScalar Lhs, FLWCScalar Rhs) { return ( ((Lhs).Tile) - ((Rhs).Tile) ) * 2097152.00f <= Rhs.Offset - Lhs.Offset; } bool LWCLessEqual( float Lhs, FLWCScalar Rhs) { return - ((Rhs).Tile) * 2097152.00f <= Rhs.Offset - Lhs; } bool LWCLessEqual( FLWCScalar Lhs, float Rhs) { return ((Lhs).Tile) * 2097152.00f <= Rhs - Lhs.Offset; }





float  LWCDdx( FLWCScalar  V) { return ( float )0; }
float  LWCDdy( FLWCScalar  V) { return ( float )0; }
#line 52 "/Engine/Private/LWCOperations.ush"
FLWCScalar  LWCAdd( FLWCScalar  Lhs,  FLWCScalar  Rhs) { return  MakeLWCScalar ( ((Lhs).Tile)  +  ((Rhs).Tile) , Lhs.Offset + Rhs.Offset); }
FLWCScalar  LWCAdd( float  Lhs,  FLWCScalar  Rhs) { return  MakeLWCScalar ( ((Rhs).Tile) , Lhs + Rhs.Offset); }
FLWCScalar  LWCAdd( FLWCScalar  Lhs,  float  Rhs) { return  MakeLWCScalar ( ((Lhs).Tile) , Lhs.Offset + Rhs); }

FLWCScalar  LWCSubtract( FLWCScalar  Lhs,  FLWCScalar  Rhs) { return  MakeLWCScalar ( ((Lhs).Tile)  -  ((Rhs).Tile) , Lhs.Offset - Rhs.Offset); }
FLWCScalar  LWCSubtract( float  Lhs,  FLWCScalar  Rhs) { return  MakeLWCScalar (- ((Rhs).Tile) , Lhs - Rhs.Offset); }
FLWCScalar  LWCSubtract( FLWCScalar  Lhs,  float  Rhs) { return  MakeLWCScalar ( ((Lhs).Tile) , Lhs.Offset - Rhs); }

bool  LWCEquals( FLWCScalar  Lhs,  FLWCScalar  Rhs)
{
	return ( ((Lhs).Tile)  -  ((Rhs).Tile) ) *  2097152.00f  == Rhs.Offset - Lhs.Offset;
}
bool  LWCEquals( float  Lhs,  FLWCScalar  Rhs)
{
	return - ((Rhs).Tile)  *  2097152.00f  == Rhs.Offset - Lhs;
}
bool  LWCEquals( FLWCScalar  Lhs,  float  Rhs)
{
	return  ((Lhs).Tile)  *  2097152.00f  == Rhs - Lhs.Offset;
}
bool  LWCEqualsApprox( FLWCScalar  Lhs,  FLWCScalar  Rhs, float Threshold)
{
	return abs(( ((Lhs).Tile)  -  ((Rhs).Tile) ) *  2097152.00f  + (Lhs.Offset - Rhs.Offset)) < ( float )Threshold;
}
bool  LWCEqualsApprox( float  Lhs,  FLWCScalar  Rhs, float Threshold)
{
	return abs(- ((Rhs).Tile)  *  2097152.00f  + (Lhs - Rhs.Offset)) < ( float )Threshold;
}
bool  LWCEqualsApprox( FLWCScalar  Lhs,  float  Rhs, float Threshold)
{
	return abs( ((Lhs).Tile)  *  2097152.00f  + (Lhs.Offset - Rhs)) < ( float )Threshold;
}

FLWCScalar  LWCSelect( bool  S,  FLWCScalar  Lhs,  FLWCScalar  Rhs) { return  MakeLWCScalar ( select_internal(S, ((Lhs).Tile) , ((Rhs).Tile) ) ,  select_internal(S,Lhs.Offset,Rhs.Offset) ); }
FLWCScalar  LWCSelect( bool  S,  float  Lhs,  FLWCScalar  Rhs) { return  MakeLWCScalar ( select_internal(S,( float )0, ((Rhs).Tile) ) ,  select_internal(S,Lhs,Rhs.Offset) ); }
FLWCScalar  LWCSelect( bool  S,  FLWCScalar  Lhs,  float  Rhs) { return  MakeLWCScalar ( select_internal(S, ((Lhs).Tile) ,( float )0) ,  select_internal(S,Lhs.Offset,Rhs) ); }

FLWCScalar  LWCNegate( FLWCScalar  V) { return  MakeLWCScalar (- ((V).Tile) , -V.Offset); }

float  LWCFrac( FLWCScalar  V)
{
	float  FracTile = frac( ((V).Tile)  *  2097152.00f );
	return frac(FracTile + V.Offset);
}

FLWCScalar  LWCFloor( FLWCScalar  V) {  FLWCScalar  VN = LWCMakeIntTile(V); return  MakeLWCScalar ( ((VN).Tile) , floor(VN.Offset)); }
FLWCScalar  LWCCeil( FLWCScalar  V) {  FLWCScalar  VN = LWCMakeIntTile(V); return  MakeLWCScalar ( ((VN).Tile) , ceil(VN.Offset)); }
FLWCScalar  LWCRound( FLWCScalar  V) {  FLWCScalar  VN = LWCMakeIntTile(V); return  MakeLWCScalar ( ((VN).Tile) , round(VN.Offset)); }
FLWCScalar  LWCTrunc( FLWCScalar  V) {  FLWCScalar  VN = LWCMakeIntTile(V); return  MakeLWCScalar ( ((VN).Tile) , trunc(VN.Offset)); }


float  LWCSign( FLWCScalar  V) { return  float (sign(LWCToFloat(V))); }
float  LWCSaturate( FLWCScalar  V) { return saturate(LWCToFloat(V)); }
float  LWCClampScalar( FLWCScalar  V, float Low, float High) { return clamp(LWCToFloat(V), Low, High); }

FLWCScalar  LWCMultiply( FLWCScalar  Lhs,  FLWCScalar  Rhs)
{
	return  MakeLWCScalar ( ((Lhs).Tile)  * ( ((Rhs).Tile)  *  2097152.00f  + Rhs.Offset) +  ((Rhs).Tile)  * Lhs.Offset, Lhs.Offset * Rhs.Offset);
}
FLWCScalar  LWCMultiply( float  Lhs,  FLWCScalar  Rhs) { return  MakeLWCScalar ( ((Rhs).Tile)  * Lhs, Lhs * Rhs.Offset); }
FLWCScalar  LWCMultiply( FLWCScalar  Lhs,  float  Rhs) { return  MakeLWCScalar ( ((Lhs).Tile)  * Rhs, Lhs.Offset * Rhs); }

FLWCScalar  LWCDivide( FLWCScalar  Lhs,  FLWCScalar  Rhs) { return LWCMultiply(Lhs, LWCRcp(Rhs)); }
FLWCScalar  LWCDivide( FLWCScalar  Lhs,  float  Rhs) { return LWCMultiply(Lhs, rcp(Rhs)); }
FLWCScalar  LWCDivide( float  Lhs,  FLWCScalar  Rhs) { return  MakeLWCScalar (( float )0, Lhs * LWCRcp(Rhs)); }


FLWCScalar  LWCLerp( FLWCScalar  Lhs,  FLWCScalar  Rhs,  float  S)
{
	return  MakeLWCScalar (lerp( ((Lhs).Tile) ,  ((Rhs).Tile) , S), lerp(Lhs.Offset, Rhs.Offset, S));
}

float  LWCFmod( FLWCScalar  Lhs,  float  Rhs)
{
	return LWCToFloat(LWCSubtract(Lhs, LWCMultiply(LWCTrunc(LWCDivide(Lhs, Rhs)), Rhs)));


}
float  LWCFmodFloor( FLWCScalar  Lhs,  float  Rhs)
{
	return LWCToFloat(LWCSubtract(Lhs, LWCMultiply(LWCFloor(LWCDivide(Lhs, Rhs)), Rhs)));


}
float  LWCFmodFloorPI( FLWCScalar  V)
{
	return LWCFmodFloor(V, PI);

}
float  LWCFmodFloor2PI( FLWCScalar  V)
{
	return LWCFmodFloor(V, 2.0f * PI);

}

float  LWCSin( FLWCScalar  V) { return sin(LWCFmodFloor2PI(V)); }
float  LWCCos( FLWCScalar  V) { return cos(LWCFmodFloor2PI(V)); }
float  LWCTan( FLWCScalar  V) { return tan(LWCFmodFloorPI(V)); }
float  LWCASin( FLWCScalar  V) { return asin(LWCClampScalar(V, -1.0f, 1.0f)); }
float  LWCACos( FLWCScalar  V) { return acos(LWCClampScalar(V, -1.0f, 1.0f)); }
float  LWCATan( FLWCScalar  V) { return atan(LWCClampScalar(V, -0.5f*PI, 0.5f*PI)); }

float  LWCSmoothStep( FLWCScalar  Lhs,  FLWCScalar  Rhs,  FLWCScalar  S)
{
	float  t = LWCSaturate(LWCDivide(LWCSubtract(S, Lhs), LWCSubtract(Rhs, Lhs)));
	return t*t*(3.0f - (2.0f*t));
}

FLWCScalar  LWCMin( FLWCScalar  Lhs,  FLWCScalar  Rhs) { return LWCSelect(LWCLess(Lhs, Rhs), Lhs, Rhs); }
FLWCScalar  LWCMin( float  Lhs,  FLWCScalar  Rhs) { return LWCSelect(LWCLess(Lhs, Rhs), Lhs, Rhs); }
FLWCScalar  LWCMin( FLWCScalar  Lhs,  float  Rhs) { return LWCSelect(LWCLess(Lhs, Rhs), Lhs, Rhs); }
FLWCScalar  LWCMax( FLWCScalar  Lhs,  FLWCScalar  Rhs) { return LWCSelect(LWCGreater(Lhs, Rhs), Lhs, Rhs); }
FLWCScalar  LWCMax( float  Lhs,  FLWCScalar  Rhs) { return LWCSelect(LWCGreater(Lhs, Rhs), Lhs, Rhs); }
FLWCScalar  LWCMax( FLWCScalar  Lhs,  float  Rhs) { return LWCSelect(LWCGreater(Lhs, Rhs), Lhs, Rhs); }

FLWCScalar  LWCAbs( FLWCScalar  V) { return LWCSelect(LWCLess(V, ( float )0), LWCNegate(V), V); }

float  LWCStep( FLWCScalar  Lhs,  FLWCScalar  Rhs) { return  select_internal(LWCGreaterEqual(Rhs, Lhs),( float )1.0f,( float )0.0f) ; }
float  LWCStep( FLWCScalar  Lhs,  float  Rhs) { return  select_internal(LWCGreaterEqual(Rhs, Lhs),( float )1.0f,( float )0.0f) ; }
float  LWCStep( float  Lhs,  FLWCScalar  Rhs) { return  select_internal(LWCGreaterEqual(Rhs, Lhs),( float )1.0f,( float )0.0f) ; }


FLWCScalar  LWCSquareScaled( FLWCScalar  V)
{
	float  OffsetScaled = V.Offset *  4.76837158e-07f ;
	return  MakeLWCScalar ( ((V).Tile)  * ( ((V).Tile)  + OffsetScaled * 2.0f), V.Offset * OffsetScaled);
}
#line 377 "/Engine/Private/LargeWorldCoordinates.ush"
#line 386 "/Engine/Private/LargeWorldCoordinates.ush"
#line 1 "LWCOperations.ush"




FLWCVector2  LWCNormalizeTile( FLWCVector2  V)
{
	float2  IntTile = floor(V.Tile + (V.Offset *  4.76837158e-07f  + 0.5f));
	return  MakeLWCVector2 (IntTile, (V.Tile - IntTile) *  2097152.00f  + V.Offset);
}


FLWCVector2  LWCMakeIntTile( FLWCVector2  V)
{
	float2  IntTile = floor(V.Tile);
	return  MakeLWCVector2 (IntTile, (V.Tile - IntTile) *  2097152.00f  + V.Offset);
}

float2  LWCSqrtUnscaled( FLWCVector2  V) { return sqrt(V.Offset *  4.76837158e-07f  +  ((V).Tile) ); }
float2  LWCRsqrtUnscaled( FLWCVector2  V) { return rsqrt(V.Offset *  4.76837158e-07f  +  ((V).Tile) ); }
float2  LWCRcpUnscaled( FLWCVector2  V) { return rcp(V.Offset *  4.76837158e-07f  +  ((V).Tile) ); }
float2  LWCSqrtScaled( FLWCVector2  V, float Scale) { return LWCSqrtUnscaled(V) * Scale; }
float2  LWCRsqrtScaled( FLWCVector2  V, float Scale) { return LWCRsqrtUnscaled(V) * Scale; }
float2  LWCRcpScaled( FLWCVector2  V, float Scale) { return LWCRcpUnscaled(V) * Scale; }
float2  LWCSqrt( FLWCVector2  V) { return LWCSqrtScaled(V,  1448.15466f ); }
float2  LWCRsqrt( FLWCVector2  V) { return LWCRsqrtScaled(V,  0.000690533954f ); }
float2  LWCRcp( FLWCVector2  V) { return LWCRcpScaled(V,  4.76837158e-07f ); }
#line 36 "/Engine/Private/LWCOperations.ush"
bool2 LWCGreater( FLWCVector2 Lhs, FLWCVector2 Rhs) { return ( ((Lhs).Tile) - ((Rhs).Tile) ) * 2097152.00f > Rhs.Offset - Lhs.Offset; } bool2 LWCGreater( float2 Lhs, FLWCVector2 Rhs) { return - ((Rhs).Tile) * 2097152.00f > Rhs.Offset - Lhs; } bool2 LWCGreater( FLWCVector2 Lhs, float2 Rhs) { return ((Lhs).Tile) * 2097152.00f > Rhs - Lhs.Offset; }
bool2 LWCGreaterEqual( FLWCVector2 Lhs, FLWCVector2 Rhs) { return ( ((Lhs).Tile) - ((Rhs).Tile) ) * 2097152.00f >= Rhs.Offset - Lhs.Offset; } bool2 LWCGreaterEqual( float2 Lhs, FLWCVector2 Rhs) { return - ((Rhs).Tile) * 2097152.00f >= Rhs.Offset - Lhs; } bool2 LWCGreaterEqual( FLWCVector2 Lhs, float2 Rhs) { return ((Lhs).Tile) * 2097152.00f >= Rhs - Lhs.Offset; }
bool2 LWCLess( FLWCVector2 Lhs, FLWCVector2 Rhs) { return ( ((Lhs).Tile) - ((Rhs).Tile) ) * 2097152.00f < Rhs.Offset - Lhs.Offset; } bool2 LWCLess( float2 Lhs, FLWCVector2 Rhs) { return - ((Rhs).Tile) * 2097152.00f < Rhs.Offset - Lhs; } bool2 LWCLess( FLWCVector2 Lhs, float2 Rhs) { return ((Lhs).Tile) * 2097152.00f < Rhs - Lhs.Offset; }
bool2 LWCLessEqual( FLWCVector2 Lhs, FLWCVector2 Rhs) { return ( ((Lhs).Tile) - ((Rhs).Tile) ) * 2097152.00f <= Rhs.Offset - Lhs.Offset; } bool2 LWCLessEqual( float2 Lhs, FLWCVector2 Rhs) { return - ((Rhs).Tile) * 2097152.00f <= Rhs.Offset - Lhs; } bool2 LWCLessEqual( FLWCVector2 Lhs, float2 Rhs) { return ((Lhs).Tile) * 2097152.00f <= Rhs - Lhs.Offset; }





float2  LWCDdx( FLWCVector2  V) { return ( float2 )0; }
float2  LWCDdy( FLWCVector2  V) { return ( float2 )0; }
#line 52 "/Engine/Private/LWCOperations.ush"
FLWCVector2  LWCAdd( FLWCVector2  Lhs,  FLWCVector2  Rhs) { return  MakeLWCVector2 ( ((Lhs).Tile)  +  ((Rhs).Tile) , Lhs.Offset + Rhs.Offset); }
FLWCVector2  LWCAdd( float2  Lhs,  FLWCVector2  Rhs) { return  MakeLWCVector2 ( ((Rhs).Tile) , Lhs + Rhs.Offset); }
FLWCVector2  LWCAdd( FLWCVector2  Lhs,  float2  Rhs) { return  MakeLWCVector2 ( ((Lhs).Tile) , Lhs.Offset + Rhs); }

FLWCVector2  LWCSubtract( FLWCVector2  Lhs,  FLWCVector2  Rhs) { return  MakeLWCVector2 ( ((Lhs).Tile)  -  ((Rhs).Tile) , Lhs.Offset - Rhs.Offset); }
FLWCVector2  LWCSubtract( float2  Lhs,  FLWCVector2  Rhs) { return  MakeLWCVector2 (- ((Rhs).Tile) , Lhs - Rhs.Offset); }
FLWCVector2  LWCSubtract( FLWCVector2  Lhs,  float2  Rhs) { return  MakeLWCVector2 ( ((Lhs).Tile) , Lhs.Offset - Rhs); }

bool2  LWCEquals( FLWCVector2  Lhs,  FLWCVector2  Rhs)
{
	return ( ((Lhs).Tile)  -  ((Rhs).Tile) ) *  2097152.00f  == Rhs.Offset - Lhs.Offset;
}
bool2  LWCEquals( float2  Lhs,  FLWCVector2  Rhs)
{
	return - ((Rhs).Tile)  *  2097152.00f  == Rhs.Offset - Lhs;
}
bool2  LWCEquals( FLWCVector2  Lhs,  float2  Rhs)
{
	return  ((Lhs).Tile)  *  2097152.00f  == Rhs - Lhs.Offset;
}
bool2  LWCEqualsApprox( FLWCVector2  Lhs,  FLWCVector2  Rhs, float Threshold)
{
	return abs(( ((Lhs).Tile)  -  ((Rhs).Tile) ) *  2097152.00f  + (Lhs.Offset - Rhs.Offset)) < ( float2 )Threshold;
}
bool2  LWCEqualsApprox( float2  Lhs,  FLWCVector2  Rhs, float Threshold)
{
	return abs(- ((Rhs).Tile)  *  2097152.00f  + (Lhs - Rhs.Offset)) < ( float2 )Threshold;
}
bool2  LWCEqualsApprox( FLWCVector2  Lhs,  float2  Rhs, float Threshold)
{
	return abs( ((Lhs).Tile)  *  2097152.00f  + (Lhs.Offset - Rhs)) < ( float2 )Threshold;
}

FLWCVector2  LWCSelect( bool2  S,  FLWCVector2  Lhs,  FLWCVector2  Rhs) { return  MakeLWCVector2 ( select_internal(S, ((Lhs).Tile) , ((Rhs).Tile) ) ,  select_internal(S,Lhs.Offset,Rhs.Offset) ); }
FLWCVector2  LWCSelect( bool2  S,  float2  Lhs,  FLWCVector2  Rhs) { return  MakeLWCVector2 ( select_internal(S,( float2 )0, ((Rhs).Tile) ) ,  select_internal(S,Lhs,Rhs.Offset) ); }
FLWCVector2  LWCSelect( bool2  S,  FLWCVector2  Lhs,  float2  Rhs) { return  MakeLWCVector2 ( select_internal(S, ((Lhs).Tile) ,( float2 )0) ,  select_internal(S,Lhs.Offset,Rhs) ); }

FLWCVector2  LWCNegate( FLWCVector2  V) { return  MakeLWCVector2 (- ((V).Tile) , -V.Offset); }

float2  LWCFrac( FLWCVector2  V)
{
	float2  FracTile = frac( ((V).Tile)  *  2097152.00f );
	return frac(FracTile + V.Offset);
}

FLWCVector2  LWCFloor( FLWCVector2  V) {  FLWCVector2  VN = LWCMakeIntTile(V); return  MakeLWCVector2 ( ((VN).Tile) , floor(VN.Offset)); }
FLWCVector2  LWCCeil( FLWCVector2  V) {  FLWCVector2  VN = LWCMakeIntTile(V); return  MakeLWCVector2 ( ((VN).Tile) , ceil(VN.Offset)); }
FLWCVector2  LWCRound( FLWCVector2  V) {  FLWCVector2  VN = LWCMakeIntTile(V); return  MakeLWCVector2 ( ((VN).Tile) , round(VN.Offset)); }
FLWCVector2  LWCTrunc( FLWCVector2  V) {  FLWCVector2  VN = LWCMakeIntTile(V); return  MakeLWCVector2 ( ((VN).Tile) , trunc(VN.Offset)); }


float2  LWCSign( FLWCVector2  V) { return  float2 (sign(LWCToFloat(V))); }
float2  LWCSaturate( FLWCVector2  V) { return saturate(LWCToFloat(V)); }
float2  LWCClampScalar( FLWCVector2  V, float Low, float High) { return clamp(LWCToFloat(V), Low, High); }

FLWCVector2  LWCMultiply( FLWCVector2  Lhs,  FLWCVector2  Rhs)
{
	return  MakeLWCVector2 ( ((Lhs).Tile)  * ( ((Rhs).Tile)  *  2097152.00f  + Rhs.Offset) +  ((Rhs).Tile)  * Lhs.Offset, Lhs.Offset * Rhs.Offset);
}
FLWCVector2  LWCMultiply( float2  Lhs,  FLWCVector2  Rhs) { return  MakeLWCVector2 ( ((Rhs).Tile)  * Lhs, Lhs * Rhs.Offset); }
FLWCVector2  LWCMultiply( FLWCVector2  Lhs,  float2  Rhs) { return  MakeLWCVector2 ( ((Lhs).Tile)  * Rhs, Lhs.Offset * Rhs); }

FLWCVector2  LWCDivide( FLWCVector2  Lhs,  FLWCVector2  Rhs) { return LWCMultiply(Lhs, LWCRcp(Rhs)); }
FLWCVector2  LWCDivide( FLWCVector2  Lhs,  float2  Rhs) { return LWCMultiply(Lhs, rcp(Rhs)); }
FLWCVector2  LWCDivide( float2  Lhs,  FLWCVector2  Rhs) { return  MakeLWCVector2 (( float2 )0, Lhs * LWCRcp(Rhs)); }


FLWCVector2  LWCLerp( FLWCVector2  Lhs,  FLWCVector2  Rhs,  float2  S)
{
	return  MakeLWCVector2 (lerp( ((Lhs).Tile) ,  ((Rhs).Tile) , S), lerp(Lhs.Offset, Rhs.Offset, S));
}

float2  LWCFmod( FLWCVector2  Lhs,  float2  Rhs)
{
	return LWCToFloat(LWCSubtract(Lhs, LWCMultiply(LWCTrunc(LWCDivide(Lhs, Rhs)), Rhs)));


}
float2  LWCFmodFloor( FLWCVector2  Lhs,  float2  Rhs)
{
	return LWCToFloat(LWCSubtract(Lhs, LWCMultiply(LWCFloor(LWCDivide(Lhs, Rhs)), Rhs)));


}
float2  LWCFmodFloorPI( FLWCVector2  V)
{
	return LWCFmodFloor(V, PI);

}
float2  LWCFmodFloor2PI( FLWCVector2  V)
{
	return LWCFmodFloor(V, 2.0f * PI);

}

float2  LWCSin( FLWCVector2  V) { return sin(LWCFmodFloor2PI(V)); }
float2  LWCCos( FLWCVector2  V) { return cos(LWCFmodFloor2PI(V)); }
float2  LWCTan( FLWCVector2  V) { return tan(LWCFmodFloorPI(V)); }
float2  LWCASin( FLWCVector2  V) { return asin(LWCClampScalar(V, -1.0f, 1.0f)); }
float2  LWCACos( FLWCVector2  V) { return acos(LWCClampScalar(V, -1.0f, 1.0f)); }
float2  LWCATan( FLWCVector2  V) { return atan(LWCClampScalar(V, -0.5f*PI, 0.5f*PI)); }

float2  LWCSmoothStep( FLWCVector2  Lhs,  FLWCVector2  Rhs,  FLWCVector2  S)
{
	float2  t = LWCSaturate(LWCDivide(LWCSubtract(S, Lhs), LWCSubtract(Rhs, Lhs)));
	return t*t*(3.0f - (2.0f*t));
}

FLWCVector2  LWCMin( FLWCVector2  Lhs,  FLWCVector2  Rhs) { return LWCSelect(LWCLess(Lhs, Rhs), Lhs, Rhs); }
FLWCVector2  LWCMin( float2  Lhs,  FLWCVector2  Rhs) { return LWCSelect(LWCLess(Lhs, Rhs), Lhs, Rhs); }
FLWCVector2  LWCMin( FLWCVector2  Lhs,  float2  Rhs) { return LWCSelect(LWCLess(Lhs, Rhs), Lhs, Rhs); }
FLWCVector2  LWCMax( FLWCVector2  Lhs,  FLWCVector2  Rhs) { return LWCSelect(LWCGreater(Lhs, Rhs), Lhs, Rhs); }
FLWCVector2  LWCMax( float2  Lhs,  FLWCVector2  Rhs) { return LWCSelect(LWCGreater(Lhs, Rhs), Lhs, Rhs); }
FLWCVector2  LWCMax( FLWCVector2  Lhs,  float2  Rhs) { return LWCSelect(LWCGreater(Lhs, Rhs), Lhs, Rhs); }

FLWCVector2  LWCAbs( FLWCVector2  V) { return LWCSelect(LWCLess(V, ( float2 )0), LWCNegate(V), V); }

float2  LWCStep( FLWCVector2  Lhs,  FLWCVector2  Rhs) { return  select_internal(LWCGreaterEqual(Rhs, Lhs),( float2 )1.0f,( float2 )0.0f) ; }
float2  LWCStep( FLWCVector2  Lhs,  float2  Rhs) { return  select_internal(LWCGreaterEqual(Rhs, Lhs),( float2 )1.0f,( float2 )0.0f) ; }
float2  LWCStep( float2  Lhs,  FLWCVector2  Rhs) { return  select_internal(LWCGreaterEqual(Rhs, Lhs),( float2 )1.0f,( float2 )0.0f) ; }


FLWCVector2  LWCSquareScaled( FLWCVector2  V)
{
	float2  OffsetScaled = V.Offset *  4.76837158e-07f ;
	return  MakeLWCVector2 ( ((V).Tile)  * ( ((V).Tile)  + OffsetScaled * 2.0f), V.Offset * OffsetScaled);
}
#line 387 "/Engine/Private/LargeWorldCoordinates.ush"
#line 396 "/Engine/Private/LargeWorldCoordinates.ush"
#line 1 "LWCOperations.ush"




FLWCVector3  LWCNormalizeTile( FLWCVector3  V)
{
	float3  IntTile = floor(V.Tile + (V.Offset *  4.76837158e-07f  + 0.5f));
	return  MakeLWCVector3 (IntTile, (V.Tile - IntTile) *  2097152.00f  + V.Offset);
}


FLWCVector3  LWCMakeIntTile( FLWCVector3  V)
{
	float3  IntTile = floor(V.Tile);
	return  MakeLWCVector3 (IntTile, (V.Tile - IntTile) *  2097152.00f  + V.Offset);
}

float3  LWCSqrtUnscaled( FLWCVector3  V) { return sqrt(V.Offset *  4.76837158e-07f  +  ((V).Tile) ); }
float3  LWCRsqrtUnscaled( FLWCVector3  V) { return rsqrt(V.Offset *  4.76837158e-07f  +  ((V).Tile) ); }
float3  LWCRcpUnscaled( FLWCVector3  V) { return rcp(V.Offset *  4.76837158e-07f  +  ((V).Tile) ); }
float3  LWCSqrtScaled( FLWCVector3  V, float Scale) { return LWCSqrtUnscaled(V) * Scale; }
float3  LWCRsqrtScaled( FLWCVector3  V, float Scale) { return LWCRsqrtUnscaled(V) * Scale; }
float3  LWCRcpScaled( FLWCVector3  V, float Scale) { return LWCRcpUnscaled(V) * Scale; }
float3  LWCSqrt( FLWCVector3  V) { return LWCSqrtScaled(V,  1448.15466f ); }
float3  LWCRsqrt( FLWCVector3  V) { return LWCRsqrtScaled(V,  0.000690533954f ); }
float3  LWCRcp( FLWCVector3  V) { return LWCRcpScaled(V,  4.76837158e-07f ); }
#line 36 "/Engine/Private/LWCOperations.ush"
bool3 LWCGreater( FLWCVector3 Lhs, FLWCVector3 Rhs) { return ( ((Lhs).Tile) - ((Rhs).Tile) ) * 2097152.00f > Rhs.Offset - Lhs.Offset; } bool3 LWCGreater( float3 Lhs, FLWCVector3 Rhs) { return - ((Rhs).Tile) * 2097152.00f > Rhs.Offset - Lhs; } bool3 LWCGreater( FLWCVector3 Lhs, float3 Rhs) { return ((Lhs).Tile) * 2097152.00f > Rhs - Lhs.Offset; }
bool3 LWCGreaterEqual( FLWCVector3 Lhs, FLWCVector3 Rhs) { return ( ((Lhs).Tile) - ((Rhs).Tile) ) * 2097152.00f >= Rhs.Offset - Lhs.Offset; } bool3 LWCGreaterEqual( float3 Lhs, FLWCVector3 Rhs) { return - ((Rhs).Tile) * 2097152.00f >= Rhs.Offset - Lhs; } bool3 LWCGreaterEqual( FLWCVector3 Lhs, float3 Rhs) { return ((Lhs).Tile) * 2097152.00f >= Rhs - Lhs.Offset; }
bool3 LWCLess( FLWCVector3 Lhs, FLWCVector3 Rhs) { return ( ((Lhs).Tile) - ((Rhs).Tile) ) * 2097152.00f < Rhs.Offset - Lhs.Offset; } bool3 LWCLess( float3 Lhs, FLWCVector3 Rhs) { return - ((Rhs).Tile) * 2097152.00f < Rhs.Offset - Lhs; } bool3 LWCLess( FLWCVector3 Lhs, float3 Rhs) { return ((Lhs).Tile) * 2097152.00f < Rhs - Lhs.Offset; }
bool3 LWCLessEqual( FLWCVector3 Lhs, FLWCVector3 Rhs) { return ( ((Lhs).Tile) - ((Rhs).Tile) ) * 2097152.00f <= Rhs.Offset - Lhs.Offset; } bool3 LWCLessEqual( float3 Lhs, FLWCVector3 Rhs) { return - ((Rhs).Tile) * 2097152.00f <= Rhs.Offset - Lhs; } bool3 LWCLessEqual( FLWCVector3 Lhs, float3 Rhs) { return ((Lhs).Tile) * 2097152.00f <= Rhs - Lhs.Offset; }





float3  LWCDdx( FLWCVector3  V) { return ( float3 )0; }
float3  LWCDdy( FLWCVector3  V) { return ( float3 )0; }
#line 52 "/Engine/Private/LWCOperations.ush"
FLWCVector3  LWCAdd( FLWCVector3  Lhs,  FLWCVector3  Rhs) { return  MakeLWCVector3 ( ((Lhs).Tile)  +  ((Rhs).Tile) , Lhs.Offset + Rhs.Offset); }
FLWCVector3  LWCAdd( float3  Lhs,  FLWCVector3  Rhs) { return  MakeLWCVector3 ( ((Rhs).Tile) , Lhs + Rhs.Offset); }
FLWCVector3  LWCAdd( FLWCVector3  Lhs,  float3  Rhs) { return  MakeLWCVector3 ( ((Lhs).Tile) , Lhs.Offset + Rhs); }

FLWCVector3  LWCSubtract( FLWCVector3  Lhs,  FLWCVector3  Rhs) { return  MakeLWCVector3 ( ((Lhs).Tile)  -  ((Rhs).Tile) , Lhs.Offset - Rhs.Offset); }
FLWCVector3  LWCSubtract( float3  Lhs,  FLWCVector3  Rhs) { return  MakeLWCVector3 (- ((Rhs).Tile) , Lhs - Rhs.Offset); }
FLWCVector3  LWCSubtract( FLWCVector3  Lhs,  float3  Rhs) { return  MakeLWCVector3 ( ((Lhs).Tile) , Lhs.Offset - Rhs); }

bool3  LWCEquals( FLWCVector3  Lhs,  FLWCVector3  Rhs)
{
	return ( ((Lhs).Tile)  -  ((Rhs).Tile) ) *  2097152.00f  == Rhs.Offset - Lhs.Offset;
}
bool3  LWCEquals( float3  Lhs,  FLWCVector3  Rhs)
{
	return - ((Rhs).Tile)  *  2097152.00f  == Rhs.Offset - Lhs;
}
bool3  LWCEquals( FLWCVector3  Lhs,  float3  Rhs)
{
	return  ((Lhs).Tile)  *  2097152.00f  == Rhs - Lhs.Offset;
}
bool3  LWCEqualsApprox( FLWCVector3  Lhs,  FLWCVector3  Rhs, float Threshold)
{
	return abs(( ((Lhs).Tile)  -  ((Rhs).Tile) ) *  2097152.00f  + (Lhs.Offset - Rhs.Offset)) < ( float3 )Threshold;
}
bool3  LWCEqualsApprox( float3  Lhs,  FLWCVector3  Rhs, float Threshold)
{
	return abs(- ((Rhs).Tile)  *  2097152.00f  + (Lhs - Rhs.Offset)) < ( float3 )Threshold;
}
bool3  LWCEqualsApprox( FLWCVector3  Lhs,  float3  Rhs, float Threshold)
{
	return abs( ((Lhs).Tile)  *  2097152.00f  + (Lhs.Offset - Rhs)) < ( float3 )Threshold;
}

FLWCVector3  LWCSelect( bool3  S,  FLWCVector3  Lhs,  FLWCVector3  Rhs) { return  MakeLWCVector3 ( select_internal(S, ((Lhs).Tile) , ((Rhs).Tile) ) ,  select_internal(S,Lhs.Offset,Rhs.Offset) ); }
FLWCVector3  LWCSelect( bool3  S,  float3  Lhs,  FLWCVector3  Rhs) { return  MakeLWCVector3 ( select_internal(S,( float3 )0, ((Rhs).Tile) ) ,  select_internal(S,Lhs,Rhs.Offset) ); }
FLWCVector3  LWCSelect( bool3  S,  FLWCVector3  Lhs,  float3  Rhs) { return  MakeLWCVector3 ( select_internal(S, ((Lhs).Tile) ,( float3 )0) ,  select_internal(S,Lhs.Offset,Rhs) ); }

FLWCVector3  LWCNegate( FLWCVector3  V) { return  MakeLWCVector3 (- ((V).Tile) , -V.Offset); }

float3  LWCFrac( FLWCVector3  V)
{
	float3  FracTile = frac( ((V).Tile)  *  2097152.00f );
	return frac(FracTile + V.Offset);
}

FLWCVector3  LWCFloor( FLWCVector3  V) {  FLWCVector3  VN = LWCMakeIntTile(V); return  MakeLWCVector3 ( ((VN).Tile) , floor(VN.Offset)); }
FLWCVector3  LWCCeil( FLWCVector3  V) {  FLWCVector3  VN = LWCMakeIntTile(V); return  MakeLWCVector3 ( ((VN).Tile) , ceil(VN.Offset)); }
FLWCVector3  LWCRound( FLWCVector3  V) {  FLWCVector3  VN = LWCMakeIntTile(V); return  MakeLWCVector3 ( ((VN).Tile) , round(VN.Offset)); }
FLWCVector3  LWCTrunc( FLWCVector3  V) {  FLWCVector3  VN = LWCMakeIntTile(V); return  MakeLWCVector3 ( ((VN).Tile) , trunc(VN.Offset)); }


float3  LWCSign( FLWCVector3  V) { return  float3 (sign(LWCToFloat(V))); }
float3  LWCSaturate( FLWCVector3  V) { return saturate(LWCToFloat(V)); }
float3  LWCClampScalar( FLWCVector3  V, float Low, float High) { return clamp(LWCToFloat(V), Low, High); }

FLWCVector3  LWCMultiply( FLWCVector3  Lhs,  FLWCVector3  Rhs)
{
	return  MakeLWCVector3 ( ((Lhs).Tile)  * ( ((Rhs).Tile)  *  2097152.00f  + Rhs.Offset) +  ((Rhs).Tile)  * Lhs.Offset, Lhs.Offset * Rhs.Offset);
}
FLWCVector3  LWCMultiply( float3  Lhs,  FLWCVector3  Rhs) { return  MakeLWCVector3 ( ((Rhs).Tile)  * Lhs, Lhs * Rhs.Offset); }
FLWCVector3  LWCMultiply( FLWCVector3  Lhs,  float3  Rhs) { return  MakeLWCVector3 ( ((Lhs).Tile)  * Rhs, Lhs.Offset * Rhs); }

FLWCVector3  LWCDivide( FLWCVector3  Lhs,  FLWCVector3  Rhs) { return LWCMultiply(Lhs, LWCRcp(Rhs)); }
FLWCVector3  LWCDivide( FLWCVector3  Lhs,  float3  Rhs) { return LWCMultiply(Lhs, rcp(Rhs)); }
FLWCVector3  LWCDivide( float3  Lhs,  FLWCVector3  Rhs) { return  MakeLWCVector3 (( float3 )0, Lhs * LWCRcp(Rhs)); }


FLWCVector3  LWCLerp( FLWCVector3  Lhs,  FLWCVector3  Rhs,  float3  S)
{
	return  MakeLWCVector3 (lerp( ((Lhs).Tile) ,  ((Rhs).Tile) , S), lerp(Lhs.Offset, Rhs.Offset, S));
}

float3  LWCFmod( FLWCVector3  Lhs,  float3  Rhs)
{
	return LWCToFloat(LWCSubtract(Lhs, LWCMultiply(LWCTrunc(LWCDivide(Lhs, Rhs)), Rhs)));


}
float3  LWCFmodFloor( FLWCVector3  Lhs,  float3  Rhs)
{
	return LWCToFloat(LWCSubtract(Lhs, LWCMultiply(LWCFloor(LWCDivide(Lhs, Rhs)), Rhs)));


}
float3  LWCFmodFloorPI( FLWCVector3  V)
{
	return LWCFmodFloor(V, PI);

}
float3  LWCFmodFloor2PI( FLWCVector3  V)
{
	return LWCFmodFloor(V, 2.0f * PI);

}

float3  LWCSin( FLWCVector3  V) { return sin(LWCFmodFloor2PI(V)); }
float3  LWCCos( FLWCVector3  V) { return cos(LWCFmodFloor2PI(V)); }
float3  LWCTan( FLWCVector3  V) { return tan(LWCFmodFloorPI(V)); }
float3  LWCASin( FLWCVector3  V) { return asin(LWCClampScalar(V, -1.0f, 1.0f)); }
float3  LWCACos( FLWCVector3  V) { return acos(LWCClampScalar(V, -1.0f, 1.0f)); }
float3  LWCATan( FLWCVector3  V) { return atan(LWCClampScalar(V, -0.5f*PI, 0.5f*PI)); }

float3  LWCSmoothStep( FLWCVector3  Lhs,  FLWCVector3  Rhs,  FLWCVector3  S)
{
	float3  t = LWCSaturate(LWCDivide(LWCSubtract(S, Lhs), LWCSubtract(Rhs, Lhs)));
	return t*t*(3.0f - (2.0f*t));
}

FLWCVector3  LWCMin( FLWCVector3  Lhs,  FLWCVector3  Rhs) { return LWCSelect(LWCLess(Lhs, Rhs), Lhs, Rhs); }
FLWCVector3  LWCMin( float3  Lhs,  FLWCVector3  Rhs) { return LWCSelect(LWCLess(Lhs, Rhs), Lhs, Rhs); }
FLWCVector3  LWCMin( FLWCVector3  Lhs,  float3  Rhs) { return LWCSelect(LWCLess(Lhs, Rhs), Lhs, Rhs); }
FLWCVector3  LWCMax( FLWCVector3  Lhs,  FLWCVector3  Rhs) { return LWCSelect(LWCGreater(Lhs, Rhs), Lhs, Rhs); }
FLWCVector3  LWCMax( float3  Lhs,  FLWCVector3  Rhs) { return LWCSelect(LWCGreater(Lhs, Rhs), Lhs, Rhs); }
FLWCVector3  LWCMax( FLWCVector3  Lhs,  float3  Rhs) { return LWCSelect(LWCGreater(Lhs, Rhs), Lhs, Rhs); }

FLWCVector3  LWCAbs( FLWCVector3  V) { return LWCSelect(LWCLess(V, ( float3 )0), LWCNegate(V), V); }

float3  LWCStep( FLWCVector3  Lhs,  FLWCVector3  Rhs) { return  select_internal(LWCGreaterEqual(Rhs, Lhs),( float3 )1.0f,( float3 )0.0f) ; }
float3  LWCStep( FLWCVector3  Lhs,  float3  Rhs) { return  select_internal(LWCGreaterEqual(Rhs, Lhs),( float3 )1.0f,( float3 )0.0f) ; }
float3  LWCStep( float3  Lhs,  FLWCVector3  Rhs) { return  select_internal(LWCGreaterEqual(Rhs, Lhs),( float3 )1.0f,( float3 )0.0f) ; }


FLWCVector3  LWCSquareScaled( FLWCVector3  V)
{
	float3  OffsetScaled = V.Offset *  4.76837158e-07f ;
	return  MakeLWCVector3 ( ((V).Tile)  * ( ((V).Tile)  + OffsetScaled * 2.0f), V.Offset * OffsetScaled);
}
#line 397 "/Engine/Private/LargeWorldCoordinates.ush"
#line 406 "/Engine/Private/LargeWorldCoordinates.ush"
#line 1 "LWCOperations.ush"




FLWCVector4  LWCNormalizeTile( FLWCVector4  V)
{
	float4  IntTile = floor(V.Tile + (V.Offset *  4.76837158e-07f  + 0.5f));
	return  MakeLWCVector4 (IntTile, (V.Tile - IntTile) *  2097152.00f  + V.Offset);
}


FLWCVector4  LWCMakeIntTile( FLWCVector4  V)
{
	float4  IntTile = floor(V.Tile);
	return  MakeLWCVector4 (IntTile, (V.Tile - IntTile) *  2097152.00f  + V.Offset);
}

float4  LWCSqrtUnscaled( FLWCVector4  V) { return sqrt(V.Offset *  4.76837158e-07f  +  ((V).Tile) ); }
float4  LWCRsqrtUnscaled( FLWCVector4  V) { return rsqrt(V.Offset *  4.76837158e-07f  +  ((V).Tile) ); }
float4  LWCRcpUnscaled( FLWCVector4  V) { return rcp(V.Offset *  4.76837158e-07f  +  ((V).Tile) ); }
float4  LWCSqrtScaled( FLWCVector4  V, float Scale) { return LWCSqrtUnscaled(V) * Scale; }
float4  LWCRsqrtScaled( FLWCVector4  V, float Scale) { return LWCRsqrtUnscaled(V) * Scale; }
float4  LWCRcpScaled( FLWCVector4  V, float Scale) { return LWCRcpUnscaled(V) * Scale; }
float4  LWCSqrt( FLWCVector4  V) { return LWCSqrtScaled(V,  1448.15466f ); }
float4  LWCRsqrt( FLWCVector4  V) { return LWCRsqrtScaled(V,  0.000690533954f ); }
float4  LWCRcp( FLWCVector4  V) { return LWCRcpScaled(V,  4.76837158e-07f ); }
#line 36 "/Engine/Private/LWCOperations.ush"
bool4 LWCGreater( FLWCVector4 Lhs, FLWCVector4 Rhs) { return ( ((Lhs).Tile) - ((Rhs).Tile) ) * 2097152.00f > Rhs.Offset - Lhs.Offset; } bool4 LWCGreater( float4 Lhs, FLWCVector4 Rhs) { return - ((Rhs).Tile) * 2097152.00f > Rhs.Offset - Lhs; } bool4 LWCGreater( FLWCVector4 Lhs, float4 Rhs) { return ((Lhs).Tile) * 2097152.00f > Rhs - Lhs.Offset; }
bool4 LWCGreaterEqual( FLWCVector4 Lhs, FLWCVector4 Rhs) { return ( ((Lhs).Tile) - ((Rhs).Tile) ) * 2097152.00f >= Rhs.Offset - Lhs.Offset; } bool4 LWCGreaterEqual( float4 Lhs, FLWCVector4 Rhs) { return - ((Rhs).Tile) * 2097152.00f >= Rhs.Offset - Lhs; } bool4 LWCGreaterEqual( FLWCVector4 Lhs, float4 Rhs) { return ((Lhs).Tile) * 2097152.00f >= Rhs - Lhs.Offset; }
bool4 LWCLess( FLWCVector4 Lhs, FLWCVector4 Rhs) { return ( ((Lhs).Tile) - ((Rhs).Tile) ) * 2097152.00f < Rhs.Offset - Lhs.Offset; } bool4 LWCLess( float4 Lhs, FLWCVector4 Rhs) { return - ((Rhs).Tile) * 2097152.00f < Rhs.Offset - Lhs; } bool4 LWCLess( FLWCVector4 Lhs, float4 Rhs) { return ((Lhs).Tile) * 2097152.00f < Rhs - Lhs.Offset; }
bool4 LWCLessEqual( FLWCVector4 Lhs, FLWCVector4 Rhs) { return ( ((Lhs).Tile) - ((Rhs).Tile) ) * 2097152.00f <= Rhs.Offset - Lhs.Offset; } bool4 LWCLessEqual( float4 Lhs, FLWCVector4 Rhs) { return - ((Rhs).Tile) * 2097152.00f <= Rhs.Offset - Lhs; } bool4 LWCLessEqual( FLWCVector4 Lhs, float4 Rhs) { return ((Lhs).Tile) * 2097152.00f <= Rhs - Lhs.Offset; }





float4  LWCDdx( FLWCVector4  V) { return ( float4 )0; }
float4  LWCDdy( FLWCVector4  V) { return ( float4 )0; }
#line 52 "/Engine/Private/LWCOperations.ush"
FLWCVector4  LWCAdd( FLWCVector4  Lhs,  FLWCVector4  Rhs) { return  MakeLWCVector4 ( ((Lhs).Tile)  +  ((Rhs).Tile) , Lhs.Offset + Rhs.Offset); }
FLWCVector4  LWCAdd( float4  Lhs,  FLWCVector4  Rhs) { return  MakeLWCVector4 ( ((Rhs).Tile) , Lhs + Rhs.Offset); }
FLWCVector4  LWCAdd( FLWCVector4  Lhs,  float4  Rhs) { return  MakeLWCVector4 ( ((Lhs).Tile) , Lhs.Offset + Rhs); }

FLWCVector4  LWCSubtract( FLWCVector4  Lhs,  FLWCVector4  Rhs) { return  MakeLWCVector4 ( ((Lhs).Tile)  -  ((Rhs).Tile) , Lhs.Offset - Rhs.Offset); }
FLWCVector4  LWCSubtract( float4  Lhs,  FLWCVector4  Rhs) { return  MakeLWCVector4 (- ((Rhs).Tile) , Lhs - Rhs.Offset); }
FLWCVector4  LWCSubtract( FLWCVector4  Lhs,  float4  Rhs) { return  MakeLWCVector4 ( ((Lhs).Tile) , Lhs.Offset - Rhs); }

bool4  LWCEquals( FLWCVector4  Lhs,  FLWCVector4  Rhs)
{
	return ( ((Lhs).Tile)  -  ((Rhs).Tile) ) *  2097152.00f  == Rhs.Offset - Lhs.Offset;
}
bool4  LWCEquals( float4  Lhs,  FLWCVector4  Rhs)
{
	return - ((Rhs).Tile)  *  2097152.00f  == Rhs.Offset - Lhs;
}
bool4  LWCEquals( FLWCVector4  Lhs,  float4  Rhs)
{
	return  ((Lhs).Tile)  *  2097152.00f  == Rhs - Lhs.Offset;
}
bool4  LWCEqualsApprox( FLWCVector4  Lhs,  FLWCVector4  Rhs, float Threshold)
{
	return abs(( ((Lhs).Tile)  -  ((Rhs).Tile) ) *  2097152.00f  + (Lhs.Offset - Rhs.Offset)) < ( float4 )Threshold;
}
bool4  LWCEqualsApprox( float4  Lhs,  FLWCVector4  Rhs, float Threshold)
{
	return abs(- ((Rhs).Tile)  *  2097152.00f  + (Lhs - Rhs.Offset)) < ( float4 )Threshold;
}
bool4  LWCEqualsApprox( FLWCVector4  Lhs,  float4  Rhs, float Threshold)
{
	return abs( ((Lhs).Tile)  *  2097152.00f  + (Lhs.Offset - Rhs)) < ( float4 )Threshold;
}

FLWCVector4  LWCSelect( bool4  S,  FLWCVector4  Lhs,  FLWCVector4  Rhs) { return  MakeLWCVector4 ( select_internal(S, ((Lhs).Tile) , ((Rhs).Tile) ) ,  select_internal(S,Lhs.Offset,Rhs.Offset) ); }
FLWCVector4  LWCSelect( bool4  S,  float4  Lhs,  FLWCVector4  Rhs) { return  MakeLWCVector4 ( select_internal(S,( float4 )0, ((Rhs).Tile) ) ,  select_internal(S,Lhs,Rhs.Offset) ); }
FLWCVector4  LWCSelect( bool4  S,  FLWCVector4  Lhs,  float4  Rhs) { return  MakeLWCVector4 ( select_internal(S, ((Lhs).Tile) ,( float4 )0) ,  select_internal(S,Lhs.Offset,Rhs) ); }

FLWCVector4  LWCNegate( FLWCVector4  V) { return  MakeLWCVector4 (- ((V).Tile) , -V.Offset); }

float4  LWCFrac( FLWCVector4  V)
{
	float4  FracTile = frac( ((V).Tile)  *  2097152.00f );
	return frac(FracTile + V.Offset);
}

FLWCVector4  LWCFloor( FLWCVector4  V) {  FLWCVector4  VN = LWCMakeIntTile(V); return  MakeLWCVector4 ( ((VN).Tile) , floor(VN.Offset)); }
FLWCVector4  LWCCeil( FLWCVector4  V) {  FLWCVector4  VN = LWCMakeIntTile(V); return  MakeLWCVector4 ( ((VN).Tile) , ceil(VN.Offset)); }
FLWCVector4  LWCRound( FLWCVector4  V) {  FLWCVector4  VN = LWCMakeIntTile(V); return  MakeLWCVector4 ( ((VN).Tile) , round(VN.Offset)); }
FLWCVector4  LWCTrunc( FLWCVector4  V) {  FLWCVector4  VN = LWCMakeIntTile(V); return  MakeLWCVector4 ( ((VN).Tile) , trunc(VN.Offset)); }


float4  LWCSign( FLWCVector4  V) { return  float4 (sign(LWCToFloat(V))); }
float4  LWCSaturate( FLWCVector4  V) { return saturate(LWCToFloat(V)); }
float4  LWCClampScalar( FLWCVector4  V, float Low, float High) { return clamp(LWCToFloat(V), Low, High); }

FLWCVector4  LWCMultiply( FLWCVector4  Lhs,  FLWCVector4  Rhs)
{
	return  MakeLWCVector4 ( ((Lhs).Tile)  * ( ((Rhs).Tile)  *  2097152.00f  + Rhs.Offset) +  ((Rhs).Tile)  * Lhs.Offset, Lhs.Offset * Rhs.Offset);
}
FLWCVector4  LWCMultiply( float4  Lhs,  FLWCVector4  Rhs) { return  MakeLWCVector4 ( ((Rhs).Tile)  * Lhs, Lhs * Rhs.Offset); }
FLWCVector4  LWCMultiply( FLWCVector4  Lhs,  float4  Rhs) { return  MakeLWCVector4 ( ((Lhs).Tile)  * Rhs, Lhs.Offset * Rhs); }

FLWCVector4  LWCDivide( FLWCVector4  Lhs,  FLWCVector4  Rhs) { return LWCMultiply(Lhs, LWCRcp(Rhs)); }
FLWCVector4  LWCDivide( FLWCVector4  Lhs,  float4  Rhs) { return LWCMultiply(Lhs, rcp(Rhs)); }
FLWCVector4  LWCDivide( float4  Lhs,  FLWCVector4  Rhs) { return  MakeLWCVector4 (( float4 )0, Lhs * LWCRcp(Rhs)); }


FLWCVector4  LWCLerp( FLWCVector4  Lhs,  FLWCVector4  Rhs,  float4  S)
{
	return  MakeLWCVector4 (lerp( ((Lhs).Tile) ,  ((Rhs).Tile) , S), lerp(Lhs.Offset, Rhs.Offset, S));
}

float4  LWCFmod( FLWCVector4  Lhs,  float4  Rhs)
{
	return LWCToFloat(LWCSubtract(Lhs, LWCMultiply(LWCTrunc(LWCDivide(Lhs, Rhs)), Rhs)));


}
float4  LWCFmodFloor( FLWCVector4  Lhs,  float4  Rhs)
{
	return LWCToFloat(LWCSubtract(Lhs, LWCMultiply(LWCFloor(LWCDivide(Lhs, Rhs)), Rhs)));


}
float4  LWCFmodFloorPI( FLWCVector4  V)
{
	return LWCFmodFloor(V, PI);

}
float4  LWCFmodFloor2PI( FLWCVector4  V)
{
	return LWCFmodFloor(V, 2.0f * PI);

}

float4  LWCSin( FLWCVector4  V) { return sin(LWCFmodFloor2PI(V)); }
float4  LWCCos( FLWCVector4  V) { return cos(LWCFmodFloor2PI(V)); }
float4  LWCTan( FLWCVector4  V) { return tan(LWCFmodFloorPI(V)); }
float4  LWCASin( FLWCVector4  V) { return asin(LWCClampScalar(V, -1.0f, 1.0f)); }
float4  LWCACos( FLWCVector4  V) { return acos(LWCClampScalar(V, -1.0f, 1.0f)); }
float4  LWCATan( FLWCVector4  V) { return atan(LWCClampScalar(V, -0.5f*PI, 0.5f*PI)); }

float4  LWCSmoothStep( FLWCVector4  Lhs,  FLWCVector4  Rhs,  FLWCVector4  S)
{
	float4  t = LWCSaturate(LWCDivide(LWCSubtract(S, Lhs), LWCSubtract(Rhs, Lhs)));
	return t*t*(3.0f - (2.0f*t));
}

FLWCVector4  LWCMin( FLWCVector4  Lhs,  FLWCVector4  Rhs) { return LWCSelect(LWCLess(Lhs, Rhs), Lhs, Rhs); }
FLWCVector4  LWCMin( float4  Lhs,  FLWCVector4  Rhs) { return LWCSelect(LWCLess(Lhs, Rhs), Lhs, Rhs); }
FLWCVector4  LWCMin( FLWCVector4  Lhs,  float4  Rhs) { return LWCSelect(LWCLess(Lhs, Rhs), Lhs, Rhs); }
FLWCVector4  LWCMax( FLWCVector4  Lhs,  FLWCVector4  Rhs) { return LWCSelect(LWCGreater(Lhs, Rhs), Lhs, Rhs); }
FLWCVector4  LWCMax( float4  Lhs,  FLWCVector4  Rhs) { return LWCSelect(LWCGreater(Lhs, Rhs), Lhs, Rhs); }
FLWCVector4  LWCMax( FLWCVector4  Lhs,  float4  Rhs) { return LWCSelect(LWCGreater(Lhs, Rhs), Lhs, Rhs); }

FLWCVector4  LWCAbs( FLWCVector4  V) { return LWCSelect(LWCLess(V, ( float4 )0), LWCNegate(V), V); }

float4  LWCStep( FLWCVector4  Lhs,  FLWCVector4  Rhs) { return  select_internal(LWCGreaterEqual(Rhs, Lhs),( float4 )1.0f,( float4 )0.0f) ; }
float4  LWCStep( FLWCVector4  Lhs,  float4  Rhs) { return  select_internal(LWCGreaterEqual(Rhs, Lhs),( float4 )1.0f,( float4 )0.0f) ; }
float4  LWCStep( float4  Lhs,  FLWCVector4  Rhs) { return  select_internal(LWCGreaterEqual(Rhs, Lhs),( float4 )1.0f,( float4 )0.0f) ; }


FLWCVector4  LWCSquareScaled( FLWCVector4  V)
{
	float4  OffsetScaled = V.Offset *  4.76837158e-07f ;
	return  MakeLWCVector4 ( ((V).Tile)  * ( ((V).Tile)  + OffsetScaled * 2.0f), V.Offset * OffsetScaled);
}
#line 407 "/Engine/Private/LargeWorldCoordinates.ush"






FLWCScalar LWCMakeRelativeToTile(FLWCScalar V, float NewTile) { return MakeLWCScalar(NewTile, LWCToFloat(LWCSubtract(V, MakeLWCScalar(NewTile, (float)0.0f)))); }
FLWCVector2 LWCMakeRelativeToTile(FLWCVector2 V, float2 NewTile) { return MakeLWCVector2(NewTile, LWCToFloat(LWCSubtract(V, MakeLWCVector2(NewTile, (float2)0.0f)))); }
FLWCVector3 LWCMakeRelativeToTile(FLWCVector3 V, float3 NewTile) { return MakeLWCVector3(NewTile, LWCToFloat(LWCSubtract(V, MakeLWCVector3(NewTile, (float3)0.0f)))); }
FLWCVector4 LWCMakeRelativeToTile(FLWCVector4 V, float4 NewTile) { return MakeLWCVector4(NewTile, LWCToFloat(LWCSubtract(V, MakeLWCVector4(NewTile, (float4)0.0f)))); }
FLWCMatrix LWCMakeRelativeToTile(FLWCMatrix M, float3 NewTile)
{
	LWCSetOrigin(M, LWCMakeRelativeToTile(LWCGetOrigin(M), NewTile));
	return M;
}

FLWCScalar LWCVectorSum(FLWCScalar V) { return V; }
FLWCScalar LWCVectorSum(FLWCVector2 V) { return LWCAdd( LWCGetComponent(V, 0) ,  LWCGetComponent(V, 1) ); }
FLWCScalar LWCVectorSum(FLWCVector3 V) { return LWCAdd(LWCAdd( LWCGetComponent(V, 0) ,  LWCGetComponent(V, 1) ),  LWCGetComponent(V, 2) ); }
FLWCScalar LWCVectorSum(FLWCVector4 V) { return LWCAdd(LWCAdd(LWCAdd( LWCGetComponent(V, 0) ,  LWCGetComponent(V, 1) ),  LWCGetComponent(V, 2) ),  LWCGetComponent(V, 3) ); }

FLWCScalar LWCDot(FLWCScalar Lhs, FLWCScalar Rhs) { return LWCMultiply(Lhs, Rhs); }
FLWCScalar LWCDot(FLWCScalar Lhs, float Rhs) { return LWCMultiply(Lhs, Rhs); }
FLWCScalar LWCDot(FLWCVector2 Lhs, FLWCVector2 Rhs) { return LWCVectorSum(LWCMultiply(Lhs, Rhs)); }
FLWCScalar LWCDot(FLWCVector2 Lhs, float2 Rhs) { return LWCVectorSum(LWCMultiply(Lhs, Rhs)); }
FLWCScalar LWCDot(FLWCVector3 Lhs, FLWCVector3 Rhs) { return LWCVectorSum(LWCMultiply(Lhs, Rhs)); }
FLWCScalar LWCDot(FLWCVector3 Lhs, float3 Rhs) { return LWCVectorSum(LWCMultiply(Lhs, Rhs)); }
FLWCScalar LWCDot(FLWCVector4 Lhs, FLWCVector4 Rhs) { return LWCVectorSum(LWCMultiply(Lhs, Rhs)); }
FLWCScalar LWCDot(FLWCVector4 Lhs, float4 Rhs) { return LWCVectorSum(LWCMultiply(Lhs, Rhs)); }


FLWCScalar LWCLength2Scaled(FLWCScalar V)
{
	return LWCSquareScaled(V);
}

FLWCScalar LWCLength2Scaled(FLWCVector2 V)
{
	FLWCScalar X2 = LWCSquareScaled( LWCGetComponent(V, 0) );
	FLWCScalar Y2 = LWCSquareScaled( LWCGetComponent(V, 1) );
	return LWCAdd(X2, Y2);
}

FLWCScalar LWCLength2Scaled(FLWCVector3 V)
{
	FLWCScalar X2 = LWCSquareScaled( LWCGetComponent(V, 0) );
	FLWCScalar Y2 = LWCSquareScaled( LWCGetComponent(V, 1) );
	FLWCScalar Z2 = LWCSquareScaled( LWCGetComponent(V, 2) );
	return LWCAdd(LWCAdd(X2, Y2), Z2);
}

FLWCScalar LWCLength2Scaled(FLWCVector4 V)
{
	FLWCScalar X2 = LWCSquareScaled( LWCGetComponent(V, 0) );
	FLWCScalar Y2 = LWCSquareScaled( LWCGetComponent(V, 1) );
	FLWCScalar Z2 = LWCSquareScaled( LWCGetComponent(V, 2) );
	FLWCScalar W2 = LWCSquareScaled( LWCGetComponent(V, 3) );
	return LWCAdd(LWCAdd(LWCAdd(X2, Y2), Z2), W2);
}



FLWCScalar LWCLength(FLWCScalar V) { return MakeLWCScalar(LWCSqrtUnscaled(LWCLength2Scaled(V)), 0.0f); }
FLWCScalar LWCLength(FLWCVector2 V) { return MakeLWCScalar(LWCSqrtUnscaled(LWCLength2Scaled(V)), 0.0f); }
FLWCScalar LWCLength(FLWCVector3 V) { return MakeLWCScalar(LWCSqrtUnscaled(LWCLength2Scaled(V)), 0.0f); }
FLWCScalar LWCLength(FLWCVector4 V) { return MakeLWCScalar(LWCSqrtUnscaled(LWCLength2Scaled(V)), 0.0f); }

float LWCRcpLength(FLWCScalar V) { return LWCRsqrtScaled(LWCLength2Scaled(V),  4.76837158e-07f ); }
float LWCRcpLength(FLWCVector2 V) { return LWCRsqrtScaled(LWCLength2Scaled(V),  4.76837158e-07f ); }
float LWCRcpLength(FLWCVector3 V) { return LWCRsqrtScaled(LWCLength2Scaled(V),  4.76837158e-07f ); }
float LWCRcpLength(FLWCVector4 V) { return LWCRsqrtScaled(LWCLength2Scaled(V),  4.76837158e-07f ); }

float LWCNormalize(FLWCScalar V) { return 1.0f; }
float2 LWCNormalize(FLWCVector2 V) { return LWCToFloat(LWCMultiply(V, LWCRcpLength(V))); }
float3 LWCNormalize(FLWCVector3 V) { return LWCToFloat(LWCMultiply(V, LWCRcpLength(V))); }
float4 LWCNormalize(FLWCVector4 V) { return LWCToFloat(LWCMultiply(V, LWCRcpLength(V))); }
#line 202 "/Engine/Private/Common.ush"
#line 203 "/Engine/Private/Common.ush"
#line 1 "InstancedStereo.ush"
#line 10 "/Engine/Private/InstancedStereo.ush"
#line 1 "/Engine/Generated/UniformBuffers/View.ush"
#line 11 "/Engine/Private/InstancedStereo.ush"
#line 1 "/Engine/Generated/UniformBuffers/InstancedView.ush"
#line 12 "/Engine/Private/InstancedStereo.ush"
#line 15 "/Engine/Private/InstancedStereo.ush"
#line 1 "/Engine/Generated/GeneratedInstancedStereo.ush"
struct ViewState
{
	float4x4 TranslatedWorldToClip;
	float4x4 TranslatedWorldToSubpixelClip;
	float4x4 RelativeWorldToClip;
	float4x4 ClipToRelativeWorld;
	float4x4 TranslatedWorldToView;
	float4x4 ViewToTranslatedWorld;
	float4x4 TranslatedWorldToCameraView;
	float4x4 CameraViewToTranslatedWorld;
	float4x4 ViewToClip;
	float4x4 ViewToClipNoAA;
	float4x4 ClipToView;
	float4x4 ClipToTranslatedWorld;
	float4x4 SVPositionToTranslatedWorld;
	float4x4 ScreenToRelativeWorld;
	float4x4 ScreenToTranslatedWorld;
	float4x4 MobileMultiviewShadowTransform;
	float3 ViewTilePosition;
	float3 MatrixTilePosition;
	float3 ViewForward;
	float3 ViewUp;
	float3 ViewRight;
	float3 HMDViewNoRollUp;
	float3 HMDViewNoRollRight;
	float4 InvDeviceZToWorldZTransform;
	float4 ScreenPositionScaleBias;
	float3 RelativeWorldCameraOrigin;
	float3 TranslatedWorldCameraOrigin;
	float3 RelativeWorldViewOrigin;
	float3 RelativePreViewTranslation;
	float4x4 PrevViewToClip;
	float4x4 PrevClipToView;
	float4x4 PrevTranslatedWorldToClip;
	float4x4 PrevTranslatedWorldToView;
	float4x4 PrevViewToTranslatedWorld;
	float4x4 PrevTranslatedWorldToCameraView;
	float4x4 PrevCameraViewToTranslatedWorld;
	float3 PrevTranslatedWorldCameraOrigin;
	float3 PrevRelativeWorldCameraOrigin;
	float3 PrevRelativeWorldViewOrigin;
	float3 RelativePrevPreViewTranslation;
	float4x4 PrevClipToRelativeWorld;
	float4x4 PrevScreenToTranslatedWorld;
	float4x4 ClipToPrevClip;
	float4x4 ClipToPrevClipWithAA;
	float4 TemporalAAJitter;
	float4 GlobalClippingPlane;
	float2 FieldOfViewWideAngles;
	float2 PrevFieldOfViewWideAngles;
	float4 ViewRectMin;
	float4 ViewSizeAndInvSize;
	uint4 ViewRectMinAndSize;
	float4 LightProbeSizeRatioAndInvSizeRatio;
	float4 BufferSizeAndInvSize;
	float4 BufferBilinearUVMinMax;
	float4 ScreenToViewSpace;
	float2 BufferToSceneTextureScale;
	float2 ResolutionFractionAndInv;
	int NumSceneColorMSAASamples;
	float SeparateWaterMainDirLightLuminance;
	float PreExposure;
	float OneOverPreExposure;
	float4 DiffuseOverrideParameter;
	float4 SpecularOverrideParameter;
	float4 NormalOverrideParameter;
	float2 RoughnessOverrideParameter;
	float PrevFrameGameTime;
	float PrevFrameRealTime;
	float OutOfBoundsMask;
	float3 WorldCameraMovementSinceLastFrame;
	float CullingSign;
	float NearPlane;
	float GameTime;
	float RealTime;
	float DeltaTime;
	float MaterialTextureMipBias;
	float MaterialTextureDerivativeMultiply;
	uint Random;
	uint FrameNumber;
	uint StateFrameIndexMod8;
	uint StateFrameIndex;
	uint DebugViewModeMask;
	float CameraCut;
	float UnlitViewmodeMask;
	float4 DirectionalLightColor;
	float3 DirectionalLightDirection;
	float4 TranslucencyLightingVolumeMin[2];
	float4 TranslucencyLightingVolumeInvSize[2];
	float4 TemporalAAParams;
	float4 CircleDOFParams;
	float DepthOfFieldSensorWidth;
	float DepthOfFieldFocalDistance;
	float DepthOfFieldScale;
	float DepthOfFieldFocalLength;
	float DepthOfFieldFocalRegion;
	float DepthOfFieldNearTransitionRegion;
	float DepthOfFieldFarTransitionRegion;
	float MotionBlurNormalizedToPixel;
	float GeneralPurposeTweak;
	float GeneralPurposeTweak2;
	float DemosaicVposOffset;
	float DecalDepthBias;
	float3 IndirectLightingColorScale;
	float3 PrecomputedIndirectLightingColorScale;
	float3 PrecomputedIndirectSpecularColorScale;
	float4 AtmosphereLightDirection[2];
	float4 AtmosphereLightIlluminanceOnGroundPostTransmittance[2];
	float4 AtmosphereLightIlluminanceOuterSpace[2];
	float4 AtmosphereLightDiscLuminance[2];
	float4 AtmosphereLightDiscCosHalfApexAngle_PPTrans[2];
	float4 SkyViewLutSizeAndInvSize;
	float3 SkyCameraTranslatedWorldOrigin;
	float4 SkyPlanetTranslatedWorldCenterAndViewHeight;
	float4x4 SkyViewLutReferential;
	float4 SkyAtmosphereSkyLuminanceFactor;
	float SkyAtmospherePresentInScene;
	float SkyAtmosphereHeightFogContribution;
	float SkyAtmosphereBottomRadiusKm;
	float SkyAtmosphereTopRadiusKm;
	float4 SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize;
	float SkyAtmosphereAerialPerspectiveStartDepthKm;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm;
	float SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv;
	float SkyAtmosphereApplyCameraAerialPerspectiveVolume;
	float3 NormalCurvatureToRoughnessScaleBias;
	float RenderingReflectionCaptureMask;
	float RealTimeReflectionCapture;
	float RealTimeReflectionCapturePreExposure;
	float4 AmbientCubemapTint;
	float AmbientCubemapIntensity;
	float SkyLightApplyPrecomputedBentNormalShadowingFlag;
	float SkyLightAffectReflectionFlag;
	float SkyLightAffectGlobalIlluminationFlag;
	float4 SkyLightColor;
	float4 MobileSkyIrradianceEnvironmentMap[8];
	float MobilePreviewMode;
	float HMDEyePaddingOffset;
	float ReflectionCubemapMaxMip;
	float ShowDecalsMask;
	uint DistanceFieldAOSpecularOcclusionMode;
	float IndirectCapsuleSelfShadowingIntensity;
	float3 ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	int StereoPassIndex;
	float4 GlobalVolumeCenterAndExtent[6];
	float4 GlobalVolumeWorldToUVAddAndMul[6];
	float4 GlobalDistanceFieldMipWorldToUVScale[6];
	float4 GlobalDistanceFieldMipWorldToUVBias[6];
	float GlobalDistanceFieldMipFactor;
	float GlobalDistanceFieldMipTransition;
	int GlobalDistanceFieldClipmapSizeInPages;
	float3 GlobalDistanceFieldInvPageAtlasSize;
	float3 GlobalDistanceFieldInvCoverageAtlasSize;
	float GlobalVolumeDimension;
	float GlobalVolumeTexelSize;
	float MaxGlobalDFAOConeDistance;
	uint NumGlobalSDFClipmaps;
	float CoveredExpandSurfaceScale;
	float NotCoveredExpandSurfaceScale;
	float NotCoveredMinStepScale;
	float DitheredTransparencyStepThreshold;
	float DitheredTransparencyTraceThreshold;
	int2 CursorPosition;
	float bCheckerboardSubsurfaceProfileRendering;
	float3 VolumetricFogInvGridSize;
	float3 VolumetricFogGridZParams;
	float2 VolumetricFogSVPosToVolumeUV;
	float VolumetricFogMaxDistance;
	float3 VolumetricLightmapWorldToUVScale;
	float3 VolumetricLightmapWorldToUVAdd;
	float3 VolumetricLightmapIndirectionTextureSize;
	float VolumetricLightmapBrickSize;
	float3 VolumetricLightmapBrickTexelSize;
	float IndirectLightingCacheShowFlag;
	float EyeToPixelSpreadAngle;
	float4 XRPassthroughCameraUVs[2];
	float GlobalVirtualTextureMipBias;
	uint VirtualTextureFeedbackShift;
	uint VirtualTextureFeedbackMask;
	uint VirtualTextureFeedbackStride;
	uint VirtualTextureFeedbackJitterOffset;
	uint VirtualTextureFeedbackSampleOffset;
	float4 RuntimeVirtualTextureMipLevel;
	float2 RuntimeVirtualTexturePackHeight;
	float4 RuntimeVirtualTextureDebugParams;
	float OverrideLandscapeLOD;
	int FarShadowStaticMeshLODBias;
	float MinRoughness;
	float4 HairRenderInfo;
	uint EnableSkyLight;
	uint HairRenderInfoBits;
	uint HairComponents;
	float bSubsurfacePostprocessEnabled;
	float4 SSProfilesTextureSizeAndInvSize;
	float4 SSProfilesPreIntegratedTextureSizeAndInvSize;
	float3 PhysicsFieldClipmapCenter;
	float PhysicsFieldClipmapDistance;
	int PhysicsFieldClipmapResolution;
	int PhysicsFieldClipmapExponent;
	int PhysicsFieldClipmapCount;
	int PhysicsFieldTargetCount;
	int4 PhysicsFieldTargets[32];
	uint InstanceSceneDataSOAStride;
	uint GPUSceneViewId;
	float ViewResolutionFraction;
	float SubSurfaceColorAsTransmittanceAtDistanceInMeters;
	FLWCInverseMatrix WorldToClip;
	FLWCMatrix ClipToWorld;
	FLWCMatrix ScreenToWorld;
	FLWCMatrix PrevClipToWorld;
	FLWCVector3 WorldCameraOrigin;
	FLWCVector3 WorldViewOrigin;
	FLWCVector3 PrevWorldCameraOrigin;
	FLWCVector3 PrevWorldViewOrigin;
	FLWCVector3 PreViewTranslation;
	FLWCVector3 PrevPreViewTranslation;
};
	void FinalizeViewState(inout ViewState InOutView);
ViewState GetPrimaryView()
{
	ViewState Result;
	Result.TranslatedWorldToClip = View.TranslatedWorldToClip;
	Result.TranslatedWorldToSubpixelClip = View.TranslatedWorldToSubpixelClip;
	Result.RelativeWorldToClip = View.RelativeWorldToClip;
	Result.ClipToRelativeWorld = View.ClipToRelativeWorld;
	Result.TranslatedWorldToView = View.TranslatedWorldToView;
	Result.ViewToTranslatedWorld = View.ViewToTranslatedWorld;
	Result.TranslatedWorldToCameraView = View.TranslatedWorldToCameraView;
	Result.CameraViewToTranslatedWorld = View.CameraViewToTranslatedWorld;
	Result.ViewToClip = View.ViewToClip;
	Result.ViewToClipNoAA = View.ViewToClipNoAA;
	Result.ClipToView = View.ClipToView;
	Result.ClipToTranslatedWorld = View.ClipToTranslatedWorld;
	Result.SVPositionToTranslatedWorld = View.SVPositionToTranslatedWorld;
	Result.ScreenToRelativeWorld = View.ScreenToRelativeWorld;
	Result.ScreenToTranslatedWorld = View.ScreenToTranslatedWorld;
	Result.MobileMultiviewShadowTransform = View.MobileMultiviewShadowTransform;
	Result.ViewTilePosition = View.ViewTilePosition;
	Result.MatrixTilePosition = View.MatrixTilePosition;
	Result.ViewForward = View.ViewForward;
	Result.ViewUp = View.ViewUp;
	Result.ViewRight = View.ViewRight;
	Result.HMDViewNoRollUp = View.HMDViewNoRollUp;
	Result.HMDViewNoRollRight = View.HMDViewNoRollRight;
	Result.InvDeviceZToWorldZTransform = View.InvDeviceZToWorldZTransform;
	Result.ScreenPositionScaleBias = View.ScreenPositionScaleBias;
	Result.RelativeWorldCameraOrigin = View.RelativeWorldCameraOrigin;
	Result.TranslatedWorldCameraOrigin = View.TranslatedWorldCameraOrigin;
	Result.RelativeWorldViewOrigin = View.RelativeWorldViewOrigin;
	Result.RelativePreViewTranslation = View.RelativePreViewTranslation;
	Result.PrevViewToClip = View.PrevViewToClip;
	Result.PrevClipToView = View.PrevClipToView;
	Result.PrevTranslatedWorldToClip = View.PrevTranslatedWorldToClip;
	Result.PrevTranslatedWorldToView = View.PrevTranslatedWorldToView;
	Result.PrevViewToTranslatedWorld = View.PrevViewToTranslatedWorld;
	Result.PrevTranslatedWorldToCameraView = View.PrevTranslatedWorldToCameraView;
	Result.PrevCameraViewToTranslatedWorld = View.PrevCameraViewToTranslatedWorld;
	Result.PrevTranslatedWorldCameraOrigin = View.PrevTranslatedWorldCameraOrigin;
	Result.PrevRelativeWorldCameraOrigin = View.PrevRelativeWorldCameraOrigin;
	Result.PrevRelativeWorldViewOrigin = View.PrevRelativeWorldViewOrigin;
	Result.RelativePrevPreViewTranslation = View.RelativePrevPreViewTranslation;
	Result.PrevClipToRelativeWorld = View.PrevClipToRelativeWorld;
	Result.PrevScreenToTranslatedWorld = View.PrevScreenToTranslatedWorld;
	Result.ClipToPrevClip = View.ClipToPrevClip;
	Result.ClipToPrevClipWithAA = View.ClipToPrevClipWithAA;
	Result.TemporalAAJitter = View.TemporalAAJitter;
	Result.GlobalClippingPlane = View.GlobalClippingPlane;
	Result.FieldOfViewWideAngles = View.FieldOfViewWideAngles;
	Result.PrevFieldOfViewWideAngles = View.PrevFieldOfViewWideAngles;
	Result.ViewRectMin = View.ViewRectMin;
	Result.ViewSizeAndInvSize = View.ViewSizeAndInvSize;
	Result.ViewRectMinAndSize = View.ViewRectMinAndSize;
	Result.LightProbeSizeRatioAndInvSizeRatio = View.LightProbeSizeRatioAndInvSizeRatio;
	Result.BufferSizeAndInvSize = View.BufferSizeAndInvSize;
	Result.BufferBilinearUVMinMax = View.BufferBilinearUVMinMax;
	Result.ScreenToViewSpace = View.ScreenToViewSpace;
	Result.BufferToSceneTextureScale = View.BufferToSceneTextureScale;
	Result.ResolutionFractionAndInv = View.ResolutionFractionAndInv;
	Result.NumSceneColorMSAASamples = View.NumSceneColorMSAASamples;
	Result.SeparateWaterMainDirLightLuminance = View.SeparateWaterMainDirLightLuminance;
	Result.PreExposure = View.PreExposure;
	Result.OneOverPreExposure = View.OneOverPreExposure;
	Result.DiffuseOverrideParameter = View.DiffuseOverrideParameter;
	Result.SpecularOverrideParameter = View.SpecularOverrideParameter;
	Result.NormalOverrideParameter = View.NormalOverrideParameter;
	Result.RoughnessOverrideParameter = View.RoughnessOverrideParameter;
	Result.PrevFrameGameTime = View.PrevFrameGameTime;
	Result.PrevFrameRealTime = View.PrevFrameRealTime;
	Result.OutOfBoundsMask = View.OutOfBoundsMask;
	Result.WorldCameraMovementSinceLastFrame = View.WorldCameraMovementSinceLastFrame;
	Result.CullingSign = View.CullingSign;
	Result.NearPlane = View.NearPlane;
	Result.GameTime = View.GameTime;
	Result.RealTime = View.RealTime;
	Result.DeltaTime = View.DeltaTime;
	Result.MaterialTextureMipBias = View.MaterialTextureMipBias;
	Result.MaterialTextureDerivativeMultiply = View.MaterialTextureDerivativeMultiply;
	Result.Random = View.Random;
	Result.FrameNumber = View.FrameNumber;
	Result.StateFrameIndexMod8 = View.StateFrameIndexMod8;
	Result.StateFrameIndex = View.StateFrameIndex;
	Result.DebugViewModeMask = View.DebugViewModeMask;
	Result.CameraCut = View.CameraCut;
	Result.UnlitViewmodeMask = View.UnlitViewmodeMask;
	Result.DirectionalLightColor = View.DirectionalLightColor;
	Result.DirectionalLightDirection = View.DirectionalLightDirection;
	Result.TranslucencyLightingVolumeMin = View.TranslucencyLightingVolumeMin;
	Result.TranslucencyLightingVolumeInvSize = View.TranslucencyLightingVolumeInvSize;
	Result.TemporalAAParams = View.TemporalAAParams;
	Result.CircleDOFParams = View.CircleDOFParams;
	Result.DepthOfFieldSensorWidth = View.DepthOfFieldSensorWidth;
	Result.DepthOfFieldFocalDistance = View.DepthOfFieldFocalDistance;
	Result.DepthOfFieldScale = View.DepthOfFieldScale;
	Result.DepthOfFieldFocalLength = View.DepthOfFieldFocalLength;
	Result.DepthOfFieldFocalRegion = View.DepthOfFieldFocalRegion;
	Result.DepthOfFieldNearTransitionRegion = View.DepthOfFieldNearTransitionRegion;
	Result.DepthOfFieldFarTransitionRegion = View.DepthOfFieldFarTransitionRegion;
	Result.MotionBlurNormalizedToPixel = View.MotionBlurNormalizedToPixel;
	Result.GeneralPurposeTweak = View.GeneralPurposeTweak;
	Result.GeneralPurposeTweak2 = View.GeneralPurposeTweak2;
	Result.DemosaicVposOffset = View.DemosaicVposOffset;
	Result.DecalDepthBias = View.DecalDepthBias;
	Result.IndirectLightingColorScale = View.IndirectLightingColorScale;
	Result.PrecomputedIndirectLightingColorScale = View.PrecomputedIndirectLightingColorScale;
	Result.PrecomputedIndirectSpecularColorScale = View.PrecomputedIndirectSpecularColorScale;
	Result.AtmosphereLightDirection = View.AtmosphereLightDirection;
	Result.AtmosphereLightIlluminanceOnGroundPostTransmittance = View.AtmosphereLightIlluminanceOnGroundPostTransmittance;
	Result.AtmosphereLightIlluminanceOuterSpace = View.AtmosphereLightIlluminanceOuterSpace;
	Result.AtmosphereLightDiscLuminance = View.AtmosphereLightDiscLuminance;
	Result.AtmosphereLightDiscCosHalfApexAngle_PPTrans = View.AtmosphereLightDiscCosHalfApexAngle_PPTrans;
	Result.SkyViewLutSizeAndInvSize = View.SkyViewLutSizeAndInvSize;
	Result.SkyCameraTranslatedWorldOrigin = View.SkyCameraTranslatedWorldOrigin;
	Result.SkyPlanetTranslatedWorldCenterAndViewHeight = View.SkyPlanetTranslatedWorldCenterAndViewHeight;
	Result.SkyViewLutReferential = View.SkyViewLutReferential;
	Result.SkyAtmosphereSkyLuminanceFactor = View.SkyAtmosphereSkyLuminanceFactor;
	Result.SkyAtmospherePresentInScene = View.SkyAtmospherePresentInScene;
	Result.SkyAtmosphereHeightFogContribution = View.SkyAtmosphereHeightFogContribution;
	Result.SkyAtmosphereBottomRadiusKm = View.SkyAtmosphereBottomRadiusKm;
	Result.SkyAtmosphereTopRadiusKm = View.SkyAtmosphereTopRadiusKm;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize = View.SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize;
	Result.SkyAtmosphereAerialPerspectiveStartDepthKm = View.SkyAtmosphereAerialPerspectiveStartDepthKm;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution = View.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv = View.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm = View.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv = View.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv;
	Result.SkyAtmosphereApplyCameraAerialPerspectiveVolume = View.SkyAtmosphereApplyCameraAerialPerspectiveVolume;
	Result.NormalCurvatureToRoughnessScaleBias = View.NormalCurvatureToRoughnessScaleBias;
	Result.RenderingReflectionCaptureMask = View.RenderingReflectionCaptureMask;
	Result.RealTimeReflectionCapture = View.RealTimeReflectionCapture;
	Result.RealTimeReflectionCapturePreExposure = View.RealTimeReflectionCapturePreExposure;
	Result.AmbientCubemapTint = View.AmbientCubemapTint;
	Result.AmbientCubemapIntensity = View.AmbientCubemapIntensity;
	Result.SkyLightApplyPrecomputedBentNormalShadowingFlag = View.SkyLightApplyPrecomputedBentNormalShadowingFlag;
	Result.SkyLightAffectReflectionFlag = View.SkyLightAffectReflectionFlag;
	Result.SkyLightAffectGlobalIlluminationFlag = View.SkyLightAffectGlobalIlluminationFlag;
	Result.SkyLightColor = View.SkyLightColor;
	Result.MobileSkyIrradianceEnvironmentMap = View.MobileSkyIrradianceEnvironmentMap;
	Result.MobilePreviewMode = View.MobilePreviewMode;
	Result.HMDEyePaddingOffset = View.HMDEyePaddingOffset;
	Result.ReflectionCubemapMaxMip = View.ReflectionCubemapMaxMip;
	Result.ShowDecalsMask = View.ShowDecalsMask;
	Result.DistanceFieldAOSpecularOcclusionMode = View.DistanceFieldAOSpecularOcclusionMode;
	Result.IndirectCapsuleSelfShadowingIntensity = View.IndirectCapsuleSelfShadowingIntensity;
	Result.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight = View.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	Result.StereoPassIndex = View.StereoPassIndex;
	Result.GlobalVolumeCenterAndExtent = View.GlobalVolumeCenterAndExtent;
	Result.GlobalVolumeWorldToUVAddAndMul = View.GlobalVolumeWorldToUVAddAndMul;
	Result.GlobalDistanceFieldMipWorldToUVScale = View.GlobalDistanceFieldMipWorldToUVScale;
	Result.GlobalDistanceFieldMipWorldToUVBias = View.GlobalDistanceFieldMipWorldToUVBias;
	Result.GlobalDistanceFieldMipFactor = View.GlobalDistanceFieldMipFactor;
	Result.GlobalDistanceFieldMipTransition = View.GlobalDistanceFieldMipTransition;
	Result.GlobalDistanceFieldClipmapSizeInPages = View.GlobalDistanceFieldClipmapSizeInPages;
	Result.GlobalDistanceFieldInvPageAtlasSize = View.GlobalDistanceFieldInvPageAtlasSize;
	Result.GlobalDistanceFieldInvCoverageAtlasSize = View.GlobalDistanceFieldInvCoverageAtlasSize;
	Result.GlobalVolumeDimension = View.GlobalVolumeDimension;
	Result.GlobalVolumeTexelSize = View.GlobalVolumeTexelSize;
	Result.MaxGlobalDFAOConeDistance = View.MaxGlobalDFAOConeDistance;
	Result.NumGlobalSDFClipmaps = View.NumGlobalSDFClipmaps;
	Result.CoveredExpandSurfaceScale = View.CoveredExpandSurfaceScale;
	Result.NotCoveredExpandSurfaceScale = View.NotCoveredExpandSurfaceScale;
	Result.NotCoveredMinStepScale = View.NotCoveredMinStepScale;
	Result.DitheredTransparencyStepThreshold = View.DitheredTransparencyStepThreshold;
	Result.DitheredTransparencyTraceThreshold = View.DitheredTransparencyTraceThreshold;
	Result.CursorPosition = View.CursorPosition;
	Result.bCheckerboardSubsurfaceProfileRendering = View.bCheckerboardSubsurfaceProfileRendering;
	Result.VolumetricFogInvGridSize = View.VolumetricFogInvGridSize;
	Result.VolumetricFogGridZParams = View.VolumetricFogGridZParams;
	Result.VolumetricFogSVPosToVolumeUV = View.VolumetricFogSVPosToVolumeUV;
	Result.VolumetricFogMaxDistance = View.VolumetricFogMaxDistance;
	Result.VolumetricLightmapWorldToUVScale = View.VolumetricLightmapWorldToUVScale;
	Result.VolumetricLightmapWorldToUVAdd = View.VolumetricLightmapWorldToUVAdd;
	Result.VolumetricLightmapIndirectionTextureSize = View.VolumetricLightmapIndirectionTextureSize;
	Result.VolumetricLightmapBrickSize = View.VolumetricLightmapBrickSize;
	Result.VolumetricLightmapBrickTexelSize = View.VolumetricLightmapBrickTexelSize;
	Result.IndirectLightingCacheShowFlag = View.IndirectLightingCacheShowFlag;
	Result.EyeToPixelSpreadAngle = View.EyeToPixelSpreadAngle;
	Result.XRPassthroughCameraUVs = View.XRPassthroughCameraUVs;
	Result.GlobalVirtualTextureMipBias = View.GlobalVirtualTextureMipBias;
	Result.VirtualTextureFeedbackShift = View.VirtualTextureFeedbackShift;
	Result.VirtualTextureFeedbackMask = View.VirtualTextureFeedbackMask;
	Result.VirtualTextureFeedbackStride = View.VirtualTextureFeedbackStride;
	Result.VirtualTextureFeedbackJitterOffset = View.VirtualTextureFeedbackJitterOffset;
	Result.VirtualTextureFeedbackSampleOffset = View.VirtualTextureFeedbackSampleOffset;
	Result.RuntimeVirtualTextureMipLevel = View.RuntimeVirtualTextureMipLevel;
	Result.RuntimeVirtualTexturePackHeight = View.RuntimeVirtualTexturePackHeight;
	Result.RuntimeVirtualTextureDebugParams = View.RuntimeVirtualTextureDebugParams;
	Result.OverrideLandscapeLOD = View.OverrideLandscapeLOD;
	Result.FarShadowStaticMeshLODBias = View.FarShadowStaticMeshLODBias;
	Result.MinRoughness = View.MinRoughness;
	Result.HairRenderInfo = View.HairRenderInfo;
	Result.EnableSkyLight = View.EnableSkyLight;
	Result.HairRenderInfoBits = View.HairRenderInfoBits;
	Result.HairComponents = View.HairComponents;
	Result.bSubsurfacePostprocessEnabled = View.bSubsurfacePostprocessEnabled;
	Result.SSProfilesTextureSizeAndInvSize = View.SSProfilesTextureSizeAndInvSize;
	Result.SSProfilesPreIntegratedTextureSizeAndInvSize = View.SSProfilesPreIntegratedTextureSizeAndInvSize;
	Result.PhysicsFieldClipmapCenter = View.PhysicsFieldClipmapCenter;
	Result.PhysicsFieldClipmapDistance = View.PhysicsFieldClipmapDistance;
	Result.PhysicsFieldClipmapResolution = View.PhysicsFieldClipmapResolution;
	Result.PhysicsFieldClipmapExponent = View.PhysicsFieldClipmapExponent;
	Result.PhysicsFieldClipmapCount = View.PhysicsFieldClipmapCount;
	Result.PhysicsFieldTargetCount = View.PhysicsFieldTargetCount;
	Result.PhysicsFieldTargets = View.PhysicsFieldTargets;
	Result.InstanceSceneDataSOAStride = View.InstanceSceneDataSOAStride;
	Result.GPUSceneViewId = View.GPUSceneViewId;
	Result.ViewResolutionFraction = View.ViewResolutionFraction;
	Result.SubSurfaceColorAsTransmittanceAtDistanceInMeters = View.SubSurfaceColorAsTransmittanceAtDistanceInMeters;
	FinalizeViewState(Result);
	return Result;
}
ViewState GetInstancedView()
{
	ViewState Result;
	Result.TranslatedWorldToClip = InstancedView.TranslatedWorldToClip;
	Result.TranslatedWorldToSubpixelClip = InstancedView.TranslatedWorldToSubpixelClip;
	Result.RelativeWorldToClip = InstancedView.RelativeWorldToClip;
	Result.ClipToRelativeWorld = InstancedView.ClipToRelativeWorld;
	Result.TranslatedWorldToView = InstancedView.TranslatedWorldToView;
	Result.ViewToTranslatedWorld = InstancedView.ViewToTranslatedWorld;
	Result.TranslatedWorldToCameraView = InstancedView.TranslatedWorldToCameraView;
	Result.CameraViewToTranslatedWorld = InstancedView.CameraViewToTranslatedWorld;
	Result.ViewToClip = InstancedView.ViewToClip;
	Result.ViewToClipNoAA = InstancedView.ViewToClipNoAA;
	Result.ClipToView = InstancedView.ClipToView;
	Result.ClipToTranslatedWorld = InstancedView.ClipToTranslatedWorld;
	Result.SVPositionToTranslatedWorld = InstancedView.SVPositionToTranslatedWorld;
	Result.ScreenToRelativeWorld = InstancedView.ScreenToRelativeWorld;
	Result.ScreenToTranslatedWorld = InstancedView.ScreenToTranslatedWorld;
	Result.MobileMultiviewShadowTransform = InstancedView.MobileMultiviewShadowTransform;
	Result.ViewTilePosition = InstancedView.ViewTilePosition;
	Result.MatrixTilePosition = InstancedView.MatrixTilePosition;
	Result.ViewForward = InstancedView.ViewForward;
	Result.ViewUp = InstancedView.ViewUp;
	Result.ViewRight = InstancedView.ViewRight;
	Result.HMDViewNoRollUp = InstancedView.HMDViewNoRollUp;
	Result.HMDViewNoRollRight = InstancedView.HMDViewNoRollRight;
	Result.InvDeviceZToWorldZTransform = InstancedView.InvDeviceZToWorldZTransform;
	Result.ScreenPositionScaleBias = InstancedView.ScreenPositionScaleBias;
	Result.RelativeWorldCameraOrigin = InstancedView.RelativeWorldCameraOrigin;
	Result.TranslatedWorldCameraOrigin = InstancedView.TranslatedWorldCameraOrigin;
	Result.RelativeWorldViewOrigin = InstancedView.RelativeWorldViewOrigin;
	Result.RelativePreViewTranslation = InstancedView.RelativePreViewTranslation;
	Result.PrevViewToClip = InstancedView.PrevViewToClip;
	Result.PrevClipToView = InstancedView.PrevClipToView;
	Result.PrevTranslatedWorldToClip = InstancedView.PrevTranslatedWorldToClip;
	Result.PrevTranslatedWorldToView = InstancedView.PrevTranslatedWorldToView;
	Result.PrevViewToTranslatedWorld = InstancedView.PrevViewToTranslatedWorld;
	Result.PrevTranslatedWorldToCameraView = InstancedView.PrevTranslatedWorldToCameraView;
	Result.PrevCameraViewToTranslatedWorld = InstancedView.PrevCameraViewToTranslatedWorld;
	Result.PrevTranslatedWorldCameraOrigin = InstancedView.PrevTranslatedWorldCameraOrigin;
	Result.PrevRelativeWorldCameraOrigin = InstancedView.PrevRelativeWorldCameraOrigin;
	Result.PrevRelativeWorldViewOrigin = InstancedView.PrevRelativeWorldViewOrigin;
	Result.RelativePrevPreViewTranslation = InstancedView.RelativePrevPreViewTranslation;
	Result.PrevClipToRelativeWorld = InstancedView.PrevClipToRelativeWorld;
	Result.PrevScreenToTranslatedWorld = InstancedView.PrevScreenToTranslatedWorld;
	Result.ClipToPrevClip = InstancedView.ClipToPrevClip;
	Result.ClipToPrevClipWithAA = InstancedView.ClipToPrevClipWithAA;
	Result.TemporalAAJitter = InstancedView.TemporalAAJitter;
	Result.GlobalClippingPlane = InstancedView.GlobalClippingPlane;
	Result.FieldOfViewWideAngles = InstancedView.FieldOfViewWideAngles;
	Result.PrevFieldOfViewWideAngles = InstancedView.PrevFieldOfViewWideAngles;
	Result.ViewRectMin = InstancedView.ViewRectMin;
	Result.ViewSizeAndInvSize = InstancedView.ViewSizeAndInvSize;
	Result.ViewRectMinAndSize = InstancedView.ViewRectMinAndSize;
	Result.LightProbeSizeRatioAndInvSizeRatio = InstancedView.LightProbeSizeRatioAndInvSizeRatio;
	Result.BufferSizeAndInvSize = InstancedView.BufferSizeAndInvSize;
	Result.BufferBilinearUVMinMax = InstancedView.BufferBilinearUVMinMax;
	Result.ScreenToViewSpace = InstancedView.ScreenToViewSpace;
	Result.BufferToSceneTextureScale = InstancedView.BufferToSceneTextureScale;
	Result.ResolutionFractionAndInv = InstancedView.ResolutionFractionAndInv;
	Result.NumSceneColorMSAASamples = InstancedView.NumSceneColorMSAASamples;
	Result.SeparateWaterMainDirLightLuminance = InstancedView.SeparateWaterMainDirLightLuminance;
	Result.PreExposure = InstancedView.PreExposure;
	Result.OneOverPreExposure = InstancedView.OneOverPreExposure;
	Result.DiffuseOverrideParameter = InstancedView.DiffuseOverrideParameter;
	Result.SpecularOverrideParameter = InstancedView.SpecularOverrideParameter;
	Result.NormalOverrideParameter = InstancedView.NormalOverrideParameter;
	Result.RoughnessOverrideParameter = InstancedView.RoughnessOverrideParameter;
	Result.PrevFrameGameTime = InstancedView.PrevFrameGameTime;
	Result.PrevFrameRealTime = InstancedView.PrevFrameRealTime;
	Result.OutOfBoundsMask = InstancedView.OutOfBoundsMask;
	Result.WorldCameraMovementSinceLastFrame = InstancedView.WorldCameraMovementSinceLastFrame;
	Result.CullingSign = InstancedView.CullingSign;
	Result.NearPlane = InstancedView.NearPlane;
	Result.GameTime = InstancedView.GameTime;
	Result.RealTime = InstancedView.RealTime;
	Result.DeltaTime = InstancedView.DeltaTime;
	Result.MaterialTextureMipBias = InstancedView.MaterialTextureMipBias;
	Result.MaterialTextureDerivativeMultiply = InstancedView.MaterialTextureDerivativeMultiply;
	Result.Random = InstancedView.Random;
	Result.FrameNumber = InstancedView.FrameNumber;
	Result.StateFrameIndexMod8 = InstancedView.StateFrameIndexMod8;
	Result.StateFrameIndex = InstancedView.StateFrameIndex;
	Result.DebugViewModeMask = InstancedView.DebugViewModeMask;
	Result.CameraCut = InstancedView.CameraCut;
	Result.UnlitViewmodeMask = InstancedView.UnlitViewmodeMask;
	Result.DirectionalLightColor = InstancedView.DirectionalLightColor;
	Result.DirectionalLightDirection = InstancedView.DirectionalLightDirection;
	Result.TranslucencyLightingVolumeMin = InstancedView.TranslucencyLightingVolumeMin;
	Result.TranslucencyLightingVolumeInvSize = InstancedView.TranslucencyLightingVolumeInvSize;
	Result.TemporalAAParams = InstancedView.TemporalAAParams;
	Result.CircleDOFParams = InstancedView.CircleDOFParams;
	Result.DepthOfFieldSensorWidth = InstancedView.DepthOfFieldSensorWidth;
	Result.DepthOfFieldFocalDistance = InstancedView.DepthOfFieldFocalDistance;
	Result.DepthOfFieldScale = InstancedView.DepthOfFieldScale;
	Result.DepthOfFieldFocalLength = InstancedView.DepthOfFieldFocalLength;
	Result.DepthOfFieldFocalRegion = InstancedView.DepthOfFieldFocalRegion;
	Result.DepthOfFieldNearTransitionRegion = InstancedView.DepthOfFieldNearTransitionRegion;
	Result.DepthOfFieldFarTransitionRegion = InstancedView.DepthOfFieldFarTransitionRegion;
	Result.MotionBlurNormalizedToPixel = InstancedView.MotionBlurNormalizedToPixel;
	Result.GeneralPurposeTweak = InstancedView.GeneralPurposeTweak;
	Result.GeneralPurposeTweak2 = InstancedView.GeneralPurposeTweak2;
	Result.DemosaicVposOffset = InstancedView.DemosaicVposOffset;
	Result.DecalDepthBias = InstancedView.DecalDepthBias;
	Result.IndirectLightingColorScale = InstancedView.IndirectLightingColorScale;
	Result.PrecomputedIndirectLightingColorScale = InstancedView.PrecomputedIndirectLightingColorScale;
	Result.PrecomputedIndirectSpecularColorScale = InstancedView.PrecomputedIndirectSpecularColorScale;
	Result.AtmosphereLightDirection = InstancedView.AtmosphereLightDirection;
	Result.AtmosphereLightIlluminanceOnGroundPostTransmittance = InstancedView.AtmosphereLightIlluminanceOnGroundPostTransmittance;
	Result.AtmosphereLightIlluminanceOuterSpace = InstancedView.AtmosphereLightIlluminanceOuterSpace;
	Result.AtmosphereLightDiscLuminance = InstancedView.AtmosphereLightDiscLuminance;
	Result.AtmosphereLightDiscCosHalfApexAngle_PPTrans = InstancedView.AtmosphereLightDiscCosHalfApexAngle_PPTrans;
	Result.SkyViewLutSizeAndInvSize = InstancedView.SkyViewLutSizeAndInvSize;
	Result.SkyCameraTranslatedWorldOrigin = InstancedView.SkyCameraTranslatedWorldOrigin;
	Result.SkyPlanetTranslatedWorldCenterAndViewHeight = InstancedView.SkyPlanetTranslatedWorldCenterAndViewHeight;
	Result.SkyViewLutReferential = InstancedView.SkyViewLutReferential;
	Result.SkyAtmosphereSkyLuminanceFactor = InstancedView.SkyAtmosphereSkyLuminanceFactor;
	Result.SkyAtmospherePresentInScene = InstancedView.SkyAtmospherePresentInScene;
	Result.SkyAtmosphereHeightFogContribution = InstancedView.SkyAtmosphereHeightFogContribution;
	Result.SkyAtmosphereBottomRadiusKm = InstancedView.SkyAtmosphereBottomRadiusKm;
	Result.SkyAtmosphereTopRadiusKm = InstancedView.SkyAtmosphereTopRadiusKm;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize = InstancedView.SkyAtmosphereCameraAerialPerspectiveVolumeSizeAndInvSize;
	Result.SkyAtmosphereAerialPerspectiveStartDepthKm = InstancedView.SkyAtmosphereAerialPerspectiveStartDepthKm;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution = InstancedView.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolution;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv = InstancedView.SkyAtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm = InstancedView.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm;
	Result.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv = InstancedView.SkyAtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKmInv;
	Result.SkyAtmosphereApplyCameraAerialPerspectiveVolume = InstancedView.SkyAtmosphereApplyCameraAerialPerspectiveVolume;
	Result.NormalCurvatureToRoughnessScaleBias = InstancedView.NormalCurvatureToRoughnessScaleBias;
	Result.RenderingReflectionCaptureMask = InstancedView.RenderingReflectionCaptureMask;
	Result.RealTimeReflectionCapture = InstancedView.RealTimeReflectionCapture;
	Result.RealTimeReflectionCapturePreExposure = InstancedView.RealTimeReflectionCapturePreExposure;
	Result.AmbientCubemapTint = InstancedView.AmbientCubemapTint;
	Result.AmbientCubemapIntensity = InstancedView.AmbientCubemapIntensity;
	Result.SkyLightApplyPrecomputedBentNormalShadowingFlag = InstancedView.SkyLightApplyPrecomputedBentNormalShadowingFlag;
	Result.SkyLightAffectReflectionFlag = InstancedView.SkyLightAffectReflectionFlag;
	Result.SkyLightAffectGlobalIlluminationFlag = InstancedView.SkyLightAffectGlobalIlluminationFlag;
	Result.SkyLightColor = InstancedView.SkyLightColor;
	Result.MobileSkyIrradianceEnvironmentMap = InstancedView.MobileSkyIrradianceEnvironmentMap;
	Result.MobilePreviewMode = InstancedView.MobilePreviewMode;
	Result.HMDEyePaddingOffset = InstancedView.HMDEyePaddingOffset;
	Result.ReflectionCubemapMaxMip = InstancedView.ReflectionCubemapMaxMip;
	Result.ShowDecalsMask = InstancedView.ShowDecalsMask;
	Result.DistanceFieldAOSpecularOcclusionMode = InstancedView.DistanceFieldAOSpecularOcclusionMode;
	Result.IndirectCapsuleSelfShadowingIntensity = InstancedView.IndirectCapsuleSelfShadowingIntensity;
	Result.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight = InstancedView.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	Result.StereoPassIndex = InstancedView.StereoPassIndex;
	Result.GlobalVolumeCenterAndExtent = InstancedView.GlobalVolumeCenterAndExtent;
	Result.GlobalVolumeWorldToUVAddAndMul = InstancedView.GlobalVolumeWorldToUVAddAndMul;
	Result.GlobalDistanceFieldMipWorldToUVScale = InstancedView.GlobalDistanceFieldMipWorldToUVScale;
	Result.GlobalDistanceFieldMipWorldToUVBias = InstancedView.GlobalDistanceFieldMipWorldToUVBias;
	Result.GlobalDistanceFieldMipFactor = InstancedView.GlobalDistanceFieldMipFactor;
	Result.GlobalDistanceFieldMipTransition = InstancedView.GlobalDistanceFieldMipTransition;
	Result.GlobalDistanceFieldClipmapSizeInPages = InstancedView.GlobalDistanceFieldClipmapSizeInPages;
	Result.GlobalDistanceFieldInvPageAtlasSize = InstancedView.GlobalDistanceFieldInvPageAtlasSize;
	Result.GlobalDistanceFieldInvCoverageAtlasSize = InstancedView.GlobalDistanceFieldInvCoverageAtlasSize;
	Result.GlobalVolumeDimension = InstancedView.GlobalVolumeDimension;
	Result.GlobalVolumeTexelSize = InstancedView.GlobalVolumeTexelSize;
	Result.MaxGlobalDFAOConeDistance = InstancedView.MaxGlobalDFAOConeDistance;
	Result.NumGlobalSDFClipmaps = InstancedView.NumGlobalSDFClipmaps;
	Result.CoveredExpandSurfaceScale = InstancedView.CoveredExpandSurfaceScale;
	Result.NotCoveredExpandSurfaceScale = InstancedView.NotCoveredExpandSurfaceScale;
	Result.NotCoveredMinStepScale = InstancedView.NotCoveredMinStepScale;
	Result.DitheredTransparencyStepThreshold = InstancedView.DitheredTransparencyStepThreshold;
	Result.DitheredTransparencyTraceThreshold = InstancedView.DitheredTransparencyTraceThreshold;
	Result.CursorPosition = InstancedView.CursorPosition;
	Result.bCheckerboardSubsurfaceProfileRendering = InstancedView.bCheckerboardSubsurfaceProfileRendering;
	Result.VolumetricFogInvGridSize = InstancedView.VolumetricFogInvGridSize;
	Result.VolumetricFogGridZParams = InstancedView.VolumetricFogGridZParams;
	Result.VolumetricFogSVPosToVolumeUV = InstancedView.VolumetricFogSVPosToVolumeUV;
	Result.VolumetricFogMaxDistance = InstancedView.VolumetricFogMaxDistance;
	Result.VolumetricLightmapWorldToUVScale = InstancedView.VolumetricLightmapWorldToUVScale;
	Result.VolumetricLightmapWorldToUVAdd = InstancedView.VolumetricLightmapWorldToUVAdd;
	Result.VolumetricLightmapIndirectionTextureSize = InstancedView.VolumetricLightmapIndirectionTextureSize;
	Result.VolumetricLightmapBrickSize = InstancedView.VolumetricLightmapBrickSize;
	Result.VolumetricLightmapBrickTexelSize = InstancedView.VolumetricLightmapBrickTexelSize;
	Result.IndirectLightingCacheShowFlag = InstancedView.IndirectLightingCacheShowFlag;
	Result.EyeToPixelSpreadAngle = InstancedView.EyeToPixelSpreadAngle;
	Result.XRPassthroughCameraUVs = InstancedView.XRPassthroughCameraUVs;
	Result.GlobalVirtualTextureMipBias = InstancedView.GlobalVirtualTextureMipBias;
	Result.VirtualTextureFeedbackShift = InstancedView.VirtualTextureFeedbackShift;
	Result.VirtualTextureFeedbackMask = InstancedView.VirtualTextureFeedbackMask;
	Result.VirtualTextureFeedbackStride = InstancedView.VirtualTextureFeedbackStride;
	Result.VirtualTextureFeedbackJitterOffset = InstancedView.VirtualTextureFeedbackJitterOffset;
	Result.VirtualTextureFeedbackSampleOffset = InstancedView.VirtualTextureFeedbackSampleOffset;
	Result.RuntimeVirtualTextureMipLevel = InstancedView.RuntimeVirtualTextureMipLevel;
	Result.RuntimeVirtualTexturePackHeight = InstancedView.RuntimeVirtualTexturePackHeight;
	Result.RuntimeVirtualTextureDebugParams = InstancedView.RuntimeVirtualTextureDebugParams;
	Result.OverrideLandscapeLOD = InstancedView.OverrideLandscapeLOD;
	Result.FarShadowStaticMeshLODBias = InstancedView.FarShadowStaticMeshLODBias;
	Result.MinRoughness = InstancedView.MinRoughness;
	Result.HairRenderInfo = InstancedView.HairRenderInfo;
	Result.EnableSkyLight = InstancedView.EnableSkyLight;
	Result.HairRenderInfoBits = InstancedView.HairRenderInfoBits;
	Result.HairComponents = InstancedView.HairComponents;
	Result.bSubsurfacePostprocessEnabled = InstancedView.bSubsurfacePostprocessEnabled;
	Result.SSProfilesTextureSizeAndInvSize = InstancedView.SSProfilesTextureSizeAndInvSize;
	Result.SSProfilesPreIntegratedTextureSizeAndInvSize = InstancedView.SSProfilesPreIntegratedTextureSizeAndInvSize;
	Result.PhysicsFieldClipmapCenter = InstancedView.PhysicsFieldClipmapCenter;
	Result.PhysicsFieldClipmapDistance = InstancedView.PhysicsFieldClipmapDistance;
	Result.PhysicsFieldClipmapResolution = InstancedView.PhysicsFieldClipmapResolution;
	Result.PhysicsFieldClipmapExponent = InstancedView.PhysicsFieldClipmapExponent;
	Result.PhysicsFieldClipmapCount = InstancedView.PhysicsFieldClipmapCount;
	Result.PhysicsFieldTargetCount = InstancedView.PhysicsFieldTargetCount;
	Result.PhysicsFieldTargets = InstancedView.PhysicsFieldTargets;
	Result.InstanceSceneDataSOAStride = InstancedView.InstanceSceneDataSOAStride;
	Result.GPUSceneViewId = InstancedView.GPUSceneViewId;
	Result.ViewResolutionFraction = InstancedView.ViewResolutionFraction;
	Result.SubSurfaceColorAsTransmittanceAtDistanceInMeters = InstancedView.SubSurfaceColorAsTransmittanceAtDistanceInMeters;
	FinalizeViewState(Result);
	return Result;
}
#line 16 "/Engine/Private/InstancedStereo.ush"

void FinalizeViewState(inout ViewState InOutView)
{
	InOutView.WorldToClip = MakeLWCInverseMatrix(InOutView.MatrixTilePosition, InOutView.RelativeWorldToClip);
	InOutView.ClipToWorld = MakeLWCMatrix(InOutView.MatrixTilePosition, InOutView.ClipToRelativeWorld);
	InOutView.ScreenToWorld = MakeLWCMatrix(InOutView.MatrixTilePosition, InOutView.ScreenToRelativeWorld);
	InOutView.PrevClipToWorld = MakeLWCMatrix(InOutView.MatrixTilePosition, InOutView.PrevClipToRelativeWorld);

	InOutView.WorldCameraOrigin = MakeLWCVector3(InOutView.ViewTilePosition, InOutView.RelativeWorldCameraOrigin);
	InOutView.WorldViewOrigin = MakeLWCVector3(InOutView.ViewTilePosition, InOutView.RelativeWorldViewOrigin);
	InOutView.PrevWorldCameraOrigin = MakeLWCVector3(InOutView.ViewTilePosition, InOutView.PrevRelativeWorldCameraOrigin);
	InOutView.PrevWorldViewOrigin = MakeLWCVector3(InOutView.ViewTilePosition, InOutView.PrevRelativeWorldViewOrigin);
	InOutView.PreViewTranslation = MakeLWCVector3(-InOutView.ViewTilePosition, InOutView.RelativePreViewTranslation);
	InOutView.PrevPreViewTranslation = MakeLWCVector3(-InOutView.ViewTilePosition, InOutView.RelativePrevPreViewTranslation);
}



static ViewState ResolvedView = (ViewState)0.0f;

ViewState ResolveView()
{
	return GetPrimaryView();
}
#line 61 "/Engine/Private/InstancedStereo.ush"
bool IsInstancedStereo()
{



	return false;

}

uint GetEyeIndex(uint InstanceId)
{



	return 0;

}

uint GetInstanceId(uint InstanceId)
{



	return InstanceId;

}
#line 204 "/Engine/Private/Common.ush"
#line 205 "/Engine/Private/Common.ush"
#line 1 "Definitions.usf"
#line 206 "/Engine/Private/Common.ush"
#line 207 "/Engine/Private/Common.ush"
#line 1 "AssertionMacros.ush"
#line 208 "/Engine/Private/Common.ush"
#line 246 "/Engine/Private/Common.ush"
static float GlobalTextureMipBias = 0;
static float GlobalRayCone_TexArea = 0;
float ComputeRayConeLod(Texture2D Tex)
{






    return  0.0f ;

}

float ClampToHalfFloatRange(float X) { return clamp(X, float(0), MaxHalfFloat); }
float2 ClampToHalfFloatRange(float2 X) { return clamp(X, float(0).xx, MaxHalfFloat.xx); }
float3 ClampToHalfFloatRange(float3 X) { return clamp(X, float(0).xxx, MaxHalfFloat.xxx); }
float4 ClampToHalfFloatRange(float4 X) { return clamp(X, float(0).xxxx, MaxHalfFloat.xxxx); }



float4  Texture1DSample(Texture1D Tex, SamplerState Sampler, float UV)
{

	return Tex.SampleLevel(Sampler, UV, 0);
#line 274 "/Engine/Private/Common.ush"
}
float4  Texture2DSample(Texture2D Tex, SamplerState Sampler, float2 UV)
{

	return Tex.SampleLevel(Sampler, UV, ComputeRayConeLod(Tex) + GlobalTextureMipBias);
#line 282 "/Engine/Private/Common.ush"
}
float4  Texture2DSample(Texture2D Tex, SamplerState Sampler, FloatDeriv2 UV)
{

	return Tex.SampleLevel(Sampler, UV.Value, ComputeRayConeLod(Tex) + GlobalTextureMipBias);
#line 290 "/Engine/Private/Common.ush"
}
float  Texture2DSample_A8(Texture2D Tex, SamplerState Sampler, float2 UV)
{

	return Tex.SampleLevel(Sampler, UV, ComputeRayConeLod(Tex) + GlobalTextureMipBias)  .a ;
#line 298 "/Engine/Private/Common.ush"
}
float4  Texture3DSample(Texture3D Tex, SamplerState Sampler, float3 UV)
{

	return Tex.SampleLevel(Sampler, UV, 0);
#line 306 "/Engine/Private/Common.ush"
}
float4  TextureCubeSample(TextureCube Tex, SamplerState Sampler, float3 UV)
{

	return Tex.SampleLevel(Sampler, UV, 0);
#line 314 "/Engine/Private/Common.ush"
}
float4  Texture2DArraySample(Texture2DArray Tex, SamplerState Sampler, float3 UV)
{

	return Tex.SampleLevel(Sampler, UV, 0);
#line 322 "/Engine/Private/Common.ush"
}
float4  Texture1DSampleLevel(Texture1D Tex, SamplerState Sampler, float UV,  float  Mip)
{
	return Tex.SampleLevel(Sampler, UV, Mip);
}
float4  Texture2DSampleLevel(Texture2D Tex, SamplerState Sampler, float2 UV,  float  Mip)
{
	return Tex.SampleLevel(Sampler, UV, Mip);
}
float4  Texture2DSampleBias(Texture2D Tex, SamplerState Sampler, float2 UV,  float  MipBias)
{

	return Tex.SampleLevel(Sampler, UV, ComputeRayConeLod(Tex) + MipBias + GlobalTextureMipBias);
#line 338 "/Engine/Private/Common.ush"
}
float4  Texture2DSampleGrad(Texture2D Tex, SamplerState Sampler, float2 UV,  float2  DDX,  float2  DDY)
{
	return Tex.SampleGrad(Sampler, UV, DDX, DDY);
}
float4  Texture3DSampleLevel(Texture3D Tex, SamplerState Sampler, float3 UV,  float  Mip)
{
	return Tex.SampleLevel(Sampler, UV, Mip);
}
float4  Texture3DSampleBias(Texture3D Tex, SamplerState Sampler, float3 UV,  float  MipBias)
{

	return Tex.SampleLevel(Sampler, UV, 0);
#line 354 "/Engine/Private/Common.ush"
}
float4  Texture3DSampleGrad(Texture3D Tex, SamplerState Sampler, float3 UV,  float3  DDX,  float3  DDY)
{
	return Tex.SampleGrad(Sampler, UV, DDX, DDY);
}
float4  TextureCubeSampleLevel(TextureCube Tex, SamplerState Sampler, float3 UV,  float  Mip)
{
	return Tex.SampleLevel(Sampler, UV, Mip);
}
float  TextureCubeSampleDepthLevel(TextureCube TexDepth, SamplerState Sampler, float3 UV,  float  Mip)
{
	return TexDepth.SampleLevel(Sampler, UV, Mip).x;
}
float4  TextureCubeSampleBias(TextureCube Tex, SamplerState Sampler, float3 UV,  float  MipBias)
{

	return Tex.SampleLevel(Sampler, UV, 0);
#line 374 "/Engine/Private/Common.ush"
}
float4  TextureCubeSampleGrad(TextureCube Tex, SamplerState Sampler, float3 UV,  float3  DDX,  float3  DDY)
{
	return Tex.SampleGrad(Sampler, UV, DDX, DDY);
}
float4  TextureExternalSample( Texture2D  Tex, SamplerState Sampler, float2 UV)
{




		return Tex.SampleLevel(Sampler, UV, ComputeRayConeLod(Tex) + GlobalTextureMipBias);
#line 390 "/Engine/Private/Common.ush"
}
float4  TextureExternalSampleGrad( Texture2D  Tex, SamplerState Sampler, float2 UV,  float2  DDX,  float2  DDY)
{
	return Tex.SampleGrad(Sampler, UV, DDX, DDY);
}
float4  TextureExternalSampleLevel( Texture2D  Tex, SamplerState Sampler, float2 UV,  float  Mip)
{
	return Tex.SampleLevel(Sampler, UV, Mip);
}




float4  Texture1DSample_Decal(Texture1D Tex, SamplerState Sampler, float UV)
{



	return Texture1DSample(Tex, Sampler, UV);

}
float4  Texture2DSample_Decal(Texture2D Tex, SamplerState Sampler, float2 UV)
{



	return Texture2DSample(Tex, Sampler, UV);

}
float4  Texture3DSample_Decal(Texture3D Tex, SamplerState Sampler, float3 UV)
{



	return Texture3DSample(Tex, Sampler, UV);

}
float4  TextureCubeSample_Decal(TextureCube Tex, SamplerState Sampler, float3 UV)
{



	return TextureCubeSample(Tex, Sampler, UV);

}
float4  TextureExternalSample_Decal( Texture2D  Tex, SamplerState Sampler, float2 UV)
{



	return TextureExternalSample(Tex, Sampler, UV);

}

float4  Texture2DArraySampleLevel(Texture2DArray Tex, SamplerState Sampler, float3 UV,  float  Mip)
{
	return Tex.SampleLevel(Sampler, UV, Mip);
}
float4  Texture2DArraySampleBias(Texture2DArray Tex, SamplerState Sampler, float3 UV,  float  MipBias)
{

	return Tex.SampleLevel(Sampler, UV, 0);
#line 455 "/Engine/Private/Common.ush"
}
float4  Texture2DArraySampleGrad(Texture2DArray Tex, SamplerState Sampler, float3 UV,  float2  DDX,  float2  DDY)
{
	return Tex.SampleGrad(Sampler, UV, DDX, DDY);
}


float2 Tile1Dto2D(float xsize, float idx)
{
	float2 xyidx = 0;
	xyidx.y = floor(idx / xsize);
	xyidx.x = idx - xsize * xyidx.y;

	return xyidx;
}
#line 482 "/Engine/Private/Common.ush"
float4 PseudoVolumeTexture(Texture2D Tex, SamplerState TexSampler, float3 inPos, float2 xysize, float numframes,
	uint mipmode = 0, float miplevel = 0, float2 InDDX = 0, float2 InDDY = 0)
{
	float z = inPos.z - 0.5f / numframes;
	float zframe = floor(z * numframes);
	float zphase = frac(z * numframes);

	float2 uv = frac(inPos.xy) / xysize;

	float2 curframe = Tile1Dto2D(xysize.x, zframe) / xysize;
	float2 nextframe = Tile1Dto2D(xysize.x, zframe + 1) / xysize;

	float2 uvCurFrame = uv + curframe;
	float2 uvNextFrame = uv + nextframe;
#line 502 "/Engine/Private/Common.ush"
	float4 sampleA = 0, sampleB = 0;
	switch (mipmode)
	{
	case 0:
		sampleA = Tex.SampleLevel(TexSampler, uvCurFrame, miplevel);
		sampleB = Tex.SampleLevel(TexSampler, uvNextFrame, miplevel);
		break;
	case 1:
		sampleA = Texture2DSample(Tex, TexSampler, uvCurFrame);
		sampleB = Texture2DSample(Tex, TexSampler, uvNextFrame);
		break;
	case 2:
		sampleA = Tex.SampleGrad(TexSampler, uvCurFrame, InDDX, InDDY);
		sampleB = Tex.SampleGrad(TexSampler, uvNextFrame, InDDX, InDDY);
		break;
	default:
		break;
	}

	return lerp(sampleA, sampleB, zphase);
}


float4  TextureCubeArraySample(TextureCubeArray Tex, SamplerState Sampler, float4 UV)
{
	return Tex.Sample(Sampler, UV);
}

float4  TextureCubeArraySampleLevel(TextureCubeArray Tex, SamplerState Sampler, float4 UV,  float  Mip)
{
	return Tex.SampleLevel(Sampler, UV, Mip);
}

float4  TextureCubeArraySampleBias(TextureCubeArray Tex, SamplerState Sampler, float4 UV,  float  MipBias)
{

	return Tex.SampleLevel(Sampler, UV, 0);
#line 542 "/Engine/Private/Common.ush"
}

float4  TextureCubeArraySampleGrad(TextureCubeArray Tex, SamplerState Sampler, float4 UV,  float3  DDX,  float3  DDY)
{
	return Tex.SampleGrad(Sampler, UV, DDX, DDY);
}


float4  TextureCubeArraySampleLevel(TextureCubeArray Tex, SamplerState Sampler, float3 UV, float ArrayIndex,  float  Mip)
{
	return TextureCubeArraySampleLevel(Tex, Sampler, float4(UV, ArrayIndex), Mip);
}
#line 585 "/Engine/Private/Common.ush"
float  Luminance(  float3  LinearColor )
{
	return dot( LinearColor,  float3 ( 0.3, 0.59, 0.11 ) );
}

float length2(float2 v)
{
	return dot(v, v);
}
float length2(float3 v)
{
	return dot(v, v);
}
float length2(float4 v)
{
	return dot(v, v);
}

uint Mod(uint a, uint b)
{

	return a % b;
#line 610 "/Engine/Private/Common.ush"
}

uint2 Mod(uint2 a, uint2 b)
{

	return a % b;
#line 619 "/Engine/Private/Common.ush"
}

uint3 Mod(uint3 a, uint3 b)
{

	return a % b;
#line 628 "/Engine/Private/Common.ush"
}




float  ClampedPow( float  X, float  Y)
{
	return pow(max(abs(X), 0.000001f ),Y);
}
float2  ClampedPow( float2  X, float2  Y)
{
	return pow(max(abs(X), float2 ( 0.000001f , 0.000001f )),Y);
}
float3  ClampedPow( float3  X, float3  Y)
{
	return pow(max(abs(X), float3 ( 0.000001f , 0.000001f , 0.000001f )),Y);
}
float4  ClampedPow( float4  X, float4  Y)
{
	return pow(max(abs(X), float4 ( 0.000001f , 0.000001f , 0.000001f , 0.000001f )),Y);
}


float  PositiveClampedPow( float  Base,  float  Exponent)
{
	return (Base <= 0.0f) ? 0.0f : pow(Base, Exponent);
}
float2  PositiveClampedPow( float2  Base,  float2  Exponent)
{
	return  float2 (PositiveClampedPow(Base.x, Exponent.x), PositiveClampedPow(Base.y, Exponent.y));
}
float3  PositiveClampedPow( float3  Base,  float3  Exponent)
{
	return  float3 (PositiveClampedPow(Base.xy, Exponent.xy), PositiveClampedPow(Base.z, Exponent.z));
}
float4  PositiveClampedPow( float4  Base,  float4  Exponent)
{
	return  float4 (PositiveClampedPow(Base.xy, Exponent.xy), PositiveClampedPow(Base.zw, Exponent.zw));
}

float DDX(float Input)
{

	return 0;
#line 675 "/Engine/Private/Common.ush"
}

float2 DDX(float2 Input)
{

	return 0;
#line 684 "/Engine/Private/Common.ush"
}

float3 DDX(float3 Input)
{

	return 0;
#line 693 "/Engine/Private/Common.ush"
}

float4 DDX(float4 Input)
{

	return 0;
#line 702 "/Engine/Private/Common.ush"
}

float DDY(float Input)
{

	return 0;
#line 711 "/Engine/Private/Common.ush"
}

float2 DDY(float2 Input)
{

	return 0;
#line 720 "/Engine/Private/Common.ush"
}

float3 DDY(float3 Input)
{

	return 0;
#line 729 "/Engine/Private/Common.ush"
}

float4 DDY(float4 Input)
{

	return 0;
#line 738 "/Engine/Private/Common.ush"
}
#line 740 "/Engine/Private/Common.ush"
#line 1 "FastMath.ush"
#line 9 "/Engine/Private/FastMath.ush"
#line 1 "FastMathThirdParty.ush"
#line 42 "/Engine/Private/FastMathThirdParty.ush"
float rsqrtFast( float x )
{
	int i = asint(x);
	i = 0x5f3759df - (i >> 1);
	return asfloat(i);
}




float sqrtFast( float x )
{
	int i = asint(x);
	i = 0x1FBD1DF5 + (i >> 1);
	return asfloat(i);
}




float rcpFast( float x )
{
	int i = asint(x);
	i = 0x7EF311C2 - i;
	return asfloat(i);
}





float rcpFastNR1( float x )
{
	int i = asint(x);
	i = 0x7EF311C3 - i;
	float xRcp = asfloat(i);
	xRcp = xRcp * (-xRcp * x + 2.0f);
	return xRcp;
}

float lengthFast( float3 v )
{
	float LengthSqr = dot(v,v);
	return sqrtFast( LengthSqr );
}

float3 normalizeFast( float3 v )
{
	float LengthSqr = dot(v,v);
	return v * rsqrtFast( LengthSqr );
}

float4 fastClamp(float4 x, float4 Min, float4 Max)
{




	return clamp(x, Min, Max);

}

float3 fastClamp(float3 x, float3 Min, float3 Max)
{




	return clamp(x, Min, Max);

}

float2 fastClamp(float2 x, float2 Min, float2 Max)
{




	return clamp(x, Min, Max);

}

float fastClamp(float x, float Min, float Max)
{




	return clamp(x, Min, Max);

}

int4 fastClamp(int4 x, int4 Min, int4 Max)
{




	return clamp(x, Min, Max);

}

int3 fastClamp(int3 x, int3 Min, int3 Max)
{




	return clamp(x, Min, Max);

}

int2 fastClamp(int2 x, int2 Min, int2 Max)
{




	return clamp(x, Min, Max);

}

int fastClamp(int x, int Min, int Max)
{




	return clamp(x, Min, Max);

}









float acosFast(float inX)
{
    float x = abs(inX);
    float res = -0.156583f * x + (0.5 * PI);
    res *= sqrt(1.0f - x);
    return (inX >= 0) ? res : PI - res;
}

float2 acosFast( float2 x )
{
	return float2( acosFast(x.x), acosFast(x.y) );
}

float3 acosFast( float3 x )
{
	return float3( acosFast(x.x), acosFast(x.y), acosFast(x.z) );
}

float4 acosFast( float4 x )
{
	return float4( acosFast(x.x), acosFast(x.y), acosFast(x.z), acosFast(x.w) );
}




float asinFast( float x )
{
    return (0.5 * PI) - acosFast(x);
}

float2 asinFast( float2 x)
{
	return float2( asinFast(x.x), asinFast(x.y) );
}

float3 asinFast( float3 x)
{
	return float3( asinFast(x.x), asinFast(x.y), asinFast(x.z) );
}

float4 asinFast( float4 x )
{
	return float4( asinFast(x.x), asinFast(x.y), asinFast(x.z), asinFast(x.w) );
}





float atanFastPos( float x )
{
    float t0 = (x < 1.0f) ? x : 1.0f / x;
    float t1 = t0 * t0;
    float poly = 0.0872929f;
    poly = -0.301895f + poly * t1;
    poly = 1.0f + poly * t1;
    poly = poly * t0;
    return (x < 1.0f) ? poly : (0.5 * PI) - poly;
}



float atanFast( float x )
{
    float t0 = atanFastPos( abs(x) );
    return (x < 0) ? -t0: t0;
}

float2 atanFast( float2 x )
{
	return float2( atanFast(x.x), atanFast(x.y) );
}

float3 atanFast( float3 x )
{
	return float3( atanFast(x.x), atanFast(x.y), atanFast(x.z) );
}

float4 atanFast( float4 x )
{
	return float4( atanFast(x.x), atanFast(x.y), atanFast(x.z), atanFast(x.w) );
}

float atan2Fast( float y, float x )
{
	float t0 = max( abs(x), abs(y) );
	float t1 = min( abs(x), abs(y) );
	float t3 = t1 / t0;
	float t4 = t3 * t3;


	t0 = + 0.0872929;
	t0 = t0 * t4 - 0.301895;
	t0 = t0 * t4 + 1.0;
	t3 = t0 * t3;

	t3 = abs(y) > abs(x) ? (0.5 * PI) - t3 : t3;
	t3 = x < 0 ? PI - t3 : t3;
	t3 = y < 0 ? -t3 : t3;

	return t3;
}

float2 atan2Fast( float2 y, float2 x )
{
	return float2( atan2Fast(y.x, x.x), atan2Fast(y.y, x.y) );
}

float3 atan2Fast( float3 y, float3 x )
{
	return float3( atan2Fast(y.x, x.x), atan2Fast(y.y, x.y), atan2Fast(y.z, x.z) );
}

float4 atan2Fast( float4 y, float4 x )
{
	return float4( atan2Fast(y.x, x.x), atan2Fast(y.y, x.y), atan2Fast(y.z, x.z), atan2Fast(y.w, x.w) );
}





float acosFast4(float inX)
{
	float x1 = abs(inX);
	float x2 = x1 * x1;
	float x3 = x2 * x1;
	float s;

	s = -0.2121144f * x1 + 1.5707288f;
	s = 0.0742610f * x2 + s;
	s = -0.0187293f * x3 + s;
	s = sqrt(1.0f - x1) * s;



	return inX >= 0.0f ? s : PI - s;
}




float asinFast4( float x )
{
	return (0.5 * PI) - acosFast4(x);
}




float CosBetweenVectors(float3 A, float3 B)
{

	return dot(A, B) * rsqrt(length2(A) * length2(B));
}



float AngleBetweenVectors(float3 A, float3 B)
{
	return acos(CosBetweenVectors(A, B));
}


float AngleBetweenVectorsFast(float3 A, float3 B)
{
	return acosFast(CosBetweenVectors(A, B));
}


int SignFastInt(float v)
{
	return 1 - int((asuint(v) & 0x80000000) >> 30);
}

int2 SignFastInt(float2 v)
{
	return int2(SignFastInt(v.x), SignFastInt(v.y));
}
#line 10 "/Engine/Private/FastMath.ush"



float FastExp(float x) { return exp2(1.442695f * x); }
float2 FastExp(float2 x) { return exp2(1.442695f * x); }
float3 FastExp(float3 x) { return exp2(1.442695f * x); }
float4 FastExp(float4 x) { return exp2(1.442695f * x); }




float FastLog(float x) { return log2(0.693147f * x); }
float2 FastLog(float2 x) { return log2(0.693147f * x); }
float3 FastLog(float3 x) { return log2(0.693147f * x); }
float4 FastLog(float4 x) { return log2(0.693147f * x); }
#line 741 "/Engine/Private/Common.ush"
#line 1 "Random.ush"
#line 12 "/Engine/Private/Random.ush"
float PseudoRandom(float2 xy)
{
	float2 pos = frac(xy / 128.0f) * 128.0f + float2(-64.340622f, -72.465622f);


	return frac(dot(pos.xyx * pos.xyy, float3(20.390625f, 60.703125f, 2.4281209f)));
}







float InterleavedGradientNoise( float2 uv, float FrameId )
{

	uv += FrameId * (float2(47, 17) * 0.695f);

    const float3 magic = float3( 0.06711056f, 0.00583715f, 52.9829189f );
    return frac(magic.z * frac(dot(uv, magic.xy)));
}



float RandFast( uint2 PixelPos, float Magic = 3571.0 )
{
	float2 Random2 = ( 1.0 / 4320.0 ) * PixelPos + float2( 0.25, 0.0 );
	float Random = frac( dot( Random2 * Random2, Magic ) );
	Random = frac( Random * Random * (2 * Magic) );
	return Random;
}
#line 56 "/Engine/Private/Random.ush"
float RandBBSfloat(float seed)
{
	float s = frac(seed /  4093 );
	s = frac(s * s *  4093 );
	s = frac(s * s *  4093 );
	return s;
}








uint3 Rand3DPCG16(int3 p)
{

	uint3 v = uint3(p);




	v = v * 1664525u + 1013904223u;
#line 94 "/Engine/Private/Random.ush"
	v.x += v.y*v.z;
	v.y += v.z*v.x;
	v.z += v.x*v.y;
	v.x += v.y*v.z;
	v.y += v.z*v.x;
	v.z += v.x*v.y;


	return v >> 16u;
}






uint3 Rand3DPCG32(int3 p)
{

	uint3 v = uint3(p);


	v = v * 1664525u + 1013904223u;


	v.x += v.y*v.z;
	v.y += v.z*v.x;
	v.z += v.x*v.y;


	v ^= v >> 16u;


	v.x += v.y*v.z;
	v.y += v.z*v.x;
	v.z += v.x*v.y;

	return v;
}








uint4 Rand4DPCG32(int4 p)
{

	uint4 v = uint4(p);


	v = v * 1664525u + 1013904223u;


	v.x += v.y*v.w;
	v.y += v.z*v.x;
	v.z += v.x*v.y;
	v.w += v.y*v.z;


	v ^= (v >> 16u);


	v.x += v.y*v.w;
	v.y += v.z*v.x;
	v.z += v.x*v.y;
	v.w += v.y*v.z;

	return v;
}
#line 174 "/Engine/Private/Random.ush"
void FindBestAxisVectors(float3 In, out float3 Axis1, out float3 Axis2 )
{
	const float3 N = abs(In);


	if( N.z > N.x && N.z > N.y )
	{
		Axis1 = float3(1, 0, 0);
	}
	else
	{
		Axis1 = float3(0, 0, 1);
	}

	Axis1 = normalize(Axis1 - In * dot(Axis1, In));
	Axis2 = cross(Axis1, In);
}
#line 215 "/Engine/Private/Random.ush"
uint2 ScrambleTEA(uint2 v, uint IterationCount = 3)
{

	uint k[4] ={ 0xA341316Cu , 0xC8013EA4u , 0xAD90777Du , 0x7E95761Eu };

	uint y = v[0];
	uint z = v[1];
	uint sum = 0;

	[unroll]  for(uint i = 0; i < IterationCount; ++i)
	{
		sum += 0x9e3779b9;
		y += ((z << 4u) + k[0]) ^ (z + sum) ^ ((z >> 5u) + k[1]);
		z += ((y << 4u) + k[2]) ^ (y + sum) ^ ((y >> 5u) + k[3]);
	}

	return uint2(y, z);
}






float3 NoiseTileWrap(float3 v, bool bTiling, float RepeatSize)
{
	return bTiling ? (frac(v / RepeatSize) * RepeatSize) : v;
}




float4 PerlinRamp(float4 t)
{
	return t * t * t * (t * (t * 6 - 15) + 10);
}




float4 PerlinRampDerivative(float4 t)
{
	return t * t * (t * (t * 30 - 60) + 30);
}







float4 MGradient(int seed, float3 offset)
{
	uint rand = Rand3DPCG16(int3(seed,0,0)).x;
	float3 direction = float3(rand.xxx &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	return float4(direction, dot(direction, offset));
}







float3 NoiseSeeds(float3 v, bool bTiling, float RepeatSize,
	out float seed000, out float seed001, out float seed010, out float seed011,
	out float seed100, out float seed101, out float seed110, out float seed111)
{
	float3 fv = frac(v);
	float3 iv = floor(v);

	const float3 primes = float3(19, 47, 101);

	if (bTiling)
	{
		seed000 = dot(primes, NoiseTileWrap(iv, true, RepeatSize));
		seed100 = dot(primes, NoiseTileWrap(iv + float3(1, 0, 0), true, RepeatSize));
		seed010 = dot(primes, NoiseTileWrap(iv + float3(0, 1, 0), true, RepeatSize));
		seed110 = dot(primes, NoiseTileWrap(iv + float3(1, 1, 0), true, RepeatSize));
		seed001 = dot(primes, NoiseTileWrap(iv + float3(0, 0, 1), true, RepeatSize));
		seed101 = dot(primes, NoiseTileWrap(iv + float3(1, 0, 1), true, RepeatSize));
		seed011 = dot(primes, NoiseTileWrap(iv + float3(0, 1, 1), true, RepeatSize));
		seed111 = dot(primes, NoiseTileWrap(iv + float3(1, 1, 1), true, RepeatSize));
	}
	else
	{
		seed000 = dot(iv, primes);
		seed100 = seed000 + primes.x;
		seed010 = seed000 + primes.y;
		seed110 = seed100 + primes.y;
		seed001 = seed000 + primes.z;
		seed101 = seed100 + primes.z;
		seed011 = seed010 + primes.z;
		seed111 = seed110 + primes.z;
	}

	return fv;
}







float GradientNoise3D_ALU(float3 v, bool bTiling, float RepeatSize)
{
	float seed000, seed001, seed010, seed011, seed100, seed101, seed110, seed111;
	float3 fv = NoiseSeeds(v, bTiling, RepeatSize, seed000, seed001, seed010, seed011, seed100, seed101, seed110, seed111);

	float rand000 = MGradient(int(seed000), fv - float3(0, 0, 0)).w;
	float rand100 = MGradient(int(seed100), fv - float3(1, 0, 0)).w;
	float rand010 = MGradient(int(seed010), fv - float3(0, 1, 0)).w;
	float rand110 = MGradient(int(seed110), fv - float3(1, 1, 0)).w;
	float rand001 = MGradient(int(seed001), fv - float3(0, 0, 1)).w;
	float rand101 = MGradient(int(seed101), fv - float3(1, 0, 1)).w;
	float rand011 = MGradient(int(seed011), fv - float3(0, 1, 1)).w;
	float rand111 = MGradient(int(seed111), fv - float3(1, 1, 1)).w;

	float3 Weights = PerlinRamp(float4(fv, 0)).xyz;

	float i = lerp(lerp(rand000, rand100, Weights.x), lerp(rand010, rand110, Weights.x), Weights.y);
	float j = lerp(lerp(rand001, rand101, Weights.x), lerp(rand011, rand111, Weights.x), Weights.y);
	return lerp(i, j, Weights.z).x;
}





float4x3 SimplexCorners(float3 v)
{

	float3 tet = floor(v + v.x/3 + v.y/3 + v.z/3);
	float3 base = tet - tet.x/6 - tet.y/6 - tet.z/6;
	float3 f = v - base;



	float3 g = step(f.yzx, f.xyz), h = 1 - g.zxy;
	float3 a1 = min(g, h) - 1. / 6., a2 = max(g, h) - 1. / 3.;


	return float4x3(base, base + a1, base + a2, base + 0.5);
}




float4 SimplexSmooth(float4x3 f)
{
	const float scale = 1024. / 375.;
	float4 d = float4(dot(f[0], f[0]), dot(f[1], f[1]), dot(f[2], f[2]), dot(f[3], f[3]));
	float4 s = saturate(2 * d);
	return (1 * scale + s*(-3 * scale + s*(3 * scale - s*scale)));
}




float3x4 SimplexDSmooth(float4x3 f)
{
	const float scale = 1024. / 375.;
	float4 d = float4(dot(f[0], f[0]), dot(f[1], f[1]), dot(f[2], f[2]), dot(f[3], f[3]));
	float4 s = saturate(2 * d);
	s = -12 * scale + s*(24 * scale - s * 12 * scale);

	return float3x4(
		s * float4(f[0][0], f[1][0], f[2][0], f[3][0]),
		s * float4(f[0][1], f[1][1], f[2][1], f[3][1]),
		s * float4(f[0][2], f[1][2], f[2][2], f[3][2]));
}
#line 403 "/Engine/Private/Random.ush"
float3x4 JacobianSimplex_ALU(float3 v, bool bTiling, float RepeatSize)
{

	float4x3 T = SimplexCorners(v);
	uint3 rand;
	float4x3 gvec[3], fv;
	float3x4 grad;



	fv[0] = v - T[0];
	rand = Rand3DPCG16(int3(floor(NoiseTileWrap(6 * T[0] + 0.5, bTiling, RepeatSize))));
	gvec[0][0] = float3(rand.xxx &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[1][0] = float3(rand.yyy &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[2][0] = float3(rand.zzz &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	grad[0][0] = dot(gvec[0][0], fv[0]);
	grad[1][0] = dot(gvec[1][0], fv[0]);
	grad[2][0] = dot(gvec[2][0], fv[0]);

	fv[1] = v - T[1];
	rand = Rand3DPCG16(int3(floor(NoiseTileWrap(6 * T[1] + 0.5, bTiling, RepeatSize))));
	gvec[0][1] = float3(rand.xxx &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[1][1] = float3(rand.yyy &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[2][1] = float3(rand.zzz &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	grad[0][1] = dot(gvec[0][1], fv[1]);
	grad[1][1] = dot(gvec[1][1], fv[1]);
	grad[2][1] = dot(gvec[2][1], fv[1]);

	fv[2] = v - T[2];
	rand = Rand3DPCG16(int3(floor(NoiseTileWrap(6 * T[2] + 0.5, bTiling, RepeatSize))));
	gvec[0][2] = float3(rand.xxx &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[1][2] = float3(rand.yyy &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[2][2] = float3(rand.zzz &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	grad[0][2] = dot(gvec[0][2], fv[2]);
	grad[1][2] = dot(gvec[1][2], fv[2]);
	grad[2][2] = dot(gvec[2][2], fv[2]);

	fv[3] = v - T[3];
	rand = Rand3DPCG16(int3(floor(NoiseTileWrap(6 * T[3] + 0.5, bTiling, RepeatSize))));
	gvec[0][3] = float3(rand.xxx &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[1][3] = float3(rand.yyy &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[2][3] = float3(rand.zzz &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	grad[0][3] = dot(gvec[0][3], fv[3]);
	grad[1][3] = dot(gvec[1][3], fv[3]);
	grad[2][3] = dot(gvec[2][3], fv[3]);


	float4 sv = SimplexSmooth(fv);
	float3x4 ds = SimplexDSmooth(fv);

	float3x4 jacobian;
	jacobian[0] = float4(mul(sv, gvec[0]) + mul(ds, grad[0]), dot(sv, grad[0]));
	jacobian[1] = float4(mul(sv, gvec[1]) + mul(ds, grad[1]), dot(sv, grad[1]));
	jacobian[2] = float4(mul(sv, gvec[2]) + mul(ds, grad[2]), dot(sv, grad[2]));

	return jacobian;
}






float ValueNoise3D_ALU(float3 v, bool bTiling, float RepeatSize)
{
	float seed000, seed001, seed010, seed011, seed100, seed101, seed110, seed111;
	float3 fv = NoiseSeeds(v, bTiling, RepeatSize, seed000, seed001, seed010, seed011, seed100, seed101, seed110, seed111);

	float rand000 = RandBBSfloat(seed000) * 2 - 1;
	float rand100 = RandBBSfloat(seed100) * 2 - 1;
	float rand010 = RandBBSfloat(seed010) * 2 - 1;
	float rand110 = RandBBSfloat(seed110) * 2 - 1;
	float rand001 = RandBBSfloat(seed001) * 2 - 1;
	float rand101 = RandBBSfloat(seed101) * 2 - 1;
	float rand011 = RandBBSfloat(seed011) * 2 - 1;
	float rand111 = RandBBSfloat(seed111) * 2 - 1;

	float3 Weights = PerlinRamp(float4(fv, 0)).xyz;

	float i = lerp(lerp(rand000, rand100, Weights.x), lerp(rand010, rand110, Weights.x), Weights.y);
	float j = lerp(lerp(rand001, rand101, Weights.x), lerp(rand011, rand111, Weights.x), Weights.y);
	return lerp(i, j, Weights.z).x;
}









float GradientNoise3D_TEX(float3 v, bool bTiling, float RepeatSize)
{
	bTiling = true;
	float3 fv = frac(v);
	float3 iv0 = NoiseTileWrap(floor(v), bTiling, RepeatSize);
	float3 iv1 = NoiseTileWrap(iv0 + 1, bTiling, RepeatSize);

	const int2 ZShear = int2(17, 89);

	float2 OffsetA = iv0.z * ZShear;
	float2 OffsetB = OffsetA + ZShear;
	if (bTiling)
	{
		OffsetB = iv1.z * ZShear;
	}


	float ts = 1 / 128.0f;


	float2 TexA0 = (iv0.xy + OffsetA + 0.5f) * ts;
	float2 TexB0 = (iv0.xy + OffsetB + 0.5f) * ts;


	float2 TexA1 = TexA0 + ts;
	float2 TexB1 = TexB0 + ts;
	if (bTiling)
	{
		TexA1 = (iv1.xy + OffsetA + 0.5f) * ts;
		TexB1 = (iv1.xy + OffsetB + 0.5f) * ts;
	}



	float3 A = Texture2DSampleLevel(View.PerlinNoiseGradientTexture, View.PerlinNoiseGradientTextureSampler, float2(TexA0.x, TexA0.y), 0).xyz * 2 - 1;
	float3 B = Texture2DSampleLevel(View.PerlinNoiseGradientTexture, View.PerlinNoiseGradientTextureSampler, float2(TexA1.x, TexA0.y), 0).xyz * 2 - 1;
	float3 C = Texture2DSampleLevel(View.PerlinNoiseGradientTexture, View.PerlinNoiseGradientTextureSampler, float2(TexA0.x, TexA1.y), 0).xyz * 2 - 1;
	float3 D = Texture2DSampleLevel(View.PerlinNoiseGradientTexture, View.PerlinNoiseGradientTextureSampler, float2(TexA1.x, TexA1.y), 0).xyz * 2 - 1;
	float3 E = Texture2DSampleLevel(View.PerlinNoiseGradientTexture, View.PerlinNoiseGradientTextureSampler, float2(TexB0.x, TexB0.y), 0).xyz * 2 - 1;
	float3 F = Texture2DSampleLevel(View.PerlinNoiseGradientTexture, View.PerlinNoiseGradientTextureSampler, float2(TexB1.x, TexB0.y), 0).xyz * 2 - 1;
	float3 G = Texture2DSampleLevel(View.PerlinNoiseGradientTexture, View.PerlinNoiseGradientTextureSampler, float2(TexB0.x, TexB1.y), 0).xyz * 2 - 1;
	float3 H = Texture2DSampleLevel(View.PerlinNoiseGradientTexture, View.PerlinNoiseGradientTextureSampler, float2(TexB1.x, TexB1.y), 0).xyz * 2 - 1;

	float a = dot(A, fv - float3(0, 0, 0));
	float b = dot(B, fv - float3(1, 0, 0));
	float c = dot(C, fv - float3(0, 1, 0));
	float d = dot(D, fv - float3(1, 1, 0));
	float e = dot(E, fv - float3(0, 0, 1));
	float f = dot(F, fv - float3(1, 0, 1));
	float g = dot(G, fv - float3(0, 1, 1));
	float h = dot(H, fv - float3(1, 1, 1));

	float3 Weights = PerlinRamp(frac(float4(fv, 0))).xyz;

	float i = lerp(lerp(a, b, Weights.x), lerp(c, d, Weights.x), Weights.y);
	float j = lerp(lerp(e, f, Weights.x), lerp(g, h, Weights.x), Weights.y);

	return lerp(i, j, Weights.z);
}



float FastGradientPerlinNoise3D_TEX(float3 xyz)
{

	float Extent = 16;



	xyz = frac(xyz / (Extent - 1)) * (Extent - 1);


	float3 uvw = frac(xyz);


	float3 p0 = xyz - uvw;


	float3 f = PerlinRamp(float4(uvw, 0)).xyz;

	float3 p = p0 + f;

	float4 NoiseSample = Texture3DSampleLevel(View.PerlinNoise3DTexture, View.PerlinNoise3DTextureSampler, p / Extent + 0.5f / Extent, 0);



	float3 n = NoiseSample.xyz * 255.0f / 127.0f - 1.0f;
	float d = NoiseSample.w * 255.f - 127;
	return dot(xyz, n) - d;
}





float3 VoronoiCornerSample(float3 pos, int Quality)
{

	float3 noise = float3(Rand3DPCG16(int3(pos))) / 0xffff - 0.5;



	if (Quality <= 2)
	{
		return normalize(noise) * 0.2588;
	}



	if (Quality == 3)
	{
		return normalize(noise) * 0.3090;
	}


	return noise;
}








float4 VoronoiCompare(float4 minval, float3 candidate, float3 offset, bool bDistanceOnly)
{
	if (bDistanceOnly)
	{
		return float4(0, 0, 0, min(minval.w, dot(offset, offset)));
	}
	else
	{
		float newdist = dot(offset, offset);
		return newdist > minval.w ? minval : float4(candidate, newdist);
	}
}


float4 VoronoiNoise3D_ALU(float3 v, int Quality, bool bTiling, float RepeatSize, bool bDistanceOnly)
{
	float3 fv = frac(v), fv2 = frac(v + 0.5);
	float3 iv = floor(v), iv2 = floor(v + 0.5);


	float4 mindist = float4(0,0,0,100);
	float3 p, offset;


	if (Quality == 3)
	{
		[unroll(3)]  for (offset.x = -1; offset.x <= 1; ++offset.x)
		{
			[unroll(3)]  for (offset.y = -1; offset.y <= 1; ++offset.y)
			{
				[unroll(3)]  for (offset.z = -1; offset.z <= 1; ++offset.z)
				{
					p = offset + VoronoiCornerSample(NoiseTileWrap(iv2 + offset, bTiling, RepeatSize), Quality);
					mindist = VoronoiCompare(mindist, iv2 + p, fv2 - p, bDistanceOnly);
				}
			}
		}
	}


	else
	{
		[unroll(2)]  for (offset.x = 0; offset.x <= 1; ++offset.x)
		{
			[unroll(2)]  for (offset.y = 0; offset.y <= 1; ++offset.y)
			{
				[unroll(2)]  for (offset.z = 0; offset.z <= 1; ++offset.z)
				{
					p = offset + VoronoiCornerSample(NoiseTileWrap(iv + offset, bTiling, RepeatSize), Quality);
					mindist = VoronoiCompare(mindist, iv + p, fv - p, bDistanceOnly);


					if (Quality == 2)
					{

						p = offset + VoronoiCornerSample(NoiseTileWrap(iv2 + offset, bTiling, RepeatSize) + 467, Quality);
						mindist = VoronoiCompare(mindist, iv2 + p, fv2 - p, bDistanceOnly);
					}
				}
			}
		}
	}


	if (Quality >= 4)
	{
		[unroll(2)]  for (offset.x = -1; offset.x <= 2; offset.x += 3)
		{
			[unroll(2)]  for (offset.y = 0; offset.y <= 1; ++offset.y)
			{
				[unroll(2)]  for (offset.z = 0; offset.z <= 1; ++offset.z)
				{

					p = offset.xyz + VoronoiCornerSample(NoiseTileWrap(iv + offset.xyz, bTiling, RepeatSize), Quality);
					mindist = VoronoiCompare(mindist, iv + p, fv - p, bDistanceOnly);


					p = offset.yzx + VoronoiCornerSample(NoiseTileWrap(iv + offset.yzx, bTiling, RepeatSize), Quality);
					mindist = VoronoiCompare(mindist, iv + p, fv - p, bDistanceOnly);


					p = offset.zxy + VoronoiCornerSample(NoiseTileWrap(iv + offset.zxy, bTiling, RepeatSize), Quality);
					mindist = VoronoiCompare(mindist, iv + p, fv - p, bDistanceOnly);
				}
			}
		}
	}


	return float4(mindist.xyz, sqrt(mindist.w));
}







float3 ComputeSimplexWeights2D(float2 OrthogonalPos, out float2 PosA, out float2 PosB, out float2 PosC)
{
	float2 OrthogonalPosFloor = floor(OrthogonalPos);
	PosA = OrthogonalPosFloor;
	PosB = PosA + float2(1, 1);

	float2 LocalPos = OrthogonalPos - OrthogonalPosFloor;

	PosC = PosA + ((LocalPos.x > LocalPos.y) ? float2(1,0) : float2(0,1));

	float b = min(LocalPos.x, LocalPos.y);
	float c = abs(LocalPos.y - LocalPos.x);
	float a = 1.0f - b - c;

	return float3(a, b, c);
}



float4 ComputeSimplexWeights3D(float3 OrthogonalPos, out float3 PosA, out float3 PosB, out float3 PosC, out float3 PosD)
{
	float3 OrthogonalPosFloor = floor(OrthogonalPos);

	PosA = OrthogonalPosFloor;
	PosB = PosA + float3(1, 1, 1);

	OrthogonalPos -= OrthogonalPosFloor;

	float Largest = max(OrthogonalPos.x, max(OrthogonalPos.y, OrthogonalPos.z));
	float Smallest = min(OrthogonalPos.x, min(OrthogonalPos.y, OrthogonalPos.z));

	PosC = PosA + float3(Largest == OrthogonalPos.x, Largest == OrthogonalPos.y, Largest == OrthogonalPos.z);
	PosD = PosA + float3(Smallest != OrthogonalPos.x, Smallest != OrthogonalPos.y, Smallest != OrthogonalPos.z);

	float4 ret;

	float RG = OrthogonalPos.x - OrthogonalPos.y;
	float RB = OrthogonalPos.x - OrthogonalPos.z;
	float GB = OrthogonalPos.y - OrthogonalPos.z;

	ret.b =
		  min(max(0, RG), max(0, RB))
		+ min(max(0, -RG), max(0, GB))
		+ min(max(0, -RB), max(0, -GB));

	ret.a =
		  min(max(0, -RG), max(0, -RB))
		+ min(max(0, RG), max(0, -GB))
		+ min(max(0, RB), max(0, GB));

	ret.g = Smallest;
	ret.r = 1.0f - ret.g - ret.b - ret.a;

	return ret;
}

float2 GetPerlinNoiseGradientTextureAt(float2 v)
{
	float2 TexA = (v.xy + 0.5f) / 128.0f;


	float3 p = Texture2DSampleLevel(View.PerlinNoiseGradientTexture, View.PerlinNoiseGradientTextureSampler, TexA, 0).xyz * 2 - 1;
	return normalize(p.xy + p.z * 0.33f);
}

float3 GetPerlinNoiseGradientTextureAt(float3 v)
{
	const float2 ZShear = float2(17.0f, 89.0f);

	float2 OffsetA = v.z * ZShear;
	float2 TexA = (v.xy + OffsetA + 0.5f) / 128.0f;

	return Texture2DSampleLevel(View.PerlinNoiseGradientTexture, View.PerlinNoiseGradientTextureSampler, TexA , 0).xyz * 2 - 1;
}

float2 SkewSimplex(float2 In)
{
	return In + dot(In, (sqrt(3.0f) - 1.0f) * 0.5f );
}
float2 UnSkewSimplex(float2 In)
{
	return In - dot(In, (3.0f - sqrt(3.0f)) / 6.0f );
}
float3 SkewSimplex(float3 In)
{
	return In + dot(In, 1.0 / 3.0f );
}
float3 UnSkewSimplex(float3 In)
{
	return In - dot(In, 1.0 / 6.0f );
}




float GradientSimplexNoise2D_TEX(float2 EvalPos)
{
	float2 OrthogonalPos = SkewSimplex(EvalPos);

	float2 PosA, PosB, PosC, PosD;
	float3 Weights = ComputeSimplexWeights2D(OrthogonalPos, PosA, PosB, PosC);


	float2 A = GetPerlinNoiseGradientTextureAt(PosA);
	float2 B = GetPerlinNoiseGradientTextureAt(PosB);
	float2 C = GetPerlinNoiseGradientTextureAt(PosC);

	PosA = UnSkewSimplex(PosA);
	PosB = UnSkewSimplex(PosB);
	PosC = UnSkewSimplex(PosC);

	float DistanceWeight;

	DistanceWeight = saturate(0.5f - length2(EvalPos - PosA)); DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float a = dot(A, EvalPos - PosA) * DistanceWeight;
	DistanceWeight = saturate(0.5f - length2(EvalPos - PosB)); DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float b = dot(B, EvalPos - PosB) * DistanceWeight;
	DistanceWeight = saturate(0.5f - length2(EvalPos - PosC)); DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float c = dot(C, EvalPos - PosC) * DistanceWeight;

	return 70 * (a + b + c);
}






float SimplexNoise3D_TEX(float3 EvalPos)
{
	float3 OrthogonalPos = SkewSimplex(EvalPos);

	float3 PosA, PosB, PosC, PosD;
	float4 Weights = ComputeSimplexWeights3D(OrthogonalPos, PosA, PosB, PosC, PosD);


	float3 A = GetPerlinNoiseGradientTextureAt(PosA);
	float3 B = GetPerlinNoiseGradientTextureAt(PosB);
	float3 C = GetPerlinNoiseGradientTextureAt(PosC);
	float3 D = GetPerlinNoiseGradientTextureAt(PosD);

	PosA = UnSkewSimplex(PosA);
	PosB = UnSkewSimplex(PosB);
	PosC = UnSkewSimplex(PosC);
	PosD = UnSkewSimplex(PosD);

	float DistanceWeight;

	DistanceWeight = saturate(0.6f - length2(EvalPos - PosA)); DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float a = dot(A, EvalPos - PosA) * DistanceWeight;
	DistanceWeight = saturate(0.6f - length2(EvalPos - PosB)); DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float b = dot(B, EvalPos - PosB) * DistanceWeight;
	DistanceWeight = saturate(0.6f - length2(EvalPos - PosC)); DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float c = dot(C, EvalPos - PosC) * DistanceWeight;
	DistanceWeight = saturate(0.6f - length2(EvalPos - PosD)); DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float d = dot(D, EvalPos - PosD) * DistanceWeight;

	return 32 * (a + b + c + d);
}


float VolumeRaymarch(float3 posPixelWS, float3 posCameraWS)
{
	float ret = 0;
	int cnt = 60;

	[loop]  for(int i=0; i < cnt; ++i)
	{
		ret += saturate(FastGradientPerlinNoise3D_TEX(lerp(posPixelWS, posCameraWS, i/(float)cnt) * 0.01) - 0.2f);
	}

	return ret / cnt * (length(posPixelWS - posCameraWS) * 0.001f );
}
#line 742 "/Engine/Private/Common.ush"
#line 747 "/Engine/Private/Common.ush"
float  PhongShadingPow( float  X,  float  Y)
{
#line 765 "/Engine/Private/Common.ush"
	return ClampedPow(X, Y);
}
#line 787 "/Engine/Private/Common.ush"
Texture2D LightAttenuationTexture;
SamplerState LightAttenuationTextureSampler;





float ConvertTangentUnormToSnorm8(float Input)
{
	int IntVal = int(round(Input * 255.0f));

	IntVal =  select_internal(IntVal > 127,IntVal | 0xFFFFFF80,IntVal) ;
	return clamp(IntVal / 127.0f, -1, 1);
}
float2 ConvertTangentUnormToSnorm8(float2 Input)
{
	int2 IntVal = int2(round(Input * 255.0f));

	IntVal =  select_internal(IntVal > 127,IntVal | 0xFFFFFF80,IntVal) ;
	return clamp(IntVal / 127.0f, -1, 1);
}
float3 ConvertTangentUnormToSnorm8(float3 Input)
{
	int3 IntVal = int3(round(Input * 255.0f));
	IntVal =  select_internal(IntVal > 127,IntVal | 0xFFFFFF80,IntVal) ;
	return clamp(IntVal / 127.0f, -1, 1);
}
float4 ConvertTangentUnormToSnorm8(float4 Input)
{
	int4 IntVal = int4(round(Input * 255.0f));

	IntVal =  select_internal(IntVal > 127,IntVal | 0xFFFFFF80,IntVal) ;
	return clamp(IntVal / 127.0f, -1, 1);
}
float ConvertTangentUnormToSnorm16(float Input)
{
	int IntVal = int(round(Input * 65535.0f));

	IntVal =  select_internal(IntVal > 32767,IntVal | 0xFFFF8000,IntVal) ;
	return clamp(IntVal / 32767.0f, -1, 1);
}
float2 ConvertTangentUnormToSnorm16(float2 Input)
{
	int2 IntVal = int2(round(Input * 65535.0f));

	IntVal =  select_internal(IntVal > 32767,IntVal | 0xFFFFFF80,IntVal) ;
	return clamp(IntVal / 32767.0f, -1, 1);
}
float3 ConvertTangentUnormToSnorm16(float3 Input)
{
	int3 IntVal = int3(round(Input * 65535.0f));
	IntVal =  select_internal(IntVal > 32767,IntVal | 0xFFFFFF80,IntVal) ;
	return clamp(IntVal / 32767.0f, -1, 1);
}
float4 ConvertTangentUnormToSnorm16(float4 Input)
{
	int4 IntVal = int4(round(Input * 65535.0f));

	IntVal =  select_internal(IntVal > 32767,IntVal | 0xFFFFFF80,IntVal) ;
	return clamp(IntVal / 32767.0f, -1, 1);
}
float ConvertTangentSnormToUnorm8(float Input)
{
	float Res =  select_internal(Input >= 0.0f,Input * 127,((Input + 1.0) * 127) + 128) ;
	return clamp(Res / 255, 0.0f, 0.99f);
}
float2 ConvertTangentSnormToUnorm8(float2 Input)
{
	float2 Res =  select_internal(Input >= 0.0f,Input * 127,((Input + 1.0) * 127) + 128) ;
	return clamp(Res / 255, 0.0f, 0.99f);
}
float3 ConvertTangentSnormToUnorm8(float3 Input)
{
	float3 Res =  select_internal(Input >= 0.0f,Input * 127,((Input + 1.0) * 127) + 128) ;
	return clamp(Res / 255, 0.0f, 0.99f);
}
float4 ConvertTangentSnormToUnorm8(float4 Input)
{
	float4 Res =  select_internal(Input >= 0.0f,Input * 127,((Input + 1.0) * 127) + 128) ;
	return clamp(Res / 255, 0.0f, 0.99f);
}
float ConvertTangentSnormToUnorm16(float Input)
{
	float Res =  select_internal(Input >= 0.0f,Input * 32767,((Input + 1.0) * 32767) + 32768) ;
	return clamp(Res / 65535, 0.0f, 0.99f);
}
float2 ConvertTangentSnormToUnorm16(float2 Input)
{
	float2 Res =  select_internal(Input >= 0.0f,Input * 32767,((Input + 1.0) * 32767) + 32768) ;
	return clamp(Res / 65535, 0.0f, 0.99f);
}
float3 ConvertTangentSnormToUnorm16(float3 Input)
{
	float3 Res =  select_internal(Input >= 0.0f,Input * 32767,((Input + 1.0) * 32767) + 32768) ;
	return clamp(Res / 65535, 0.0f, 0.99f);
}
float4 ConvertTangentSnormToUnorm16(float4 Input)
{
	float4 Res =  select_internal(Input >= 0.0f,Input * 32767,((Input + 1.0) * 32767) + 32768) ;
	return clamp(Res / 65535, 0.0f, 0.99f);
}






uint PackUnorm2x16(float2 v)
{
	uint2 sv = uint2(round(clamp(v, 0.0, 1.0) * 65535.0));
	return (sv.x | (sv.y << 16u));
}

uint PackSnorm2x16(float2 v)
{
	uint2 sv = uint2(round(clamp(v, -1.0, 1.0) * 32767.0) + 32767.0);
	return (sv.x | (sv.y << 16u));
}

float2 UnpackUnorm2x16(uint p)
{
	float2 Ret;
	Ret.x = (p & 0xffff) * rcp(65535.0f);
	Ret.y = (p >> 16u) * rcp(65535.0f);
	return Ret;
}

float2 UnpackSnorm2x16(uint p)
{
	float2 Ret;
	Ret.x = clamp((float(p & 0xffff) - 32767.0f) * rcp(32767.0f), -1.0, 1.0);
	Ret.y = clamp((float(p >> 16u) - 32767.0f) * rcp(32767.0f), -1.0, 1.0);
	return Ret;
}

float Square( float x )
{
	return x*x;
}

float2 Square( float2 x )
{
	return x*x;
}

float3 Square( float3 x )
{
	return x*x;
}

float4 Square( float4 x )
{
	return x*x;
}

float Pow2( float x )
{
	return x*x;
}

float2 Pow2( float2 x )
{
	return x*x;
}

float3 Pow2( float3 x )
{
	return x*x;
}

float4 Pow2( float4 x )
{
	return x*x;
}

float Pow3( float x )
{
	return x*x*x;
}

float2 Pow3( float2 x )
{
	return x*x*x;
}

float3 Pow3( float3 x )
{
	return x*x*x;
}

float4 Pow3( float4 x )
{
	return x*x*x;
}

float Pow4( float x )
{
	float xx = x*x;
	return xx * xx;
}

float2 Pow4( float2 x )
{
	float2 xx = x*x;
	return xx * xx;
}

float3 Pow4( float3 x )
{
	float3 xx = x*x;
	return xx * xx;
}

float4 Pow4( float4 x )
{
	float4 xx = x*x;
	return xx * xx;
}

float Pow5( float x )
{
	float xx = x*x;
	return xx * xx * x;
}

float2 Pow5( float2 x )
{
	float2 xx = x*x;
	return xx * xx * x;
}

float3 Pow5( float3 x )
{
	float3 xx = x*x;
	return xx * xx * x;
}

float4 Pow5( float4 x )
{
	float4 xx = x*x;
	return xx * xx * x;
}

float Pow6( float x )
{
	float xx = x*x;
	return xx * xx * xx;
}

float2 Pow6( float2 x )
{
	float2 xx = x*x;
	return xx * xx * xx;
}

float3 Pow6( float3 x )
{
	float3 xx = x*x;
	return xx * xx * xx;
}

float4 Pow6( float4 x )
{
	float4 xx = x*x;
	return xx * xx * xx;
}


float  AtanFast(  float  x )
{

	float3  A = x < 1 ?  float3 ( x, 0, 1 ) :  float3 ( 1/x, 0.5 * PI, -1 );
	return A.y + A.z * ( ( ( -0.130234 * A.x - 0.0954105 ) * A.x + 1.00712 ) * A.x - 0.00001203333 );
}


float  EncodeLightAttenuation( float  InColor)
{


	return sqrt(InColor);
}


float4  EncodeLightAttenuation( float4  InColor)
{
	return sqrt(InColor);
}


float  DecodeLightAttenuation( float  InColor)
{
	return Square(InColor);
}


float4  DecodeLightAttenuation( float4  InColor)
{
	return Square(InColor);
}


float4  RGBTEncode( float3  Color)
{
	float4  RGBT;
	float  Max = max(max(Color.r, Color.g), max(Color.b, 1e-6));
	float  RcpMax = rcp(Max);
	RGBT.rgb = Color.rgb * RcpMax;
	RGBT.a = Max * rcp(1.0 + Max);
	return RGBT;
}

float3  RGBTDecode( float4  RGBT)
{
	RGBT.a = RGBT.a * rcp(1.0 - RGBT.a);
	return RGBT.rgb * RGBT.a;
}



float4  RGBMEncode(  float3  Color )
{
	Color *= 1.0 / 64.0;

	float4 rgbm;
	rgbm.a = saturate( max( max( Color.r, Color.g ), max( Color.b, 1e-6 ) ) );
	rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
	rgbm.rgb = Color / rgbm.a;
	return rgbm;
}

float4  RGBMEncodeFast(  float3  Color )
{

	float4  rgbm;
	rgbm.a = dot( Color, 255.0 / 64.0 );
	rgbm.a = ceil( rgbm.a );
	rgbm.rgb = Color / rgbm.a;
	rgbm *=  float4 ( 255.0 / 64.0, 255.0 / 64.0, 255.0 / 64.0, 1.0 / 255.0 );
	return rgbm;
}

float3  RGBMDecode(  float4  rgbm,  float  MaxValue )
{
	return rgbm.rgb * (rgbm.a * MaxValue);
}

float3  RGBMDecode(  float4  rgbm )
{
	return rgbm.rgb * (rgbm.a * 64.0f);
}

float4  RGBTEncode8BPC( float3  Color,  float  Range)
{
	float  Max = max(max(Color.r, Color.g), max(Color.b, 1e-6));
	Max = min(Max, Range);

	float4  RGBT;
	RGBT.a = (Range + 1) / Range * Max / (1 + Max);


	RGBT.a = ceil(RGBT.a*255.0) / 255.0;
	Max = RGBT.a / (1 + 1 / Range - RGBT.a);

	float  RcpMax = rcp(Max);
	RGBT.rgb = Color.rgb * RcpMax;
	return RGBT;
}

float3  RGBTDecode8BPC( float4  RGBT,  float  Range)
{
	RGBT.a = RGBT.a / (1 + 1 / Range - RGBT.a);
	return RGBT.rgb * RGBT.a;
}
#line 1179 "/Engine/Private/Common.ush"
float2 CalcScreenUVFromOffsetFraction(float4 ScreenPosition, float2 OffsetFraction)
{
	float2 NDC = ScreenPosition.xy / ScreenPosition.w;



	float2 OffsetNDC = clamp(NDC + OffsetFraction * float2(2, -2), -.999f, .999f);
	return float2(OffsetNDC * ResolvedView.ScreenPositionScaleBias.xy + ResolvedView.ScreenPositionScaleBias.wz);
}

float4 GetPerPixelLightAttenuation(float2 UV)
{
	return DecodeLightAttenuation(Texture2DSampleLevel(LightAttenuationTexture, LightAttenuationTextureSampler, UV, 0));
}




float ConvertFromDeviceZ(float DeviceZ)
{

	return DeviceZ * View.InvDeviceZToWorldZTransform[0] + View.InvDeviceZToWorldZTransform[1] + 1.0f / (DeviceZ * View.InvDeviceZToWorldZTransform[2] - View.InvDeviceZToWorldZTransform[3]);
}


bool IsOrthoProjection(float4x4 ViewToClip)
{
	return ViewToClip[3][3] >= 1.0f;
}




float ConvertToDeviceZ(float SceneDepth)
{
	[flatten]
	if (IsOrthoProjection(View.ViewToClip))
	{

		return SceneDepth * View.ViewToClip[2][2] + View.ViewToClip[3][2];
	}
	else
	{

		return 1.0f / ((SceneDepth + View.InvDeviceZToWorldZTransform[3]) * View.InvDeviceZToWorldZTransform[2]);
	}
}

float2 ScreenPositionToBufferUV(float4 ScreenPosition)
{
	return float2(ScreenPosition.xy / ScreenPosition.w * ResolvedView.ScreenPositionScaleBias.xy + ResolvedView.ScreenPositionScaleBias.wz);
}

float2 SvPositionToBufferUV(float4 SvPosition)
{
	return SvPosition.xy * View.BufferSizeAndInvSize.zw;
}


float3 SvPositionToTranslatedWorld(float4 SvPosition)
{
	float4 HomWorldPos = mul(float4(SvPosition.xyz, 1), View.SVPositionToTranslatedWorld);

	return HomWorldPos.xyz / HomWorldPos.w;
}


float3 SvPositionToResolvedTranslatedWorld(float4 SvPosition)
{
	float4 HomWorldPos = mul(float4(SvPosition.xyz, 1), ResolvedView.SVPositionToTranslatedWorld);

	return HomWorldPos.xyz / HomWorldPos.w;
}


FLWCVector3 SvPositionToWorld(float4 SvPosition)
{
	float3 TranslatedWorldPosition = SvPositionToTranslatedWorld(SvPosition);
	return LWCSubtract(TranslatedWorldPosition,  GetPrimaryView() .PreViewTranslation);
}


float4 SvPositionToScreenPosition(float4 SvPosition)
{



	float2 PixelPos = SvPosition.xy - View.ViewRectMin.xy;


	float3 NDCPos = float3( (PixelPos * View.ViewSizeAndInvSize.zw - 0.5f) * float2(2, -2), SvPosition.z);


	return float4(NDCPos.xyz, 1) * SvPosition.w;
}


float4 SvPositionToResolvedScreenPosition(float4 SvPosition)
{
	float2 PixelPos = SvPosition.xy - ResolvedView.ViewRectMin.xy;


	float3 NDCPos = float3( (PixelPos * ResolvedView.ViewSizeAndInvSize.zw - 0.5f) * float2(2, -2), SvPosition.z);


	return float4(NDCPos.xyz, 1) * SvPosition.w;
}

void SvPositionToResolvedScreenPositionDeriv(float4 SvPosition, float2 PPZ_DDX_DDY, float2 W_DDX_DDY, inout float4 ScreenPosition, inout float4 ScreenPositionDDX, inout float4 ScreenPositionDDY)
{
	float2 PixelPos = SvPosition.xy - ResolvedView.ViewRectMin.xy;


	float4 NDCPos = float4((PixelPos * ResolvedView.ViewSizeAndInvSize.zw - 0.5f) * float2(2, -2), SvPosition.z, 1.0f);
	float4 NDCPosDDX = float4(ResolvedView.ViewSizeAndInvSize.z * 2.0f, 0.0f, PPZ_DDX_DDY.x, 0.0f);
	float4 NDCPosDDY = float4(ResolvedView.ViewSizeAndInvSize.w * 2.0f, 0.0f, PPZ_DDX_DDY.y, 0.0f);

	ScreenPosition = NDCPos * SvPosition.w;
	ScreenPositionDDX = NDCPos * W_DDX_DDY.x + NDCPosDDX * SvPosition.w;
	ScreenPositionDDY = NDCPos * W_DDX_DDY.y + NDCPosDDY * SvPosition.w;
}

float2 SvPositionToViewportUV(float4 SvPosition)
{

	float2 PixelPos = SvPosition.xy - View.ViewRectMin.xy;

	return PixelPos.xy * View.ViewSizeAndInvSize.zw;
}

float2 BufferUVToViewportUV(float2 BufferUV)
{
	float2 PixelPos = BufferUV.xy * View.BufferSizeAndInvSize.xy - View.ViewRectMin.xy;
	return PixelPos.xy * View.ViewSizeAndInvSize.zw;
}

float2 ViewportUVToBufferUV(float2 ViewportUV)
{
	float2 PixelPos = ViewportUV * View.ViewSizeAndInvSize.xy;
	return (PixelPos + View.ViewRectMin.xy) * View.BufferSizeAndInvSize.zw;
}


float2 ViewportUVToScreenPos(float2 ViewportUV)
{
	return float2(2 * ViewportUV.x - 1, 1 - 2 * ViewportUV.y);
}

float2 ScreenPosToViewportUV(float2 ScreenPos)
{
	return float2(0.5 + 0.5 * ScreenPos.x, 0.5 - 0.5 * ScreenPos.y);
}



float3 ScreenToViewPos(float2 ViewportUV, float SceneDepth)
{
	float2 ProjViewPos;

	ProjViewPos.x = ViewportUV.x * View.ScreenToViewSpace.x + View.ScreenToViewSpace.z;
	ProjViewPos.y = ViewportUV.y * View.ScreenToViewSpace.y + View.ScreenToViewSpace.w;
	return float3(ProjViewPos * SceneDepth, SceneDepth);
}
#line 1349 "/Engine/Private/Common.ush"
float2  ScreenAlignedPosition( float4 ScreenPosition )
{
	return  float2 (ScreenPositionToBufferUV(ScreenPosition));
}
#line 1357 "/Engine/Private/Common.ush"
float2  ScreenAlignedUV(  float2  UV )
{
	return (UV* float2 (2,-2) +  float2 (-1,1))*View.ScreenPositionScaleBias.xy + View.ScreenPositionScaleBias.wz;
}
#line 1365 "/Engine/Private/Common.ush"
float2  GetViewportCoordinates( float2  InFragmentCoordinates)
{
	return InFragmentCoordinates;
}
#line 1373 "/Engine/Private/Common.ush"
float4  UnpackNormalMap(  float4  TextureSample )
{



		float2  NormalXY = TextureSample.rg;


	NormalXY = NormalXY *  float2 (2.0f,2.0f) -  float2 (1.0f,1.0f);
	float  NormalZ = sqrt( saturate( 1.0f - dot( NormalXY, NormalXY ) ) );
	return  float4 ( NormalXY.xy, NormalZ, 1.0f );
}


float AntialiasedTextureMask( Texture2D Tex, SamplerState Sampler, float2 UV, float ThresholdConst, int Channel )
{

	float4  MaskConst =  float4 (Channel == 0, Channel == 1, Channel == 2, Channel == 3);


	const float WidthConst = 1.0f;
	float InvWidthConst = 1 / WidthConst;
#line 1417 "/Engine/Private/Common.ush"
	float Result;
	{

		float Sample1 = dot(MaskConst, Texture2DSample(Tex, Sampler, UV));


		float2 TexDD = float2(DDX(Sample1), DDY(Sample1));

		float TexDDLength = max(abs(TexDD.x), abs(TexDD.y));
		float Top = InvWidthConst * (Sample1 - ThresholdConst);
		Result = Top / TexDDLength + ThresholdConst;
	}

	Result = saturate(Result);

	return Result;
}



float Noise3D_Multiplexer(int Function, float3 Position, int Quality, bool bTiling, float RepeatSize)
{

	switch(Function)
	{
		case 0:
			return SimplexNoise3D_TEX(Position);
		case 1:
			return GradientNoise3D_TEX(Position, bTiling, RepeatSize);
		case 2:
			return FastGradientPerlinNoise3D_TEX(Position);
		case 3:
			return GradientNoise3D_ALU(Position, bTiling, RepeatSize);
		case 4:
			return ValueNoise3D_ALU(Position, bTiling, RepeatSize);
		default:
			return VoronoiNoise3D_ALU(Position, Quality, bTiling, RepeatSize, true).w * 2. - 1.;
	}
	return 0;
}



float  MaterialExpressionNoise(float3 Position, float Scale, int Quality, int Function, bool bTurbulence, uint Levels, float OutputMin, float OutputMax, float LevelScale, float FilterWidth, bool bTiling, float RepeatSize)
{
	Position *= Scale;
	FilterWidth *= Scale;

	float Out = 0.0f;
	float OutScale = 1.0f;
	float InvLevelScale = 1.0f / LevelScale;

	[loop]  for(uint i = 0; i < Levels; ++i)
	{

		OutScale *= saturate(1.0 - FilterWidth);

		if(bTurbulence)
		{
			Out += abs(Noise3D_Multiplexer(Function, Position, Quality, bTiling, RepeatSize)) * OutScale;
		}
		else
		{
			Out += Noise3D_Multiplexer(Function, Position, Quality, bTiling, RepeatSize) * OutScale;
		}

		Position *= LevelScale;
		RepeatSize *= LevelScale;
		OutScale *= InvLevelScale;
		FilterWidth *= LevelScale;
	}

	if(!bTurbulence)
	{

		Out = Out * 0.5f + 0.5f;
	}


	return lerp(OutputMin, OutputMax, Out);
}





float4  MaterialExpressionVectorNoise( float3  Position, int Quality, int Function, bool bTiling, float TileSize)
{
	float4 result = float4(0,0,0,1);
	float3x4 Jacobian = JacobianSimplex_ALU(Position, bTiling, TileSize);


	switch (Function)
	{
	case 0:
		result.xyz = float3(Rand3DPCG16(int3(floor(NoiseTileWrap(Position, bTiling, TileSize))))) / 0xffff;
		break;
	case 1:
		result.xyz = float3(Jacobian[0].w, Jacobian[1].w, Jacobian[2].w);
		break;
	case 2:
		result = Jacobian[0];
		break;
	case 3:
		result.xyz = float3(Jacobian[2][1] - Jacobian[1][2], Jacobian[0][2] - Jacobian[2][0], Jacobian[1][0] - Jacobian[0][1]);
		break;
	default:
		result = VoronoiNoise3D_ALU(Position, Quality, bTiling, TileSize, false);
		break;
	}
	return result;
}
#line 1544 "/Engine/Private/Common.ush"
float2 LineBoxIntersect(float3 RayOrigin, float3 RayEnd, float3 BoxMin, float3 BoxMax)
{
	float3 InvRayDir = 1.0f / (RayEnd - RayOrigin);


	float3 FirstPlaneIntersections = (BoxMin - RayOrigin) * InvRayDir;

	float3 SecondPlaneIntersections = (BoxMax - RayOrigin) * InvRayDir;

	float3 ClosestPlaneIntersections = min(FirstPlaneIntersections, SecondPlaneIntersections);

	float3 FurthestPlaneIntersections = max(FirstPlaneIntersections, SecondPlaneIntersections);

	float2 BoxIntersections;

	BoxIntersections.x = max(ClosestPlaneIntersections.x, max(ClosestPlaneIntersections.y, ClosestPlaneIntersections.z));

	BoxIntersections.y = min(FurthestPlaneIntersections.x, min(FurthestPlaneIntersections.y, FurthestPlaneIntersections.z));

	return saturate(BoxIntersections);
}


float  ComputeDistanceFromBoxToPoint( float3  Mins,  float3  Maxs,  float3  InPoint)
{
	float3  DistancesToMin =  select_internal(InPoint < Mins,abs(InPoint - Mins), float (0.0)) ;
	float3  DistancesToMax =  select_internal(InPoint > Maxs,abs(InPoint - Maxs), float (0.0)) ;


	float  Distance = dot(DistancesToMin, 1);
	Distance += dot(DistancesToMax, 1);
	return Distance;
}


float  ComputeSquaredDistanceFromBoxToPoint( float3  BoxCenter,  float3  BoxExtent,  float3  InPoint)
{
	float3  AxisDistances = max(abs(InPoint - BoxCenter) - BoxExtent, 0);
	return dot(AxisDistances, AxisDistances);
}


float ComputeDistanceFromBoxToPointInside(float3 BoxCenter, float3 BoxExtent, float3 InPoint)
{
	float3 DistancesToMin = max(InPoint - BoxCenter + BoxExtent, 0);
	float3 DistancesToMax = max(BoxCenter + BoxExtent - InPoint, 0);
	float3 ClosestDistances = min(DistancesToMin, DistancesToMax);
	return min(ClosestDistances.x, min(ClosestDistances.y, ClosestDistances.z));
}

bool RayHitSphere(float3 RayOrigin, float3 UnitRayDirection, float3 SphereCenter, float SphereRadius)
{
	float3 ClosestPointOnRay = max(0, dot(SphereCenter - RayOrigin, UnitRayDirection)) * UnitRayDirection;
	float3 CenterToRay = RayOrigin + ClosestPointOnRay - SphereCenter;
	return dot(CenterToRay, CenterToRay) <= Square(SphereRadius);
}

bool RaySegmentHitSphere(float3 RayOrigin, float3 UnitRayDirection, float RayLength, float3 SphereCenter, float SphereRadius)
{
	float DistanceAlongRay = dot(SphereCenter - RayOrigin, UnitRayDirection);
	float3 ClosestPointOnRay = DistanceAlongRay * UnitRayDirection;
	float3 CenterToRay = RayOrigin + ClosestPointOnRay - SphereCenter;
	return dot(CenterToRay, CenterToRay) <= Square(SphereRadius) && DistanceAlongRay > -SphereRadius && DistanceAlongRay - SphereRadius < RayLength;
}
#line 1613 "/Engine/Private/Common.ush"
float2 RayIntersectSphere(float3 RayOrigin, float3 RayDirection, float4 Sphere)
{
	float3 LocalPosition = RayOrigin - Sphere.xyz;
	float LocalPositionSqr = dot(LocalPosition, LocalPosition);

	float3 QuadraticCoef;
	QuadraticCoef.x = dot(RayDirection, RayDirection);
	QuadraticCoef.y = 2 * dot(RayDirection, LocalPosition);
	QuadraticCoef.z = LocalPositionSqr - Sphere.w * Sphere.w;

	float Discriminant = QuadraticCoef.y * QuadraticCoef.y - 4 * QuadraticCoef.x * QuadraticCoef.z;

	float2 Intersections = -1;


	[flatten]
	if (Discriminant >= 0)
	{
		float SqrtDiscriminant = sqrt(Discriminant);
		Intersections = (-QuadraticCoef.y + float2(-1, 1) * SqrtDiscriminant) / (2 * QuadraticCoef.x);
	}

	return Intersections;
}


float3  TransformTangentVectorToWorld( float3x3  TangentToWorld,  float3  InTangentVector)
{


	return mul(InTangentVector, TangentToWorld);
}


float3  TransformWorldVectorToTangent( float3x3  TangentToWorld,  float3  InWorldVector)
{


	return mul(TangentToWorld, InWorldVector);
}

float3 TransformWorldVectorToView(float3 InTangentVector)
{

	return mul(InTangentVector, (float3x3)ResolvedView.TranslatedWorldToView);
}


float  GetBoxPushout( float3  Normal, float3  Extent)
{
	return dot(abs(Normal * Extent),  float3 (1.0f, 1.0f, 1.0f));
}


void GenerateCoordinateSystem(float3 ZAxis, out float3 XAxis, out float3 YAxis)
{
	if (abs(ZAxis.x) > abs(ZAxis.y))
	{
		float InverseLength = 1.0f / sqrt(dot(ZAxis.xz, ZAxis.xz));
		XAxis = float3(-ZAxis.z * InverseLength, 0.0f, ZAxis.x * InverseLength);
	}
	else
	{
		float InverseLength = 1.0f / sqrt(dot(ZAxis.yz, ZAxis.yz));
		XAxis = float3(0.0f, ZAxis.z * InverseLength, -ZAxis.y * InverseLength);
	}

	YAxis = cross(ZAxis, XAxis);
}
#line 1692 "/Engine/Private/Common.ush"
struct FScreenVertexOutput
{
	noperspective float2 UV : TEXCOORD0;
	float4 Position : SV_POSITION;
};




float4  EncodeVelocityToTexture(float3 V)
{

		V.xy = sign(V.xy) * sqrt(abs(V.xy)) * (2.0 / sqrt(2.0));




	float4 EncodedV;
	EncodedV.xy = V.xy * (0.499f * 0.5f) + 32767.0f / 65535.0f;


		uint Vz = asuint(V.z);

		EncodedV.z = saturate(float((Vz >> 16) & 0xFFFF) * rcp(65535.0f) + (0.1 / 65535.0f));
		EncodedV.w = saturate(float((Vz >> 0) & 0xFFFF) * rcp(65535.0f) + (0.1 / 65535.0f));
#line 1724 "/Engine/Private/Common.ush"
	return EncodedV;

}

float3 DecodeVelocityFromTexture( float4  InEncodedV)
{



	float4 EncodedV = InEncodedV;

	const float InvDiv = 1.0f / (0.499f * 0.5f);

	float3 V;
	V.xy = EncodedV.xy * InvDiv - 32767.0f / 65535.0f * InvDiv;


		V.z = asfloat((uint(round(EncodedV.z * 65535.0f)) << 16) | uint(round(EncodedV.w * 65535.0f)));
#line 1747 "/Engine/Private/Common.ush"
		V.xy = (V.xy * abs(V.xy)) * 0.5;


	return V;
}


bool GetGIReplaceState()
{



	return false;

}


bool GetNaniteReplaceState()
{



	return false;

}

bool GetRayTracingQualitySwitch()
{



	return false;

}

bool GetPathTracingQualitySwitch()
{



	return false;

}

bool GetLightmassReplaceState()
{



	return false;

}



bool GetRuntimeVirtualTextureOutputSwitch()
{



	return false;

}

struct FWriteToSliceGeometryOutput
{
	FScreenVertexOutput Vertex;
	uint LayerIndex : SV_RenderTargetArrayIndex;
};






void DrawRectangle(
	in float4 InPosition,
	in float2 InTexCoord,
	out float4 OutPosition,
	out float2 OutTexCoord)
{
	OutPosition = InPosition;
	OutPosition.xy = -1.0f + 2.0f * (DrawRectangleParameters.PosScaleBias.zw + (InPosition.xy * DrawRectangleParameters.PosScaleBias.xy)) * DrawRectangleParameters.InvTargetSizeAndTextureSize.xy;
	OutPosition.xy *= float2( 1, -1 );
	OutTexCoord.xy = (DrawRectangleParameters.UVScaleBias.zw + (InTexCoord.xy * DrawRectangleParameters.UVScaleBias.xy)) * DrawRectangleParameters.InvTargetSizeAndTextureSize.zw;
}


void DrawRectangle(
	in float4 InPosition,
	in float2 InTexCoord,
	out float4 OutPosition,
	out float4 OutUVAndScreenPos)
{
	DrawRectangle(InPosition, InTexCoord, OutPosition, OutUVAndScreenPos.xy);
	OutUVAndScreenPos.zw = OutPosition.xy;
}


void DrawRectangle(in float4 InPosition, out float4 OutPosition)
{
	OutPosition = InPosition;
	OutPosition.xy = -1.0f + 2.0f * (DrawRectangleParameters.PosScaleBias.zw + (InPosition.xy * DrawRectangleParameters.PosScaleBias.xy)) * DrawRectangleParameters.InvTargetSizeAndTextureSize.xy;
	OutPosition.xy *= float2( 1, -1 );
}
#line 1864 "/Engine/Private/Common.ush"
float SafeSaturate(float In) { return saturate(In);}
float2 SafeSaturate(float2 In) { return saturate(In);}
float3 SafeSaturate(float3 In) { return saturate(In);}
float4 SafeSaturate(float4 In) { return saturate(In);}
#line 1893 "/Engine/Private/Common.ush"
bool IsFinite(float In) { return (asuint(In) & 0x7F800000) != 0x7F800000; }bool IsPositiveFinite(float In) { return asuint(In) < 0x7F800000; }float MakeFinite(float In) { return select_internal(!IsFinite(In),0.0,In) ; }float MakePositiveFinite(float In) { return select_internal(!IsPositiveFinite(In),0.0,In) ; }
bool2 IsFinite(float2 In) { return (asuint(In) & 0x7F800000) != 0x7F800000; }bool2 IsPositiveFinite(float2 In) { return asuint(In) < 0x7F800000; }float2 MakeFinite(float2 In) { return select_internal(!IsFinite(In),0.0,In) ; }float2 MakePositiveFinite(float2 In) { return select_internal(!IsPositiveFinite(In),0.0,In) ; }
bool3 IsFinite(float3 In) { return (asuint(In) & 0x7F800000) != 0x7F800000; }bool3 IsPositiveFinite(float3 In) { return asuint(In) < 0x7F800000; }float3 MakeFinite(float3 In) { return select_internal(!IsFinite(In),0.0,In) ; }float3 MakePositiveFinite(float3 In) { return select_internal(!IsPositiveFinite(In),0.0,In) ; }
bool4 IsFinite(float4 In) { return (asuint(In) & 0x7F800000) != 0x7F800000; }bool4 IsPositiveFinite(float4 In) { return asuint(In) < 0x7F800000; }float4 MakeFinite(float4 In) { return select_internal(!IsFinite(In),0.0,In) ; }float4 MakePositiveFinite(float4 In) { return select_internal(!IsPositiveFinite(In),0.0,In) ; }





bool GetShadowReplaceState()
{



	return false;

}

bool GetReflectionCapturePassSwitchState()
{
	return View.RenderingReflectionCaptureMask > 0.0f;
}

float IsShadowDepthShader()
{
	return GetShadowReplaceState() ? 1.0f : 0.0f;
}




float DecodePackedTwoChannelValue(float2 PackedHeight)
{
	return PackedHeight.x * 255.0 * 256.0 + PackedHeight.y * 255.0;
}

float DecodeHeightValue(float InValue)
{
	return (InValue - 32768.0) *  (1.0f/128.0f) ;
}

float DecodePackedHeight(float2 PackedHeight)
{
	return DecodeHeightValue(DecodePackedTwoChannelValue(PackedHeight));
}


uint ReverseBitsN(uint Bitfield, const uint BitCount)
{
	return reversebits(Bitfield) >> (32 - BitCount);
}


uint2 ZOrder2D(uint Index, const uint SizeLog2)
{
	uint2 Coord = 0;

	[unroll]
	for (uint i = 0; i < SizeLog2; i++)
	{
		Coord.x |= ((Index >> (2 * i + 0)) & 0x1) << i;
		Coord.y |= ((Index >> (2 * i + 1)) & 0x1) << i;
	}

	return Coord;
}

uint3 ZOrder3D(uint Index, const uint SizeLog2)
{
    uint3 Coord = 0;

    [unroll]
    for (uint i = 0; i < SizeLog2; i++)
    {
        Coord.x |= ((Index >> (3 * i + 0)) & 0x1) << i;
        Coord.y |= ((Index >> (3 * i + 1)) & 0x1) << i;
        Coord.z |= ((Index >> (3 * i + 2)) & 0x1) << i;
    }

    return Coord;
}

uint ZOrder3DEncode(uint3 Coord, const uint SizeLog2)
{
    uint Index = 0;

    [unroll]
    for (uint i = 0; i < SizeLog2; i++)
    {
        Index |= ((Coord.x >> i) & 0x1) << (3 * i + 0);
        Index |= ((Coord.y >> i) & 0x1) << (3 * i + 1);
        Index |= ((Coord.z >> i) & 0x1) << (3 * i + 2);
    }

    return Index;
}



struct FPixelShaderIn
{

	float4 SvPosition;


	uint Coverage;


	bool bIsFrontFace;
};

struct FPixelShaderOut
{

	float4 MRT[8];


	uint StrataOutput[3];


	uint Coverage;


	float Depth;
};
#line 2047 "/Engine/Private/Common.ush"
float4 GatherDepth(Texture2D Texture, float2 UV)
{

	float4 DeviceZ = Texture.GatherRed( D3DStaticBilinearClampedSampler , UV);

	return float4(
		ConvertFromDeviceZ(DeviceZ.x),
		ConvertFromDeviceZ(DeviceZ.y),
		ConvertFromDeviceZ(DeviceZ.z),
		ConvertFromDeviceZ(DeviceZ.w));
}
#line 4 "/Engine/Private/Lumen/LumenSceneDirectLightingCulling.usf"
#line 5 "/Engine/Private/Lumen/LumenSceneDirectLightingCulling.usf"
#line 1 "../DeferredLightingCommon.ush"
#line 9 "/Engine/Private/DeferredLightingCommon.ush"
#line 1 "DeferredShadingCommon.ush"
#line 9 "/Engine/Private/DeferredShadingCommon.ush"
#line 1 "ShadingCommon.ush"
#line 56 "/Engine/Private/ShadingCommon.ush"
float3 GetShadingModelColor(uint ShadingModelID)
{
#line 76 "/Engine/Private/ShadingCommon.ush"
	switch(ShadingModelID)
	{
		case  0 : return float3(0.1f, 0.1f, 0.2f);
		case  1 : return float3(0.1f, 1.0f, 0.1f);
		case  2 : return float3(1.0f, 0.1f, 0.1f);
		case  3 : return float3(0.6f, 0.4f, 0.1f);
		case  4 : return float3(0.1f, 0.4f, 0.4f);
		case  5 : return float3(0.2f, 0.6f, 0.5f);
		case  6 : return float3(0.2f, 0.2f, 0.8f);
		case  7 : return float3(0.6f, 0.1f, 0.5f);
		case  8 : return float3(0.7f, 1.0f, 1.0f);
		case  9 : return float3(0.3f, 1.0f, 1.0f);
		case  10 : return float3(0.5f, 0.5f, 1.0f);
		case  11 : return float3(1.0f, 0.8f, 0.3f);
		case  12 : return float3(1.0f, 1.0f, 0.0f);
		default: return float3(1.0f, 1.0f, 1.0f);
	}

}




bool GetShadingModelRequiresBackfaceLighting(uint ShadingModelID)
{
	return ShadingModelID ==  6 ;
}




float F0ToDielectricSpecular(float F0)
{
	return saturate(F0 / 0.08f);
}

float F0RGBToDielectricSpecular(float3 F0)
{
	return F0ToDielectricSpecular(max(F0.r, max(F0.g, F0.b)));
}

float  DielectricSpecularToF0( float  Specular)
{
	return 0.08f * Specular;
}


float DielectricF0ToIor(float F0)
{
	return 2.0f / (1.0f - sqrt(F0)) - 1.0f;
}

float DielectricIorToF0(float Ior)
{
	const float F0Sqrt = (Ior-1)/(Ior+1);
	const float F0 = F0Sqrt*F0Sqrt;
	return F0;
}


float GetF0MicroOcclusionThreshold() { return 0.02f; }
float F0ToMicroOcclusion(float F0) { return saturate(50.0 * F0); }
float3 F0ToMicroOcclusion(float3 F0) { return saturate(50.0 * F0); }

float F0RGBToMicroOcclusion(float3 F0)
{
	return F0ToMicroOcclusion(max(F0.r, max(F0.g, F0.b)));
}

float3  ComputeF0( float  Specular,  float3  BaseColor,  float  Metallic)
{
	return lerp(DielectricSpecularToF0(Specular).xxx, BaseColor, Metallic.xxx);
}

float3 ComputeF90(float3 F0, float3 EdgeColor, float Metallic)
{
	return lerp(1.0, EdgeColor, Metallic.xxx);
}

float3 ComputeDiffuseAlbedo(float3 BaseColor, float Metallic)
{
	return BaseColor - BaseColor * Metallic;
}

float MakeRoughnessSafe(float Roughness, float MinRoughness=0.001f)
{
	return clamp(Roughness, MinRoughness, 1.0f);
}

float ComputeHazyLobeRoughness(float Roughness, float Haziness)
{
	return lerp(Roughness, 1.0f, Haziness);
}

float F0ToMetallic(float F0)
{

	const float DiamondF0 = 0.24f;
	const float CondutorMinF0 = 0.4f;


	return saturate((F0 - DiamondF0) / (CondutorMinF0 - DiamondF0));
}

float F0RGBToMetallic(float3 F0)
{
	return F0ToMetallic(max(F0.r, max(F0.g, F0.b)));
}





struct FVerticalLayeringInfo
{
	float TransmittanceTopAndBottom;
	float TransmittanceOnlyBottom;
	float TransmittanceOnlyTop;

	float SurfaceBottom;
	float SurfaceTop;

	float Coverage;
	float NoSurface;
};



FVerticalLayeringInfo GetVerticalLayeringInfo(const float TopCoverage, const float BottomCoverage)
{
	FVerticalLayeringInfo Info;

	Info.TransmittanceTopAndBottom = TopCoverage * BottomCoverage;
	Info.TransmittanceOnlyBottom = (1.0f - TopCoverage) * BottomCoverage;
	Info.TransmittanceOnlyTop = (1.0f - BottomCoverage) * TopCoverage;

	Info.SurfaceBottom = Info.TransmittanceOnlyBottom;
	Info.SurfaceTop = TopCoverage;

	Info.Coverage = Info.SurfaceTop + Info.SurfaceBottom;
	Info.NoSurface = 1.0f - Info.Coverage;

	return Info;
}
#line 10 "/Engine/Private/DeferredShadingCommon.ush"
#line 1 "LightAccumulator.ush"
#line 24 "/Engine/Private/LightAccumulator.ush"
struct FLightAccumulator
{
	float3 TotalLight;




	float ScatterableLightLuma;




	float3 ScatterableLight;



	float EstimatedCost;



	float3 TotalLightDiffuse;
	float3 TotalLightSpecular;

};

struct FDeferredLightingSplit
{
	float4 DiffuseLighting;
	float4 SpecularLighting;
};


void LightAccumulator_AddSplit(inout FLightAccumulator In, float3 DiffuseTotalLight, float3 SpecularTotalLight, float3 ScatterableLight, float3 CommonMultiplier, const bool bNeedsSeparateSubsurfaceLightAccumulation)
{

	In.TotalLight += (DiffuseTotalLight + SpecularTotalLight) * CommonMultiplier;


	if (bNeedsSeparateSubsurfaceLightAccumulation)
	{
		if ( 1  == 1)
		{
			if (View.bCheckerboardSubsurfaceProfileRendering == 0)
			{
				In.ScatterableLightLuma += Luminance(ScatterableLight * CommonMultiplier);
			}
		}
		else if ( 1  == 2)
		{

			In.ScatterableLight += ScatterableLight * CommonMultiplier;
		}
	}

	In.TotalLightDiffuse += DiffuseTotalLight * CommonMultiplier;
	In.TotalLightSpecular += SpecularTotalLight * CommonMultiplier;
}

void LightAccumulator_Add(inout FLightAccumulator In, float3 TotalLight, float3 ScatterableLight, float3 CommonMultiplier, const bool bNeedsSeparateSubsurfaceLightAccumulation)
{
	LightAccumulator_AddSplit(In, TotalLight, 0.0f, ScatterableLight, CommonMultiplier, bNeedsSeparateSubsurfaceLightAccumulation);
}




float4 LightAccumulator_GetResult(FLightAccumulator In)
{
	float4 Ret;

	if ( 0  == 1)
	{

		Ret = 0.1f * float4(1.0f, 0.25f, 0.075f, 0) * In.EstimatedCost;
	}
	else
	{
		Ret = float4(In.TotalLight, 0);

		if ( 1  == 1 )
		{
			if (View.bCheckerboardSubsurfaceProfileRendering == 0)
			{

				Ret.a = In.ScatterableLightLuma;
			}
		}
		else if ( 1  == 2)
		{


			Ret.a = Luminance(In.ScatterableLight);

		}
	}

	return Ret;
}


FDeferredLightingSplit LightAccumulator_GetResultSplit(FLightAccumulator In)
{
	float4 RetDiffuse;
	float4 RetSpecular;

	if ( 0  == 1)
	{

		RetDiffuse = 0.1f * float4(1.0f, 0.25f, 0.075f, 0) * In.EstimatedCost;
		RetSpecular = 0.1f * float4(1.0f, 0.25f, 0.075f, 0) * In.EstimatedCost;
	}
	else
	{
		RetDiffuse = float4(In.TotalLightDiffuse, 0);
		RetSpecular = float4(In.TotalLightSpecular, 0);

		if ( 1  == 1 )
		{
			if (View.bCheckerboardSubsurfaceProfileRendering == 0)
			{

				RetDiffuse.a = In.ScatterableLightLuma;
			}
		}
		else if ( 1  == 2)
		{


			RetDiffuse.a = Luminance(In.ScatterableLight);

		}
	}

	FDeferredLightingSplit Ret;
	Ret.DiffuseLighting = RetDiffuse;
	Ret.SpecularLighting = RetSpecular;

	return Ret;
}

struct FStrataDeferredLighting
{
	float4 SceneColor;
#line 171 "/Engine/Private/LightAccumulator.ush"
};

FStrataDeferredLighting GetInitialisedStrataDeferredLighting()
{
	FStrataDeferredLighting Result = (FStrataDeferredLighting)0;
	return Result;
}

void AccumulateStrataDeferredLighting(inout FStrataDeferredLighting StrataLighting, FLightAccumulator In, bool bDiffuseIsSubsurface, bool bIsToplayer)
{
	FDeferredLightingSplit DiffSpec = LightAccumulator_GetResultSplit(In);
#line 197 "/Engine/Private/LightAccumulator.ush"
	StrataLighting.SceneColor += DiffSpec.DiffuseLighting + DiffSpec.SpecularLighting;

}
#line 11 "/Engine/Private/DeferredShadingCommon.ush"
#line 1 "SceneTexturesCommon.ush"
#line 41 "/Engine/Private/SceneTexturesCommon.ush"
float3 CalcSceneColor(float2 ScreenUV)
{



	return Texture2DSampleLevel(SceneTexturesStruct.SceneColorTexture,  SceneTexturesStruct.PointClampSampler , ScreenUV, 0).rgb;

}

float4 CalcFullSceneColor(float2 ScreenUV)
{



	return Texture2DSample(SceneTexturesStruct.SceneColorTexture,  SceneTexturesStruct.PointClampSampler ,ScreenUV);

}


float CalcSceneDepth(float2 ScreenUV)
{



	return ConvertFromDeviceZ(Texture2DSampleLevel(SceneTexturesStruct.SceneDepthTexture,  SceneTexturesStruct.PointClampSampler , ScreenUV, 0).r);

}


float4 CalcSceneColorAndDepth( float2 ScreenUV )
{
	return float4(CalcSceneColor(ScreenUV), CalcSceneDepth(ScreenUV));
}


float LookupDeviceZ( float2 ScreenUV )
{




	return Texture2DSampleLevel(SceneTexturesStruct.SceneDepthTexture,  SceneTexturesStruct.PointClampSampler , ScreenUV, 0).r;

}


float LookupDeviceZ(uint2 PixelPos)
{



	return SceneTexturesStruct.SceneDepthTexture.Load(int3(PixelPos, 0)).r;

}


float CalcSceneDepth(uint2 PixelPos)
{



	float DeviceZ = SceneTexturesStruct.SceneDepthTexture.Load(int3(PixelPos, 0)).r;


	return ConvertFromDeviceZ(DeviceZ);

}


float4 GatherSceneDepth(float2 UV, float2 InvBufferSize)
{



	return GatherDepth(SceneTexturesStruct.SceneDepthTexture, UV);

}


float CalcSceneCustomDepth(float2 ScreenUV)
{



	return ConvertFromDeviceZ(Texture2DSampleLevel(SceneTexturesStruct.CustomDepthTexture,  SceneTexturesStruct.PointClampSampler , ScreenUV, 0).r);

}

uint CalcSceneCustomStencil(uint2 PixelPos)
{



	return SceneTexturesStruct.CustomStencilTexture.Load(uint3(PixelPos, 0))  .g ;

}

float CalcSceneAO(float2 ScreenUV)
{



	return Texture2DSampleLevel(SceneTexturesStruct.ScreenSpaceAOTexture,  SceneTexturesStruct.PointClampSampler , ScreenUV, 0).r;

}
#line 12 "/Engine/Private/DeferredShadingCommon.ush"
#line 1 "MonteCarlo.ush"
#line 13 "/Engine/Private/MonteCarlo.ush"
float3x3 GetTangentBasis( float3 TangentZ )
{
	const float Sign = TangentZ.z >= 0 ? 1 : -1;
	const float a = -rcp( Sign + TangentZ.z );
	const float b = TangentZ.x * TangentZ.y * a;

	float3 TangentX = { 1 + Sign * a * Pow2( TangentZ.x ), Sign * b, -Sign * TangentZ.x };
	float3 TangentY = { b, Sign + a * Pow2( TangentZ.y ), -TangentZ.y };

	return float3x3( TangentX, TangentY, TangentZ );
}



float3x3 GetTangentBasisFrisvad(float3 TangentZ)
{
	float3 TangentX;
	float3 TangentY;

	if (TangentZ.z < -0.9999999f)
	{
		TangentX = float3(0, -1, 0);
		TangentY = float3(-1, 0, 0);
	}
	else
	{
		float A = 1.0f / (1.0f + TangentZ.z);
		float B = -TangentZ.x * TangentZ.y * A;
		TangentX = float3(1.0f - TangentZ.x * TangentZ.x * A, B, -TangentZ.x);
		TangentY = float3(B, 1.0f - TangentZ.y * TangentZ.y * A, -TangentZ.y);
	}

	return float3x3( TangentX, TangentY, TangentZ );
}

float3 TangentToWorld( float3 Vec, float3 TangentZ )
{
	return mul( Vec, GetTangentBasis( TangentZ ) );
}

float3 WorldToTangent(float3 Vec, float3 TangentZ)
{
	return mul(GetTangentBasis(TangentZ), Vec);
}

float2 Hammersley( uint Index, uint NumSamples, uint2 Random )
{
	float E1 = frac( (float)Index / NumSamples + float( Random.x & 0xffff ) / (1<<16) );
	float E2 = float( reversebits(Index) ^ Random.y ) * 2.3283064365386963e-10;
	return float2( E1, E2 );
}

float2 Hammersley16( uint Index, uint NumSamples, uint2 Random )
{
	float E1 = frac( (float)Index / NumSamples + float( Random.x ) * (1.0 / 65536.0) );
	float E2 = float( ( reversebits(Index) >> 16 ) ^ Random.y ) * (1.0 / 65536.0);
	return float2( E1, E2 );
}


float2 R2Sequence( uint Index )
{
	const float Phi = 1.324717957244746;
	const float2 a = float2( 1.0 / Phi, 1.0 / Pow2(Phi) );
	return frac( a * Index );
}



float2 JitteredR2( uint Index, uint NumSamples, float2 Jitter, float JitterAmount = 0.5 )
{
	const float Phi = 1.324717957244746;
	const float2 a = float2( 1.0 / Phi, 1.0 / Pow2(Phi) );
	const float d0 = 0.76;
	const float i0 = 0.7;

	return frac( a * float(Index) + ( JitterAmount * 0.5 * d0 * sqrt(PI) * rsqrt( float(NumSamples) ) ) * Jitter );
}


float2 JitteredR2( uint Index, float2 Jitter, float JitterAmount = 0.5 )
{
	const float Phi = 1.324717957244746;
	const float2 a = float2( 1.0 / Phi, 1.0 / Pow2(Phi) );
	const float d0 = 0.76;
	const float i0 = 0.7;

	return frac( a * Index + ( JitterAmount * 0.25 * d0 * sqrt(PI) * rsqrt( Index - i0 ) ) * Jitter );
}




float2 UniformSampleDisk( float2 E )
{
	float Theta = 2 * PI * E.x;
	float Radius = sqrt( E.y );
	return Radius * float2( cos( Theta ), sin( Theta ) );
}


float3 ConcentricDiskSamplingHelper(float2 E)
{

	float2 p = 2 * E - 0.99999994;
	float2 a = abs(p);
	float Lo = min(a.x, a.y);
	float Hi = max(a.x, a.y);
	float Epsilon = 5.42101086243e-20;
	float Phi = (PI / 4) * (Lo / (Hi + Epsilon) + 2 * float(a.y >= a.x));
	float Radius = Hi;

	const uint SignMask = 0x80000000;
	float2 Disk = asfloat((asuint(float2(cos(Phi), sin(Phi))) & ~SignMask) | (asuint(p) & SignMask));

	return float3(Disk, Radius);
}

float2 UniformSampleDiskConcentric( float2 E )
{
	float3 Result = ConcentricDiskSamplingHelper(E);
	return Result.xy * Result.z;
}



float2 UniformSampleDiskConcentricApprox( float2 E )
{
	float2 sf = E * sqrt(2.0) - sqrt(0.5);
	float2 sq = sf*sf;
	float root = sqrt(2.0*max(sq.x, sq.y) - min(sq.x, sq.y));
	if (sq.x > sq.y)
	{
		sf.x = sf.x > 0 ? root : -root;
	}
	else
	{
		sf.y = sf.y > 0 ? root : -root;
	}
	return sf;
}





float3 EquiAreaSphericalMapping(float2 UV)
{
	UV = 2 * UV - 1;
	float D = 1 - (abs(UV.x) + abs(UV.y));
	float R = 1 - abs(D);
	float Epsilon = 5.42101086243e-20;
	float Phi = (PI / 4) * ((abs(UV.y) - abs(UV.x)) / (R + Epsilon) + 1);
	float F = R * sqrt(2 - R * R);
	return float3(
		F * sign(UV.x) * abs(cos(Phi)),
		F * sign(UV.y) * abs(sin(Phi)),
		sign(D) * (1 - R * R)
	);
}




float2 InverseEquiAreaSphericalMapping(float3 Direction)
{
	float3 AbsDir = abs(Direction);
	float R = sqrt(1 - AbsDir.z);
	float Epsilon = 5.42101086243e-20;
	float x = min(AbsDir.x, AbsDir.y) / (max(AbsDir.x, AbsDir.y) + Epsilon);


	const float t1 = 0.406758566246788489601959989e-5f;
	const float t2 = 0.636226545274016134946890922156f;
	const float t3 = 0.61572017898280213493197203466e-2f;
	const float t4 = -0.247333733281268944196501420480f;
	const float t5 = 0.881770664775316294736387951347e-1f;
	const float t6 = 0.419038818029165735901852432784e-1f;
	const float t7 = -0.251390972343483509333252996350e-1f;


	float Phi = t6 + t7 * x;
	Phi = t5 + Phi * x;
	Phi = t4 + Phi * x;
	Phi = t3 + Phi * x;
	Phi = t2 + Phi * x;
	Phi = t1 + Phi * x;

	Phi = (AbsDir.x < AbsDir.y) ? 1 - Phi : Phi;
	float2 UV = float2(R - Phi * R, Phi * R);
	UV = (Direction.z < 0) ? 1 - UV.yx : UV;
	UV = asfloat(asuint(UV) ^ (asuint(Direction.xy) & 0x80000000u));
	return UV * 0.5 + 0.5;
}



float4 UniformSampleSphere( float2 E )
{
	float Phi = 2 * PI * E.x;
	float CosTheta = 1 - 2 * E.y;
	float SinTheta = sqrt( 1 - CosTheta * CosTheta );

	float3 H;
	H.x = SinTheta * cos( Phi );
	H.y = SinTheta * sin( Phi );
	H.z = CosTheta;

	float PDF = 1.0 / (4 * PI);

	return float4( H, PDF );
}


float4 UniformSampleHemisphere( float2 E )
{
	float Phi = 2 * PI * E.x;
	float CosTheta = E.y;
	float SinTheta = sqrt( 1 - CosTheta * CosTheta );

	float3 H;
	H.x = SinTheta * cos( Phi );
	H.y = SinTheta * sin( Phi );
	H.z = CosTheta;

	float PDF = 1.0 / (2 * PI);

	return float4( H, PDF );
}


float4 CosineSampleHemisphere( float2 E )
{
	float Phi = 2 * PI * E.x;
	float CosTheta = sqrt(E.y);
	float SinTheta = sqrt(1 - CosTheta * CosTheta);

	float3 H;
	H.x = SinTheta * cos(Phi);
	H.y = SinTheta * sin(Phi);
	H.z = CosTheta;

	float PDF = CosTheta * (1.0 / PI);

	return float4(H, PDF);
}


float4 CosineSampleHemisphereConcentric(float2 E)
{
	float3 Result = ConcentricDiskSamplingHelper(E);
	float SinTheta = Result.z;
	float CosTheta = sqrt(1 - SinTheta * SinTheta);
	return float4(Result.xy * SinTheta, CosTheta, CosTheta * (1.0 / PI));
}


float4 CosineSampleHemisphere( float2 E, float3 N )
{
	float3 H = UniformSampleSphere( E ).xyz;
	H = normalize( N + H );

	float PDF = dot(H, N) * (1.0 / PI);

	return float4( H, PDF );
}

float4 UniformSampleCone( float2 E, float CosThetaMax )
{
	float Phi = 2 * PI * E.x;
	float CosTheta = lerp( CosThetaMax, 1, E.y );
	float SinTheta = sqrt( 1 - CosTheta * CosTheta );

	float3 L;
	L.x = SinTheta * cos( Phi );
	L.y = SinTheta * sin( Phi );
	L.z = CosTheta;

	float PDF = 1.0 / ( 2 * PI * (1 - CosThetaMax) );

	return float4( L, PDF );
}




float4 UniformSampleConeRobust(float2 E, float SinThetaMax2)
{
	float Phi = 2 * PI * E.x;



	float OneMinusCosThetaMax = SinThetaMax2 < 0.01 ? SinThetaMax2 * (0.5 + 0.125 * SinThetaMax2) : 1 - sqrt(1 - SinThetaMax2);

	float CosTheta = 1 - OneMinusCosThetaMax * E.y;
	float SinTheta = sqrt(1 - CosTheta * CosTheta);

	float3 L;
	L.x = SinTheta * cos(Phi);
	L.y = SinTheta * sin(Phi);
	L.z = CosTheta;
	float PDF = 1.0 / (2 * PI * OneMinusCosThetaMax);

	return float4(L, PDF);
}

float UniformConeSolidAngle(float SinThetaMax2)
{
	float OneMinusCosThetaMax = SinThetaMax2 < 0.01 ? SinThetaMax2 * (0.5 + 0.125 * SinThetaMax2) : 1 - sqrt(1 - SinThetaMax2);
	return 2 * PI * OneMinusCosThetaMax;
}


float4 UniformSampleConeConcentricRobust(float2 E, float SinThetaMax2)
{



	float OneMinusCosThetaMax = SinThetaMax2 < 0.01 ? SinThetaMax2 * (0.5 + 0.125 * SinThetaMax2) : 1 - sqrt(1 - SinThetaMax2);
	float3 Result = ConcentricDiskSamplingHelper(E);
	float SinTheta = Result.z * sqrt(SinThetaMax2);
	float CosTheta = sqrt(1 - SinTheta * SinTheta);

	float3 L = float3(Result.xy * SinTheta, CosTheta);
	float PDF = 1.0 / (2 * PI * OneMinusCosThetaMax);

	return float4(L, PDF);
}


float4 ImportanceSampleGGX( float2 E, float a2 )
{
	float Phi = 2 * PI * E.x;
	float CosTheta = sqrt( (1 - E.y) / ( 1 + (a2 - 1) * E.y ) );
	float SinTheta = sqrt( 1 - CosTheta * CosTheta );

	float3 H;
	H.x = SinTheta * cos( Phi );
	H.y = SinTheta * sin( Phi );
	H.z = CosTheta;

	float d = ( CosTheta * a2 - CosTheta ) * CosTheta + 1;
	float D = a2 / ( PI*d*d );
	float PDF = D * CosTheta;

	return float4( H, PDF );
}

float VisibleGGXPDF(float3 V, float3 H, float a2)
{
	float NoV = V.z;
	float NoH = H.z;
	float VoH = dot(V, H);

	float d = (NoH * a2 - NoH) * NoH + 1;
	float D = a2 / (PI*d*d);

	float PDF = 2 * VoH * D / (NoV + sqrt(NoV * (NoV - NoV * a2) + a2));
	return PDF;
}

float VisibleGGXPDF_aniso(float3 V, float3 H, float2 Alpha)
{
	float NoV = V.z;
	float NoH = H.z;
	float VoH = dot(V, H);
	float a2 = Alpha.x * Alpha.y;
	float3 Hs = float3(Alpha.y * H.x, Alpha.x * H.y, a2 * NoH);
	float S = dot(Hs, Hs);
	float D = (1.0f / PI) * a2 * Square(a2 / S);
	float LenV = length(float3(V.x * Alpha.x, V.y * Alpha.y, NoV));
	float Pdf = (2 * D * VoH) / (NoV + LenV);
	return Pdf;
}





float4 ImportanceSampleVisibleGGX( float2 DiskE, float a2, float3 V )
{

	float a = sqrt(a2);


	float3 Vh = normalize( float3( a * V.xy, V.z ) );



	float LenSq = Vh.x * Vh.x + Vh.y * Vh.y;
	float3 Tangent0 = LenSq > 0 ? float3(-Vh.y, Vh.x, 0) * rsqrt(LenSq) : float3(1, 0, 0);
	float3 Tangent1 = cross(Vh, Tangent0);

	float2 p = DiskE;
	float s = 0.5 + 0.5 * Vh.z;
	p.y = (1 - s) * sqrt( 1 - p.x * p.x ) + s * p.y;

	float3 H;
	H = p.x * Tangent0;
	H += p.y * Tangent1;
	H += sqrt( saturate( 1 - dot( p, p ) ) ) * Vh;


	H = normalize( float3( a * H.xy, max(0.0, H.z) ) );

	return float4(H, VisibleGGXPDF(V, H, a2));
}





float4 ImportanceSampleVisibleGGX_aniso(float2 DiskE, float2 Alpha, float3 V)
{

	float3 Vh = normalize(float3(Alpha * V.xy, V.z));


	float LenSq = Vh.x * Vh.x + Vh.y * Vh.y;
	float3 Tx = LenSq > 0 ? float3(-Vh.y, Vh.x, 0) * rsqrt(LenSq) : float3(1, 0, 0);
	float3 Ty = cross(Vh, Tx);

	float2 p = DiskE;
	float s = 0.5 + 0.5 * Vh.z;
	p.y = lerp(sqrt(1 - p.x * p.x), p.y, s);

	float3 H = p.x * Tx + p.y * Ty + sqrt(saturate(1 - dot(p, p))) * Vh;


	H = normalize(float3(Alpha * H.xy, max(0.0, H.z)));

	return float4(H, VisibleGGXPDF_aniso(V, H, Alpha));
}



float MISWeight( uint Num, float PDF, uint OtherNum, float OtherPDF )
{
	float Weight = Num * PDF;
	float OtherWeight = OtherNum * OtherPDF;
	return Weight * Weight / (Weight * Weight + OtherWeight * OtherWeight);
}


float MISWeightBalanced(float Pdf, float OtherPdf)
{



	if (Pdf == OtherPdf)
	{

		return 0.5f;
	}






	if (OtherPdf < Pdf)
	{
		float x = OtherPdf / Pdf;
		return 1.0 / (1.0 + x);
	}
	else
	{

		float x = Pdf / OtherPdf;
		return 1.0 - 1.0 / (1.0 + x);
	}
}


float MISWeightRobust(float Pdf, float OtherPdf) {










	if (Pdf == OtherPdf)
	{

		return 0.5f;
	}






	if (OtherPdf < Pdf)
	{
		float x = OtherPdf / Pdf;
		return 1.0 / (1.0 + x * x);
	}
	else
	{

		float x = Pdf / OtherPdf;
		return 1.0 - 1.0 / (1.0 + x * x);
	}
}



float RayPDFToReflectionRayPDF(float VoH, float RayPDF)
{
	float ReflectPDF = RayPDF / (4.0 * saturate(VoH));

	return ReflectPDF;
}
#line 13 "/Engine/Private/DeferredShadingCommon.ush"
#line 1 "OctahedralCommon.ush"
#line 18 "/Engine/Private/OctahedralCommon.ush"
float2 UnitVectorToOctahedron( float3 N )
{
	N.xy /= dot( 1, abs(N) );
	if( N.z <= 0 )
	{
		N.xy = ( 1 - abs(N.yx) ) *  select_internal(N.xy >= 0,float2(1,1),float2(-1,-1)) ;
	}
	return N.xy;
}

float3 OctahedronToUnitVector( float2 Oct )
{
	float3 N = float3( Oct, 1 - dot( 1, abs(Oct) ) );
	float t = max( -N.z, 0 );
	N.xy +=  select_internal(N.xy >= 0,float2(-t, -t),float2(t, t)) ;
	return normalize(N);
}

float2 UnitVectorToHemiOctahedron( float3 N )
{
	N.xy /= dot( 1, abs(N) );
	return float2( N.x + N.y, N.x - N.y );
}

float3 HemiOctahedronToUnitVector( float2 Oct )
{
	Oct = float2( Oct.x + Oct.y, Oct.x - Oct.y );
	float3 N = float3( Oct, 2.0 - dot( 1, abs(Oct) ) );
	return normalize(N);
}


uint2 OctahedralMapWrapBorder(uint2 TexelCoord, uint Resolution, uint BorderSize)
{
	if (TexelCoord.x < BorderSize)
	{
		TexelCoord.x = BorderSize - 1 + BorderSize - TexelCoord.x;
		TexelCoord.y = Resolution - 1 - TexelCoord.y;
	}
	if (TexelCoord.x >= Resolution - BorderSize)
	{
		TexelCoord.x = (Resolution - BorderSize) - (TexelCoord.x - (Resolution - BorderSize - 1));
		TexelCoord.y = Resolution - 1 - TexelCoord.y;
	}
	if (TexelCoord.y < BorderSize)
	{
		TexelCoord.y = BorderSize - 1 + BorderSize - TexelCoord.y;
		TexelCoord.x = Resolution - 1 - TexelCoord.x;
	}
	if (TexelCoord.y >= Resolution - BorderSize)
	{
		TexelCoord.y = (Resolution - BorderSize) - (TexelCoord.y - (Resolution - BorderSize - 1));
		TexelCoord.x = Resolution - 1 - TexelCoord.x;
	}

	return TexelCoord - BorderSize;
}



float ComputeSphericalExcess(float3 A, float3 B, float3 C) {
    float CosAB = dot(A, B);
    float SinAB = 1.0f - CosAB * CosAB;
    float CosBC = dot(B, C);
    float SinBC = 1.0f - CosBC * CosBC;
    float CosCA = dot(C, A);
    float CosC = CosCA - CosAB * CosBC;
    float SinC = sqrt(SinAB * SinBC - CosC * CosC);
    float Inv = (1.0f - CosAB) * (1.0f - CosBC);
	return 2.0f * atan2(SinC, sqrt((SinAB * SinBC * (1.0f + CosBC) * (1.0f + CosAB)) / Inv) + CosC);
}


float OctahedralSolidAngle(float2 TexelCoord, float InvResolution)
{
	float3 Direction10 = OctahedronToUnitVector((TexelCoord + float2(.5f, -.5f) * InvResolution) * 2.0f - 1.0f);
	float3 Direction01 = OctahedronToUnitVector((TexelCoord + float2(-.5f, .5f) * InvResolution) * 2.0f - 1.0f);

	float SolidAngle0 = ComputeSphericalExcess(
		OctahedronToUnitVector((TexelCoord + float2(-.5f, -.5f) * InvResolution) * 2.0f - 1.0f),
		Direction10,
		Direction01);

	float SolidAngle1 = ComputeSphericalExcess(
		OctahedronToUnitVector((TexelCoord + float2(.5f, .5f) * InvResolution) * 2.0f - 1.0f),
		Direction01,
		Direction10);

	return SolidAngle0 + SolidAngle1;
}
#line 14 "/Engine/Private/DeferredShadingCommon.ush"
#line 26 "/Engine/Private/DeferredShadingCommon.ush"
uint bSceneLightingChannelsValid;


Texture2D SceneDepthTexture;
Texture2D<uint2> SceneStencilTexture;
Texture2D GBufferATexture;
Texture2D GBufferBTexture;
Texture2D GBufferCTexture;
Texture2D GBufferDTexture;
Texture2D GBufferETexture;
Texture2D GBufferVelocityTexture;
Texture2D GBufferFTexture;
Texture2D<uint> SceneLightingChannels;










float SampleDeviceZFromSceneTextures(float2 UV)
{
	return SceneDepthTexture.SampleLevel( D3DStaticPointClampedSampler , UV, 0).r;
}









float3 RGBToYCoCg( float3 RGB )
{
	float Y = dot( RGB, float3( 1, 2, 1 ) ) * 0.25;
	float Co = dot( RGB, float3( 2, 0, -2 ) ) * 0.25 + ( 0.5 * 256.0 / 255.0 );
	float Cg = dot( RGB, float3( -1, 2, -1 ) ) * 0.25 + ( 0.5 * 256.0 / 255.0 );

	float3 YCoCg = float3( Y, Co, Cg );
	return YCoCg;
}

float3 YCoCgToRGB( float3 YCoCg )
{
	float Y = YCoCg.x;
	float Co = YCoCg.y - ( 0.5 * 256.0 / 255.0 );
	float Cg = YCoCg.z - ( 0.5 * 256.0 / 255.0 );

	float R = Y + Co - Cg;
	float G = Y + Cg;
	float B = Y - Co - Cg;

	float3 RGB = float3( R, G, B );
	return RGB;
}

float3 Pack1212To888( float2 x )
{








	float2 x1212 = floor( x * 4095 );
	float2 High = floor( x1212 / 256 );
	float2 Low = x1212 - High * 256;
	float3 x888 = float3( Low, High.x + High.y * 16 );
	return saturate( x888 / 255 );

}

float2 Pack888To1212( float3 x )
{








	float3 x888 = floor( x * 255 );
	float High = floor( x888.z / 16 );
	float Low = x888.z - High * 16;
	float2 x1212 = x888.xy + float2( Low, High ) * 256;
	return saturate( x1212 / 4095 );

}

float3 EncodeNormal( float3 N )
{
	return N * 0.5 + 0.5;

}

float3 DecodeNormal( float3 N )
{
	return N * 2 - 1;

}

void EncodeNormal( inout float3 N, out uint Face )
{

	uint Axis = 2;
	if( abs(N.x) >= abs(N.y) && abs(N.x) >= abs(N.z) )
	{
		Axis = 0;
	}
	else if( abs(N.y) > abs(N.z) )
	{
		Axis = 1;
	}
	Face = Axis * 2;
#line 153 "/Engine/Private/DeferredShadingCommon.ush"
	N = Axis == 0 ? N.yzx : N;
	N = Axis == 1 ? N.xzy : N;

	float MaxAbs = 1.0 / sqrt(2.0);

	Face += N.z > 0 ? 0 : 1;
	N.xy *= N.z > 0 ? 1 : -1;
	N.xy = N.xy * (0.5 / MaxAbs) + 0.5;
}

void DecodeNormal( inout float3 N, in uint Face )
{
	uint Axis = Face >> 1;

	float MaxAbs = 1.0 / sqrt(2.0);

	N.xy = N.xy * (2 * MaxAbs) - (1 * MaxAbs);
	N.z = sqrt( 1 - dot( N.xy, N.xy ) );

	N = Axis == 0 ? N.zxy : N;
	N = Axis == 1 ? N.xzy : N;
	N *= (Face & 1) ? -1 : 1;
}

float3 EncodeBaseColor(float3 BaseColor)
{

	return BaseColor;
}

float3 DecodeBaseColor(float3 BaseColor)
{

	return BaseColor;
}

float3 EncodeSubsurfaceColor(float3 SubsurfaceColor)
{
	return sqrt(saturate(SubsurfaceColor));
}


float3 EncodeSubsurfaceProfile(float SubsurfaceProfile)
{
	return float3(SubsurfaceProfile, 0, 0);
}


float SubsurfaceDensityFromOpacity(float Opacity)
{
	return (-0.05f * log(1.0f - min(Opacity, 0.99f)));
}

float EncodeIndirectIrradiance(float IndirectIrradiance)
{
	float L = IndirectIrradiance;
	L *= View.PreExposure;
	const float LogBlackPoint = 0.00390625;
	return log2( L + LogBlackPoint ) / 16 + 0.5;
}

float DecodeIndirectIrradiance(float IndirectIrradiance)
{

	float LogL = IndirectIrradiance;
	const float LogBlackPoint = 0.00390625;
	return View.OneOverPreExposure * (exp2( LogL * 16 - 8 ) - LogBlackPoint);
}

float4 EncodeWorldTangentAndAnisotropy(float3 WorldTangent, float Anisotropy)
{
	return float4(
		EncodeNormal(WorldTangent),
		Anisotropy * 0.5f + 0.5f
		);
}

float ComputeAngleFromRoughness( float Roughness, const float Threshold = 0.04f )
{

	float Angle = 3 * Square( Roughness );
#line 239 "/Engine/Private/DeferredShadingCommon.ush"
	return Angle;
}

float ComputeRoughnessFromAngle( float Angle, const float Threshold = 0.04f )
{

	float Roughness = sqrt( 0.33333 * Angle );
#line 251 "/Engine/Private/DeferredShadingCommon.ush"
	return Roughness;
}

float AddAngleToRoughness( float Angle, float Roughness )
{
	return saturate( sqrt( Square( Roughness ) + 0.33333 * Angle ) );
}




float Encode71(float Scalar, uint Mask)
{
	return
		127.0f / 255.0f * saturate(Scalar) +
		128.0f / 255.0f * Mask;
}





float Decode71(float Scalar, out uint Mask)
{
	Mask = (uint)(Scalar > 0.5f);

	return (Scalar - 0.5f * Mask) * 2.0f;
}

float EncodeShadingModelIdAndSelectiveOutputMask(uint ShadingModelId, uint SelectiveOutputMask)
{
	uint Value = (ShadingModelId &  0xF ) | SelectiveOutputMask;
	return (float)Value / (float)0xFF;
}

uint DecodeShadingModelId(float InPackedChannel)
{
	return ((uint)round(InPackedChannel * (float)0xFF)) &  0xF ;
}

uint DecodeSelectiveOutputMask(float InPackedChannel)
{
	return ((uint)round(InPackedChannel * (float)0xFF)) & ~ 0xF ;
}

bool IsSubsurfaceModel(int ShadingModel)
{
	return ShadingModel ==  2
		|| ShadingModel ==  3
		|| ShadingModel ==  5
		|| ShadingModel ==  6
		|| ShadingModel ==  7
		|| ShadingModel ==  9 ;
}

bool UseSubsurfaceProfile(int ShadingModel)
{
	return ShadingModel ==  5  || ShadingModel ==  9 ;
}

bool HasCustomGBufferData(int ShadingModelID)
{
	return ShadingModelID ==  2
		|| ShadingModelID ==  3
		|| ShadingModelID ==  4
		|| ShadingModelID ==  5
		|| ShadingModelID ==  6
		|| ShadingModelID ==  7
		|| ShadingModelID ==  8
		|| ShadingModelID ==  9 ;
}

bool HasAnisotropy(int SelectiveOutputMask)
{
	return (SelectiveOutputMask &  (1 << 4) ) != 0;
}


struct FGBufferData
{

	float3  WorldNormal;

	float3  WorldTangent;

	float3  DiffuseColor;

	float3  SpecularColor;

	float3  BaseColor;

	float  Metallic;

	float  Specular;

	float4  CustomData;

	float  GenericAO;

	float  IndirectIrradiance;


	float4  PrecomputedShadowFactors;

	float  Roughness;

	float  Anisotropy;

	float  GBufferAO;

	uint DiffuseIndirectSampleOcclusion;

	uint ShadingModelID;

	uint SelectiveOutputMask;

	float  PerObjectGBufferData;

	float  CustomDepth;

	uint CustomStencil;


	float  Depth;

	float4  Velocity;


	float3  StoredBaseColor;

	float  StoredSpecular;

	float  StoredMetallic;


	float  Curvature;
};

bool CastContactShadow(FGBufferData GBufferData)
{
	uint PackedAlpha = (uint)(GBufferData.PerObjectGBufferData * 3.999f);
	bool bCastContactShadowBit = PackedAlpha & 1;

	bool bShadingModelCastContactShadows = (GBufferData.ShadingModelID !=  9 );
	return bCastContactShadowBit && bShadingModelCastContactShadows;
}

bool HasDynamicIndirectShadowCasterRepresentation(FGBufferData GBufferData)
{
	uint PackedAlpha = (uint)(GBufferData.PerObjectGBufferData * 3.999f);
	return (PackedAlpha & 2) != 0;
}




bool CheckerFromPixelPos(uint2 PixelPos)
{


	uint TemporalAASampleIndex = uint(View.TemporalAAParams.x);


	return (PixelPos.x + PixelPos.y + TemporalAASampleIndex) % 2;
#line 418 "/Engine/Private/DeferredShadingCommon.ush"
}




bool CheckerFromSceneColorUV(float2 UVSceneColor)
{

	uint2 PixelPos = uint2(UVSceneColor * View.BufferSizeAndInvSize.xy);

	return CheckerFromPixelPos(PixelPos);
}
#line 432 "/Engine/Private/DeferredShadingCommon.ush"
#line 1 "GBufferHelpers.ush"
#line 7 "/Engine/Private/GBufferHelpers.ush"
#line 1 "SceneTextureParameters.ush"
#line 8 "/Engine/Private/GBufferHelpers.ush"


float SquareInline(float X)
{
	return X * X;
}

float3 EncodeNormalHelper(float3 SrcNormal, float QuantizationBias)
{
	return SrcNormal * .5f + .5f;
}

float3 DecodeNormalHelper(float3 SrcNormal)
{
	return SrcNormal * 2.0f - 1.0f;
}


uint EncodeQuantize6(float Value, float QuantizationBias)
{
	return min(uint(saturate(Value) * 63.0f + .5f + QuantizationBias),63u);
}

float DecodeQuantize6(uint Value)
{
	return float(Value) / 63.0f;
}

uint EncodeQuantize6Sqrt(float Value, float QuantizationBias)
{
	return min(uint(sqrt(saturate(Value)) * 63.0f + .5f + QuantizationBias),63u);
}

float DecodeQuantize6Sqrt(uint Value)
{
	return SquareInline(float(Value) / 63.0f);
}

uint EncodeQuantize5(float Value, float QuantizationBias)
{
	return min(uint(saturate(Value) * 31.0f + .5f + QuantizationBias),31u);
}

float DecodeQuantize5(uint Value)
{
	return float(Value) / 31.0f;
}

uint EncodeQuantize5Sqrt(float Value, float QuantizationBias)
{
	return min(uint(sqrt(saturate(Value)) * 31.0f + .5f + QuantizationBias),31u);
}

float DecodeQuantize5Sqrt(uint Value)
{
	return SquareInline(float(Value) / 31.0f);
}

uint EncodeQuantize4(float Value, float QuantizationBias)
{
	return min(uint(saturate(Value) * 15.0f + .5f + QuantizationBias),15u);
}

float DecodeQuantize4(uint Value)
{
	return float(Value) / 15.0f;
}

uint EncodeQuantize4Sqrt(float Value, float QuantizationBias)
{
	return min(uint(sqrt(saturate(Value)) * 15.0f + .5f + QuantizationBias),15u);
}

float DecodeQuantize4Sqrt(uint Value)
{
	return SquareInline(float(Value) / 15.0f);
}


uint EncodeQuantize3(float Value, float QuantizationBias)
{
	return min(uint(saturate(Value) * 7.0f + .5f + QuantizationBias),7u);
}

float DecodeQuantize3(uint Value)
{
	return float(Value) / 7.0f;
}

uint EncodeQuantize3Sqrt(float Value, float QuantizationBias)
{
	return min(uint(sqrt(saturate(Value)) * 7.0f + .5f + QuantizationBias),7u);
}

float DecodeQuantize3Sqrt(uint Value)
{
	return SquareInline(float(Value) / 7.0f);
}

uint EncodeQuantize2(float Value, float QuantizationBias)
{
	return min(uint(saturate(Value) * 3.0f + .5f + QuantizationBias),3u);
}

float DecodeQuantize2(uint Value)
{
	return float(Value) / 3.0f;
}

uint EncodeQuantize2Sqrt(float Value, float QuantizationBias)
{
	return min(uint(sqrt(saturate(Value)) * 3.0f + .5f + QuantizationBias),3u);
}

float DecodeQuantize2Sqrt(uint Value)
{
	return SquareInline(float(Value) / 3.0f);
}

uint EncodeQuantize1(float Value, float QuantizationBias)
{
	return min(uint(saturate(Value) * 1.0f + .5f + QuantizationBias),1u);
}

float DecodeQuantize1(uint Value)
{
	return float(Value) / 1.0f;
}

uint EncodeQuantize1Sqrt(float Value, float QuantizationBias)
{
	return min(uint(sqrt(saturate(Value)) * 1.0f + .5f + QuantizationBias),1u);
}

float DecodeQuantize1Sqrt(uint Value)
{
	return SquareInline(float(Value) / 1.0f);
}


uint3 EncodeQuantize565(float3 Value, float QuantizationBias)
{
	uint3 Ret;
	Ret.x = EncodeQuantize5(Value.x,QuantizationBias);
	Ret.y = EncodeQuantize6(Value.y,QuantizationBias);
	Ret.z = EncodeQuantize5(Value.z,QuantizationBias);
	return Ret;
}

float3 DecodeQuantize565(uint3 Value)
{
	float3 Ret;
	Ret.x = DecodeQuantize5(Value.x);
	Ret.y = DecodeQuantize6(Value.y);
	Ret.z = DecodeQuantize5(Value.z);
	return Ret;
}

uint3 EncodeQuantize565Sqrt(float3 Value, float QuantizationBias)
{
	uint3 Ret;
	Ret.x = EncodeQuantize5Sqrt(Value.x,QuantizationBias);
	Ret.y = EncodeQuantize6Sqrt(Value.y,QuantizationBias);
	Ret.z = EncodeQuantize5Sqrt(Value.z,QuantizationBias);
	return Ret;
}

float3 DecodeQuantize565Sqrt(uint3 Value)
{
	float3 Ret;
	Ret.x = DecodeQuantize5Sqrt(Value.x);
	Ret.y = DecodeQuantize6Sqrt(Value.y);
	Ret.z = DecodeQuantize5Sqrt(Value.z);
	return Ret;
}


uint3 EncodeQuantize444(float3 Value, float QuantizationBias)
{
	uint3 Ret;
	Ret.x = EncodeQuantize4(Value.x,QuantizationBias);
	Ret.y = EncodeQuantize4(Value.y,QuantizationBias);
	Ret.z = EncodeQuantize4(Value.z,QuantizationBias);
	return Ret;
}

float3 DecodeQuantize444(uint3 Value)
{
	float3 Ret;
	Ret.x = DecodeQuantize4(Value.x);
	Ret.y = DecodeQuantize4(Value.y);
	Ret.z = DecodeQuantize4(Value.z);
	return Ret;
}

uint3 EncodeQuantize444Sqrt(float3 Value, float QuantizationBias)
{
	uint3 Ret;
	Ret.x = EncodeQuantize4Sqrt(Value.x,QuantizationBias);
	Ret.y = EncodeQuantize4Sqrt(Value.y,QuantizationBias);
	Ret.z = EncodeQuantize4Sqrt(Value.z,QuantizationBias);
	return Ret;
}

float3 DecodeQuantize444Sqrt(uint3 Value)
{
	float3 Ret;
	Ret.x = DecodeQuantize4Sqrt(Value.x);
	Ret.y = DecodeQuantize4Sqrt(Value.y);
	Ret.z = DecodeQuantize4Sqrt(Value.z);
	return Ret;
}


uint3 EncodeQuantize332(float3 Value, float QuantizationBias)
{
	uint3 Ret;
	Ret.x = EncodeQuantize3(Value.x,QuantizationBias);
	Ret.y = EncodeQuantize3(Value.y,QuantizationBias);
	Ret.z = EncodeQuantize2(Value.z,QuantizationBias);
	return Ret;
}

float3 DecodeQuantize332(uint3 Value)
{
	float3 Ret;
	Ret.x = DecodeQuantize3(Value.x);
	Ret.y = DecodeQuantize3(Value.y);
	Ret.z = DecodeQuantize2(Value.z);
	return Ret;
}

uint3 EncodeQuantize332Sqrt(float3 Value, float QuantizationBias)
{
	uint3 Ret;
	Ret.x = EncodeQuantize3Sqrt(Value.x,QuantizationBias);
	Ret.y = EncodeQuantize3Sqrt(Value.y,QuantizationBias);
	Ret.z = EncodeQuantize2Sqrt(Value.z,QuantizationBias);
	return Ret;
}

float3 DecodeQuantize332Sqrt(uint3 Value)
{
	float3 Ret;
	Ret.x = DecodeQuantize3Sqrt(Value.x);
	Ret.y = DecodeQuantize3Sqrt(Value.y);
	Ret.z = DecodeQuantize2Sqrt(Value.z);
	return Ret;
}


void EnvBRDFApproxFullyRoughHelper(inout float3 DiffuseColor, inout float3 SpecularColor)
{

	DiffuseColor += SpecularColor * 0.45;
	SpecularColor = 0;

}

void EnvBRDFApproxFullyRoughHelper(inout float3 DiffuseColor, inout float SpecularColor)
{
	DiffuseColor += SpecularColor * 0.45;
	SpecularColor = 0;
}








void GBufferPreEncode(inout FGBufferData GBuffer, bool bChecker, float GeometricAARoughness, inout  float3  OriginalBaseColor, inout  float  OriginalSpecular, inout  float  OriginalMetallic, float QuantizationBias)
{
#line 314 "/Engine/Private/GBufferHelpers.ush"
	GBuffer.DiffuseColor = OriginalBaseColor - OriginalBaseColor * OriginalMetallic;


	{

		GBuffer.DiffuseColor = GBuffer.DiffuseColor * View.DiffuseOverrideParameter.w + View.DiffuseOverrideParameter.xyz;
		GBuffer.SpecularColor = GBuffer.SpecularColor * View.SpecularOverrideParameter.w + View.SpecularOverrideParameter.xyz;
	}



	if (View.RenderingReflectionCaptureMask)

	{
		EnvBRDFApproxFullyRoughHelper(GBuffer.DiffuseColor, GBuffer.SpecularColor);

	}







		GBuffer.GenericAO = EncodeIndirectIrradiance(GBuffer.IndirectIrradiance * GBuffer.GBufferAO) + QuantizationBias * (1.0 / 255.0);
#line 345 "/Engine/Private/GBufferHelpers.ush"
}



void AdjustBaseColorAndSpecularColorForSubsurfaceProfileLightingCopyHack(inout float3 BaseColor, inout float3 SpecularColor, inout float Specular, bool bChecker)
{





	const bool bCheckerboardRequired = View.bSubsurfacePostprocessEnabled > 0 && View.bCheckerboardSubsurfaceProfileRendering > 0;
	BaseColor = View.bSubsurfacePostprocessEnabled ? float3(1, 1, 1) : BaseColor;

	if (bCheckerboardRequired)
	{



		BaseColor = bChecker;

		SpecularColor *= !bChecker;
		Specular *= !bChecker;
	}
}





void GBufferPostDecode(inout FGBufferData Ret, bool bChecker, bool bGetNormalizedNormal)
{
	Ret.CustomData = HasCustomGBufferData(Ret.ShadingModelID) ? Ret.CustomData : 0.0f;

	Ret.PrecomputedShadowFactors = !(Ret.SelectiveOutputMask & 0x2) ? Ret.PrecomputedShadowFactors : ((Ret.SelectiveOutputMask & 0x4) ? 0.0f : 1.0f);
	Ret.Velocity = !(Ret.SelectiveOutputMask & 0x8) ? Ret.Velocity : 0.0f;
	bool bHasAnisotropy = (Ret.SelectiveOutputMask & 0x1);

	Ret.StoredBaseColor = Ret.BaseColor;
	Ret.StoredMetallic = Ret.Metallic;
	Ret.StoredSpecular = Ret.Specular;






	Ret.GBufferAO = 1;
	Ret.DiffuseIndirectSampleOcclusion = 0x0;
	Ret.IndirectIrradiance = DecodeIndirectIrradiance(Ret.GenericAO.x);
#line 401 "/Engine/Private/GBufferHelpers.ush"
	if(bGetNormalizedNormal)
	{
		Ret.WorldNormal = normalize(Ret.WorldNormal);
	}

	[flatten]
	if( Ret.ShadingModelID ==  9  )
	{
		Ret.Metallic = 0.0;
#line 413 "/Engine/Private/GBufferHelpers.ush"
	}


	{
		Ret.SpecularColor = ComputeF0(Ret.Specular, Ret.BaseColor, Ret.Metallic);

		if (UseSubsurfaceProfile(Ret.ShadingModelID))
		{
			AdjustBaseColorAndSpecularColorForSubsurfaceProfileLightingCopyHack(Ret.BaseColor, Ret.SpecularColor, Ret.Specular, bChecker);
		}

		Ret.DiffuseColor = Ret.BaseColor - Ret.BaseColor * Ret.Metallic;


		{

			Ret.DiffuseColor = Ret.DiffuseColor * View.DiffuseOverrideParameter.www + View.DiffuseOverrideParameter.xyz;
			Ret.SpecularColor = Ret.SpecularColor * View.SpecularOverrideParameter.w + View.SpecularOverrideParameter.xyz;
		}

	}

	if (bHasAnisotropy)
	{
		Ret.WorldTangent = DecodeNormal(Ret.WorldTangent);
		Ret.Anisotropy = Ret.Anisotropy * 2.0f - 1.0f;

		if(bGetNormalizedNormal)
		{
			Ret.WorldTangent = normalize(Ret.WorldTangent);
		}
	}
	else
	{
		Ret.WorldTangent = 0;
		Ret.Anisotropy = 0;
	}



	Ret.SelectiveOutputMask = Ret.SelectiveOutputMask << 4;
}
#line 433 "/Engine/Private/DeferredShadingCommon.ush"
#line 434 "/Engine/Private/DeferredShadingCommon.ush"
#line 1 "/Engine/Generated/ShaderAutogen/AutogenShaderHeaders.ush"
#line 6 "/ShaderAutogen/PCD3D_SM6/AutogenShaderHeaders.ush"
float SampleDeviceZFromSceneTexturesTempCopy(float2 UV)
{
	return SceneDepthTexture.SampleLevel( D3DStaticPointClampedSampler , UV, 0).r;
}








void EncodeGBufferToMRT(inout FPixelShaderOut Out, FGBufferData GBuffer, float QuantizationBias)
{
	float4 MrtFloat1 = 0.0f;
	float4 MrtFloat2 = 0.0f;
	uint4 MrtUint2 = 0;
	float4 MrtFloat3 = 0.0f;
	float4 MrtFloat4 = 0.0f;
	float4 MrtFloat5 = 0.0f;
	float4 MrtFloat6 = 0.0f;

	float3 WorldNormal_Compressed = EncodeNormalHelper(GBuffer.WorldNormal, 0.0f);

	MrtFloat1.x = WorldNormal_Compressed.x;
	MrtFloat1.y = WorldNormal_Compressed.y;
	MrtFloat1.z = WorldNormal_Compressed.z;
	MrtFloat1.w = GBuffer.PerObjectGBufferData.x;
	MrtFloat2.x = GBuffer.Metallic.x;
	MrtFloat2.y = GBuffer.Specular.x;
	MrtFloat2.z = GBuffer.Roughness.x;
	MrtUint2.w |= ((((GBuffer.ShadingModelID.x) >> 0) & 0x0f) << 0);
	MrtUint2.w |= ((((GBuffer.SelectiveOutputMask.x) >> 0) & 0x0f) << 4);
	MrtFloat3.x = GBuffer.BaseColor.x;
	MrtFloat3.y = GBuffer.BaseColor.y;
	MrtFloat3.z = GBuffer.BaseColor.z;
	MrtFloat3.w = GBuffer.GenericAO.x;
	MrtFloat4.x = GBuffer.Velocity.x;
	MrtFloat4.y = GBuffer.Velocity.y;
	MrtFloat4.z = GBuffer.Velocity.z;
	MrtFloat4.w = GBuffer.Velocity.w;
	MrtFloat6.x = GBuffer.PrecomputedShadowFactors.x;
	MrtFloat6.y = GBuffer.PrecomputedShadowFactors.y;
	MrtFloat6.z = GBuffer.PrecomputedShadowFactors.z;
	MrtFloat6.w = GBuffer.PrecomputedShadowFactors.w;
	MrtFloat5.x = GBuffer.CustomData.x;
	MrtFloat5.y = GBuffer.CustomData.y;
	MrtFloat5.z = GBuffer.CustomData.z;
	MrtFloat5.w = GBuffer.CustomData.w;

	Out.MRT[1] = MrtFloat1;
	Out.MRT[2] = float4(MrtFloat2.x, MrtFloat2.y, MrtFloat2.z, (float(MrtUint2.w) + .5f) / 255.0f);
	Out.MRT[3] = MrtFloat3;
	Out.MRT[4] = MrtFloat4;
	Out.MRT[5] = MrtFloat5;
	Out.MRT[6] = MrtFloat6;
	Out.MRT[7] = float4(0.0f, 0.0f, 0.0f, 0.0f);
}


FGBufferData DecodeGBufferDataDirect(float4 InMRT1,
	float4 InMRT2,
	float4 InMRT3,
	float4 InMRT4,
	float4 InMRT5,
	float4 InMRT6,

	float CustomNativeDepth,
	float4 AnisotropicData,
	uint CustomStencil,
	float SceneDepth,
	bool bGetNormalizedNormal,
	bool bChecker)
{
	FGBufferData Ret = (FGBufferData)0;
	float3 WorldNormal_Compressed = 0.0f;
	WorldNormal_Compressed.x = InMRT1.x;
	WorldNormal_Compressed.y = InMRT1.y;
	WorldNormal_Compressed.z = InMRT1.z;
	Ret.PerObjectGBufferData.x = InMRT1.w;
	Ret.Metallic.x = InMRT2.x;
	Ret.Specular.x = InMRT2.y;
	Ret.Roughness.x = InMRT2.z;
	Ret.ShadingModelID.x = (((uint((float(InMRT2.w) * 255.0f) + .5f) >> 0) & 0x0f) << 0);
	Ret.SelectiveOutputMask.x = (((uint((float(InMRT2.w) * 255.0f) + .5f) >> 4) & 0x0f) << 0);
	Ret.BaseColor.x = InMRT3.x;
	Ret.BaseColor.y = InMRT3.y;
	Ret.BaseColor.z = InMRT3.z;
	Ret.GenericAO.x = InMRT3.w;
	Ret.Velocity.x = InMRT4.x;
	Ret.Velocity.y = InMRT4.y;
	Ret.Velocity.z = InMRT4.z;
	Ret.Velocity.w = InMRT4.w;
	Ret.PrecomputedShadowFactors.x = InMRT6.x;
	Ret.PrecomputedShadowFactors.y = InMRT6.y;
	Ret.PrecomputedShadowFactors.z = InMRT6.z;
	Ret.PrecomputedShadowFactors.w = InMRT6.w;
	Ret.CustomData.x = InMRT5.x;
	Ret.CustomData.y = InMRT5.y;
	Ret.CustomData.z = InMRT5.z;
	Ret.CustomData.w = InMRT5.w;

	Ret.WorldNormal = DecodeNormalHelper(WorldNormal_Compressed);
	Ret.WorldTangent = AnisotropicData.xyz;
	Ret.Anisotropy = AnisotropicData.w;

	GBufferPostDecode(Ret,bChecker,bGetNormalizedNormal);

	Ret.CustomDepth = ConvertFromDeviceZ(CustomNativeDepth);
	Ret.CustomStencil = CustomStencil;
	Ret.Depth = SceneDepth;


	return Ret;
}





FGBufferData DecodeGBufferDataUV(float2 UV, bool bGetNormalizedNormal = true)
{
	float CustomNativeDepth = Texture2DSampleLevel(SceneTexturesStruct.CustomDepthTexture,  SceneTexturesStruct.PointClampSampler , UV, 0).r;
	int2 IntUV = (int2)trunc(UV * View.BufferSizeAndInvSize.xy * View.BufferToSceneTextureScale.xy);
	uint CustomStencil = SceneTexturesStruct.CustomStencilTexture.Load(int3(IntUV, 0))  .g ;
	float SceneDepth = CalcSceneDepth(UV);
	float4 AnisotropicData = Texture2DSampleLevel(SceneTexturesStruct.GBufferFTexture,  SceneTexturesStruct.PointClampSampler , UV, 0).xyzw;

	float4 InMRT1 = Texture2DSampleLevel(SceneTexturesStruct.GBufferATexture,  SceneTexturesStruct.PointClampSampler , UV, 0).xyzw;
	float4 InMRT2 = Texture2DSampleLevel(SceneTexturesStruct.GBufferBTexture,  SceneTexturesStruct.PointClampSampler , UV, 0).xyzw;
	float4 InMRT3 = Texture2DSampleLevel(SceneTexturesStruct.GBufferCTexture,  SceneTexturesStruct.PointClampSampler , UV, 0).xyzw;
	float4 InMRT4 = Texture2DSampleLevel(SceneTexturesStruct.GBufferVelocityTexture,  SceneTexturesStruct.PointClampSampler , UV, 0).xyzw;
	float4 InMRT5 = Texture2DSampleLevel(SceneTexturesStruct.GBufferDTexture,  SceneTexturesStruct.PointClampSampler , UV, 0).xyzw;
	float4 InMRT6 = Texture2DSampleLevel(SceneTexturesStruct.GBufferETexture,  SceneTexturesStruct.PointClampSampler , UV, 0).xyzw;

	FGBufferData Ret = DecodeGBufferDataDirect(InMRT1,
		InMRT2,
		InMRT3,
		InMRT4,
		InMRT5,
		InMRT6,

		CustomNativeDepth,
		AnisotropicData,
		CustomStencil,
		SceneDepth,
		bGetNormalizedNormal,
		CheckerFromSceneColorUV(UV));

	return Ret;
}



FGBufferData DecodeGBufferDataUint(uint2 PixelPos, bool bGetNormalizedNormal = true)
{
	float CustomNativeDepth = SceneTexturesStruct.CustomDepthTexture.Load(int3(PixelPos, 0)).r;
	uint CustomStencil = SceneTexturesStruct.CustomStencilTexture.Load(int3(PixelPos, 0))  .g ;
	float SceneDepth = CalcSceneDepth(PixelPos);
	float4 AnisotropicData = SceneTexturesStruct.GBufferFTexture.Load(int3(PixelPos, 0)).xyzw;

	float4 InMRT1 = SceneTexturesStruct.GBufferATexture.Load(int3(PixelPos, 0)).xyzw;
	float4 InMRT2 = SceneTexturesStruct.GBufferBTexture.Load(int3(PixelPos, 0)).xyzw;
	float4 InMRT3 = SceneTexturesStruct.GBufferCTexture.Load(int3(PixelPos, 0)).xyzw;
	float4 InMRT4 = SceneTexturesStruct.GBufferVelocityTexture.Load(int3(PixelPos, 0)).xyzw;
	float4 InMRT5 = SceneTexturesStruct.GBufferDTexture.Load(int3(PixelPos, 0)).xyzw;
	float4 InMRT6 = SceneTexturesStruct.GBufferETexture.Load(int3(PixelPos, 0)).xyzw;

	FGBufferData Ret = DecodeGBufferDataDirect(InMRT1,
		InMRT2,
		InMRT3,
		InMRT4,
		InMRT5,
		InMRT6,

		CustomNativeDepth,
		AnisotropicData,
		CustomStencil,
		SceneDepth,
		bGetNormalizedNormal,
		CheckerFromPixelPos(PixelPos));

	return Ret;
}



FGBufferData DecodeGBufferDataSceneTextures(float2 UV, bool bGetNormalizedNormal = true)
{
	uint CustomStencil = 0;
	float CustomNativeDepth = 0;
	float DeviceZ = SampleDeviceZFromSceneTexturesTempCopy(UV);
	float SceneDepth = ConvertFromDeviceZ(DeviceZ);
	float4 AnisotropicData = GBufferFTexture.SampleLevel( D3DStaticPointClampedSampler , UV, 0).xyzw;

	float4 InMRT1 = GBufferATexture.SampleLevel( D3DStaticPointClampedSampler , UV, 0).xyzw;
	float4 InMRT2 = GBufferBTexture.SampleLevel( D3DStaticPointClampedSampler , UV, 0).xyzw;
	float4 InMRT3 = GBufferCTexture.SampleLevel( D3DStaticPointClampedSampler , UV, 0).xyzw;
	float4 InMRT4 = GBufferVelocityTexture.SampleLevel( D3DStaticPointClampedSampler , UV, 0).xyzw;
	float4 InMRT5 = GBufferDTexture.SampleLevel( D3DStaticPointClampedSampler , UV, 0).xyzw;
	float4 InMRT6 = GBufferETexture.SampleLevel( D3DStaticPointClampedSampler , UV, 0).xyzw;

	FGBufferData Ret = DecodeGBufferDataDirect(InMRT1,
		InMRT2,
		InMRT3,
		InMRT4,
		InMRT5,
		InMRT6,

		CustomNativeDepth,
		AnisotropicData,
		CustomStencil,
		SceneDepth,
		bGetNormalizedNormal,
		CheckerFromSceneColorUV(UV));

	return Ret;
}



FGBufferData DecodeGBufferDataSceneTexturesLoad(uint2 PixelCoord, bool bGetNormalizedNormal = true)
{
	uint CustomStencil = 0;
	float CustomNativeDepth = 0;
	float DeviceZ = SceneDepthTexture.Load(int3(PixelCoord, 0)).r;
	float SceneDepth = ConvertFromDeviceZ(DeviceZ);
	float4 AnisotropicData = GBufferFTexture.Load(int3(PixelCoord, 0)).xyzw;

	float4 InMRT1 = GBufferATexture.Load(int3(PixelCoord, 0)).xyzw;
	float4 InMRT2 = GBufferBTexture.Load(int3(PixelCoord, 0)).xyzw;
	float4 InMRT3 = GBufferCTexture.Load(int3(PixelCoord, 0)).xyzw;
	float4 InMRT4 = GBufferVelocityTexture.Load(int3(PixelCoord, 0)).xyzw;
	float4 InMRT5 = GBufferDTexture.Load(int3(PixelCoord, 0)).xyzw;
	float4 InMRT6 = GBufferETexture.Load(int3(PixelCoord, 0)).xyzw;

	FGBufferData Ret = DecodeGBufferDataDirect(InMRT1,
		InMRT2,
		InMRT3,
		InMRT4,
		InMRT5,
		InMRT6,

		CustomNativeDepth,
		AnisotropicData,
		CustomStencil,
		SceneDepth,
		bGetNormalizedNormal,
		CheckerFromPixelPos(PixelCoord));

	return Ret;
}
#line 435 "/Engine/Private/DeferredShadingCommon.ush"


struct FScreenSpaceData
{

	FGBufferData GBuffer;

	float AmbientOcclusion;
};


void SetGBufferForUnlit(out float4 OutGBufferB)
{
	OutGBufferB = 0;
	OutGBufferB.a = EncodeShadingModelIdAndSelectiveOutputMask( 0 , 0);
}



float4 ComputeIndirectLightingSampleE(uint2 TracingPixelCoord, uint TracingRayIndex, uint TracingRayCount)
{

	uint2 Seed0 = Rand3DPCG16(int3(TracingPixelCoord, View.StateFrameIndexMod8)).xy;
	uint2 Seed1 = Rand3DPCG16(int3(TracingPixelCoord + 17, View.StateFrameIndexMod8)).xy;

	return float4(
		Hammersley16(TracingRayIndex, TracingRayCount, Seed0),
		Hammersley16(TracingRayIndex, TracingRayCount, Seed1));
}
#line 752 "/Engine/Private/DeferredShadingCommon.ush"
void EncodeGBuffer(
	FGBufferData GBuffer,
	out float4 OutGBufferA,
	out float4 OutGBufferB,
	out float4 OutGBufferC,
	out float4 OutGBufferD,
	out float4 OutGBufferE,
	out float4 OutGBufferVelocity,
	float QuantizationBias = 0
	)
{





	if (GBuffer.ShadingModelID ==  0 )
	{
		OutGBufferA = 0;
		SetGBufferForUnlit(OutGBufferB);
		OutGBufferC = 0;
		OutGBufferD = 0;
		OutGBufferE = 0;
	}
	else
	{

		OutGBufferA.rgb = EncodeNormal( GBuffer.WorldNormal );
		OutGBufferA.a = GBuffer.PerObjectGBufferData;
#line 791 "/Engine/Private/DeferredShadingCommon.ush"
		OutGBufferB.r = GBuffer.Metallic;
		OutGBufferB.g = GBuffer.Specular;
		OutGBufferB.b = GBuffer.Roughness;
		OutGBufferB.a = EncodeShadingModelIdAndSelectiveOutputMask(GBuffer.ShadingModelID, GBuffer.SelectiveOutputMask);

		OutGBufferC.rgb = EncodeBaseColor( GBuffer.BaseColor );





		OutGBufferC.a = EncodeIndirectIrradiance(GBuffer.IndirectIrradiance * GBuffer.GBufferAO) + QuantizationBias * (1.0 / 255.0);
#line 807 "/Engine/Private/DeferredShadingCommon.ush"
		OutGBufferD = GBuffer.CustomData;
		OutGBufferE = GBuffer.PrecomputedShadowFactors;
	}




	OutGBufferVelocity = 0;


}




bool AdjustBaseColorAndSpecularColorForSubsurfaceProfileLighting(inout float3 BaseColor, inout float Specular, bool bChecker)
{





	const bool bCheckerboardRequired = View.bSubsurfacePostprocessEnabled > 0 && View.bCheckerboardSubsurfaceProfileRendering > 0;
	BaseColor = View.bSubsurfacePostprocessEnabled ? float3(1, 1, 1) : BaseColor;

	if (bCheckerboardRequired)
	{


		BaseColor = bChecker;
		Specular *= !bChecker;
	}
	return bCheckerboardRequired;
}
void AdjustBaseColorAndSpecularColorForSubsurfaceProfileLighting(inout float3 BaseColor, inout float3 SpecularColor, inout float Specular, bool bChecker)
{
	const bool bCheckerboardRequired = AdjustBaseColorAndSpecularColorForSubsurfaceProfileLighting(BaseColor, Specular, bChecker);
	if (bCheckerboardRequired)
	{

		SpecularColor *= !bChecker;
	}
}



FGBufferData DecodeGBufferData(
	float4 InGBufferA,
	float4 InGBufferB,
	float4 InGBufferC,
	float4 InGBufferD,
	float4 InGBufferE,
	float4 InGBufferF,
	float4 InGBufferVelocity,
	float CustomNativeDepth,
	uint CustomStencil,
	float SceneDepth,
	bool bGetNormalizedNormal,
	bool bChecker)
{
	FGBufferData GBuffer;

	GBuffer.WorldNormal = DecodeNormal( InGBufferA.xyz );
	if(bGetNormalizedNormal)
	{
		GBuffer.WorldNormal = normalize(GBuffer.WorldNormal);
	}

	GBuffer.PerObjectGBufferData = InGBufferA.a;
	GBuffer.Metallic = InGBufferB.r;
	GBuffer.Specular = InGBufferB.g;
	GBuffer.Roughness = InGBufferB.b;



	GBuffer.ShadingModelID = DecodeShadingModelId(InGBufferB.a);
	GBuffer.SelectiveOutputMask = DecodeSelectiveOutputMask(InGBufferB.a);

	GBuffer.BaseColor = DecodeBaseColor(InGBufferC.rgb);






	GBuffer.GBufferAO = 1;
	GBuffer.DiffuseIndirectSampleOcclusion = 0x0;
	GBuffer.IndirectIrradiance = DecodeIndirectIrradiance(InGBufferC.a);
#line 901 "/Engine/Private/DeferredShadingCommon.ush"
	GBuffer.CustomData = HasCustomGBufferData(GBuffer.ShadingModelID) ? InGBufferD : 0;

	GBuffer.PrecomputedShadowFactors = !(GBuffer.SelectiveOutputMask &  (1 << 5) ) ? InGBufferE : ((GBuffer.SelectiveOutputMask &  (1 << 6) ) ? 0 : 1);
	GBuffer.CustomDepth = ConvertFromDeviceZ(CustomNativeDepth);
	GBuffer.CustomStencil = CustomStencil;
	GBuffer.Depth = SceneDepth;

	GBuffer.StoredBaseColor = GBuffer.BaseColor;
	GBuffer.StoredMetallic = GBuffer.Metallic;
	GBuffer.StoredSpecular = GBuffer.Specular;

	[flatten]
	if( GBuffer.ShadingModelID ==  9  )
	{
		GBuffer.Metallic = 0.0;
#line 919 "/Engine/Private/DeferredShadingCommon.ush"
	}


	{
		GBuffer.SpecularColor = ComputeF0(GBuffer.Specular, GBuffer.BaseColor, GBuffer.Metallic);

		if (UseSubsurfaceProfile(GBuffer.ShadingModelID))
		{
			AdjustBaseColorAndSpecularColorForSubsurfaceProfileLighting(GBuffer.BaseColor, GBuffer.SpecularColor, GBuffer.Specular, bChecker);
		}

		GBuffer.DiffuseColor = GBuffer.BaseColor - GBuffer.BaseColor * GBuffer.Metallic;


		{

			GBuffer.DiffuseColor = GBuffer.DiffuseColor * View.DiffuseOverrideParameter.www + View.DiffuseOverrideParameter.xyz;
			GBuffer.SpecularColor = GBuffer.SpecularColor * View.SpecularOverrideParameter.w + View.SpecularOverrideParameter.xyz;
		}

	}

	{
		bool bHasAnisoProp = HasAnisotropy(GBuffer.SelectiveOutputMask);

		GBuffer.WorldTangent = bHasAnisoProp ? DecodeNormal(InGBufferF.rgb) : 0;
		GBuffer.Anisotropy = bHasAnisoProp ? InGBufferF.a * 2.0f - 1.0f : 0;

		if (bGetNormalizedNormal && bHasAnisoProp)
		{
			GBuffer.WorldTangent = normalize(GBuffer.WorldTangent);
		}
	}

	GBuffer.Velocity = !(GBuffer.SelectiveOutputMask &  (1 << 7) ) ? InGBufferVelocity : 0;

	return GBuffer;
}

float3 ExtractSubsurfaceColor(FGBufferData BufferData)
{
	return Square(BufferData.CustomData.rgb);
}

uint ExtractSubsurfaceProfileInt(float ProfileNormFloat)
{
	return uint(ProfileNormFloat * 255.0f + 0.5f);
}

uint ExtractSubsurfaceProfileInt(FGBufferData BufferData)
{
	return ExtractSubsurfaceProfileInt(BufferData.CustomData.r);
}





	FGBufferData GetGBufferDataUint(uint2 PixelPos, bool bGetNormalizedNormal = true)
	{

		return DecodeGBufferDataUint(PixelPos,bGetNormalizedNormal);
#line 1007 "/Engine/Private/DeferredShadingCommon.ush"
	}


	FScreenSpaceData GetScreenSpaceDataUint(uint2 PixelPos, bool bGetNormalizedNormal = true)
	{
		FScreenSpaceData Out;

		Out.GBuffer = GetGBufferDataUint(PixelPos, bGetNormalizedNormal);

		float4 ScreenSpaceAO = Texture2DSampleLevel(SceneTexturesStruct.ScreenSpaceAOTexture,  SceneTexturesStruct.PointClampSampler , (PixelPos + 0.5f) * View.BufferSizeAndInvSize.zw, 0);
		Out.AmbientOcclusion = ScreenSpaceAO.r;

		return Out;
	}




FGBufferData GetGBufferDataFromSceneTextures(float2 UV, bool bGetNormalizedNormal = true)
{

	return DecodeGBufferDataSceneTextures(UV,bGetNormalizedNormal);
#line 1047 "/Engine/Private/DeferredShadingCommon.ush"
}


uint GetSceneLightingChannel(uint2 PixelCoord)
{
	[branch]
	if (bSceneLightingChannelsValid)
	{
		return SceneLightingChannels.Load(uint3(PixelCoord, 0)).x;
	}
	return ~0;
}


FGBufferData GetGBufferData(float2 UV, bool bGetNormalizedNormal = true)
{

	return DecodeGBufferDataUV(UV,bGetNormalizedNormal);
#line 1095 "/Engine/Private/DeferredShadingCommon.ush"
}


uint GetShadingModelId(float2 UV)
{
	return DecodeShadingModelId(Texture2DSampleLevel(SceneTexturesStruct.GBufferBTexture,  SceneTexturesStruct.PointClampSampler , UV, 0).a);
}


FScreenSpaceData GetScreenSpaceData(float2 UV, bool bGetNormalizedNormal = true)
{
	FScreenSpaceData Out;

	Out.GBuffer = GetGBufferData(UV, bGetNormalizedNormal);
	float4 ScreenSpaceAO = Texture2DSampleLevel(SceneTexturesStruct.ScreenSpaceAOTexture,  SceneTexturesStruct.PointClampSampler , UV, 0);

	Out.AmbientOcclusion = ScreenSpaceAO.r;

	return Out;
}



float3  AOMultiBounce( float3  BaseColor,  float  AO)
{
	if ( 0  && ! 0 )
	{
		return AO;
	}
	else
	{
		float3  a = 2.0404 * BaseColor - 0.3324;
		float3  b = -4.7951 * BaseColor + 0.6417;
		float3  c = 2.7552 * BaseColor + 0.6903;
		return max(AO, ((AO * a + b) * AO + c) * AO);
	}
}
#line 10 "/Engine/Private/DeferredLightingCommon.ush"
#line 1 "DynamicLightingCommon.ush"
#line 9 "/Engine/Private/DynamicLightingCommon.ush"
float3 GetDeferredLightTranslatedWorldPosition()
{
	return DeferredLightUniforms.TranslatedWorldPosition;
}
#line 18 "/Engine/Private/DynamicLightingCommon.ush"
float RadialAttenuationMask(float3 WorldLightVector)
{
	float NormalizeDistanceSquared = dot(WorldLightVector, WorldLightVector);
	return 1.0f - saturate(NormalizeDistanceSquared);
}
float RadialAttenuation(float3 WorldLightVector,  float  FalloffExponent)
{

	return pow(RadialAttenuationMask(WorldLightVector), FalloffExponent);
#line 48 "/Engine/Private/DynamicLightingCommon.ush"
}
#line 56 "/Engine/Private/DynamicLightingCommon.ush"
float SpotAttenuationMask(float3 L, float3 SpotDirection, float2 SpotAngles)
{
	return saturate((dot(L, -SpotDirection) - SpotAngles.x) * SpotAngles.y);
}
float SpotAttenuation(float3 L, float3 SpotDirection, float2 SpotAngles)
{
	float ConeAngleFalloff = Square(SpotAttenuationMask(L, SpotDirection, SpotAngles));
	return ConeAngleFalloff;
}


float CalcLightAttenuation(float3 TranslatedWorldPosition, out float3 WorldLightVector)
{
	WorldLightVector = DeferredLightUniforms.Direction;
	float DistanceAttenuation = 1;
#line 89 "/Engine/Private/DynamicLightingCommon.ush"
	float SpotFalloff = 1;
#line 94 "/Engine/Private/DynamicLightingCommon.ush"
	return SpotFalloff * DistanceAttenuation;
}

float3 GetNormalizedLightVector(float3 TranslatedWorldPosition)
{

	float3 Ret = DeferredLightUniforms.Direction;
#line 106 "/Engine/Private/DynamicLightingCommon.ush"
	return Ret;
}

float GetLightInfluenceMask(float3 TranslatedWorldPosition)
{
	float LightMask = 1;

	if (DeferredLightUniforms.InvRadius > 0)
	{
		float3 ToLight = GetDeferredLightTranslatedWorldPosition() - TranslatedWorldPosition;
		float DistanceSqr = dot(ToLight, ToLight);
		float3 L = ToLight * rsqrt(DistanceSqr);

		if (DeferredLightUniforms.FalloffExponent == 0)
		{
			LightMask = saturate(1 - Square(DistanceSqr * Square(DeferredLightUniforms.InvRadius)));

		}
		else
		{
			LightMask = RadialAttenuationMask(ToLight * DeferredLightUniforms.InvRadius);
		}

		if (DeferredLightUniforms.SpotAngles.x > -2.0f)
		{
			LightMask *= SpotAttenuationMask(L, -DeferredLightUniforms.Direction, DeferredLightUniforms.SpotAngles);
		}
	}

	return LightMask > 0.0f ? 1.0f : 0.0f;
}
#line 11 "/Engine/Private/DeferredLightingCommon.ush"
#line 1 "IESLightProfilesCommon.ush"
#line 8 "/Engine/Private/IESLightProfilesCommon.ush"
Texture2D IESTexture;
SamplerState IESTextureSampler;


float ComputeLightProfileMultiplier(float3 WorldPosition, float3 LightPosition, float3 LightDirection, float3 LightTangent)
{
#line 35 "/Engine/Private/IESLightProfilesCommon.ush"
	return 1.0f;

}
#line 12 "/Engine/Private/DeferredLightingCommon.ush"
#line 1 "CapsuleLightIntegrate.ush"
#line 7 "/Engine/Private/CapsuleLightIntegrate.ush"
#line 1 "AreaLightCommon.ush"
#line 5 "/Engine/Private/AreaLightCommon.ush"
#line 1 "RectLight.ush"
#line 6 "/Engine/Private/RectLight.ush"
#line 1 "CapsuleLight.ush"
#line 5 "/Engine/Private/CapsuleLight.ush"
float SmoothMin( float a, float b, float k )
{
	float h = saturate( 0.5 + (0.5 / k) * (b - a) );
	return lerp( b, a, h ) - k * (h - h*h);
}

float SmoothMax( float a, float b, float k )
{
	return SmoothMin( a, b, -k );
}

float SmoothClamp( float x, float Min, float Max, float k )
{
	return SmoothMin( SmoothMax( x, Min, k ), Max, k );

}

struct FCapsuleLight
{
	float3 LightPos[2];
	float Length;
	float Radius;
	float SoftRadius;
	float DistBiasSqr;
};

void ClipToHorizon( inout float3 Line0, inout float3 Line1, float3 N )
{
	float NoP0 = dot( N, Line0 );
	float NoP1 = dot( N, Line1 );
	if( NoP0 < 0 ) Line0 = ( Line0 * NoP1 - Line1 * NoP0 ) / ( NoP1 - NoP0 );
	if( NoP1 < 0 ) Line1 = ( -Line0 * NoP1 + Line1 * NoP0 ) / ( -NoP1 + NoP0 );
}


float3 ClosestPointLineToPoint( float3 Line0, float3 Line1, float Length )
{
	float3 Line01 = Line1 - Line0;
	return Line0 + Line01 * saturate( -dot( Line01, Line0 ) / Pow2( Length ) );

}


float3 ClosestPointLineToRay( float3 Line0, float3 Line1, float Length, float3 R )
{
	float3 L0 = Line0;
	float3 L1 = Line1;
	float3 Line01 = Line1 - Line0;


	float A = Square( Length );
	float B = dot( R, Line01 );
	float t = saturate( dot( Line0, B*R - Line01 ) / (A - B*B) );

	return Line0 + t * Line01;
}

float3 SmallestAnglePointOnLineToRay( float3 Line0, float3 Line1, float Length, float3 R )
{
	float3 L0 = Line0;
	float3 L1 = Line1;
	float3 Line01 = Line1 - Line0;

	float A = Square( Length );
	float B = 2 * dot( Line0, Line01 );
	float C = dot( Line0, Line0 );
	float D = dot( R, Line0 );
	float E = dot( R, Line01 );
	float t = saturate( (B*D - 2*C*E) / (B*E - 2*A*D) );

	return Line0 + t * Line01;
}

float3 LineIrradiance( float3 N, float3 Line0, float3 Line1, float DistanceBiasSqr, out float CosSubtended, out float BaseIrradiance, out float NoL )
{
	float LengthSqr0 = dot( Line0, Line0 );
	float LengthSqr1 = dot( Line1, Line1 );
	float InvLength0 = rsqrt( LengthSqr0 );
	float InvLength1 = rsqrt( LengthSqr1 );
	float InvLength01 = InvLength0 * InvLength1;

	CosSubtended = dot( Line0, Line1 ) * InvLength01;
	BaseIrradiance = InvLength01 / ( CosSubtended * 0.5 + 0.5 + DistanceBiasSqr * InvLength01 );
	NoL = 0.5 * ( dot(N, Line0) * InvLength0 + dot(N, Line1) * InvLength1 );

	float3 VectorIrradiance = ( BaseIrradiance * 0.5 ) * ( Line0 * InvLength0 + Line1 * InvLength1 );
	return VectorIrradiance;
}


float SphereHorizonCosWrap( float NoL, float SinAlphaSqr )
{

	float SinAlpha = sqrt( SinAlphaSqr );

	if( NoL < SinAlpha )
	{
		NoL = max( NoL, -SinAlpha );
#line 120 "/Engine/Private/CapsuleLight.ush"
		NoL = Pow2( SinAlpha + NoL ) / ( 4 * SinAlpha );

	}
#line 127 "/Engine/Private/CapsuleLight.ush"
	return NoL;
}
#line 7 "/Engine/Private/RectLight.ush"








struct FRect
{
	float3 Origin;
	float3x3 Axis;
	float2 Extent;
	float2 FullExtent;
	float2 Offset;
};

struct FRectTexture
{
	float2  AtlasUVOffset;
	float2  AtlasUVScale;
	float  AtlasMaxLevel;
};

FRectTexture InitRectTexture()
{
	FRectTexture Out;
	Out.AtlasUVOffset = 0;
	Out.AtlasUVScale = 0;
	Out.AtlasMaxLevel =  32 ;
	return Out;
}

FRectTexture InitRectTexture( float2  InUVOffset,  float2  InUVScale,  float  InMaxLevel)
{
	FRectTexture Out;
	Out.AtlasUVOffset = InUVOffset;
	Out.AtlasUVScale = InUVScale;
	Out.AtlasMaxLevel = InMaxLevel;
	return Out;
}

float3 SampleRectTexture(FRectTexture RectTexture, float2 RectUV, float Level, bool bIsReference = false)
{

	const bool bIsValid = RectTexture.AtlasMaxLevel <  32 ;
	const float2 RectTextureSize = RectTexture.AtlasUVScale * View.RectLightAtlasSizeAndInvSize.xy;
	Level += log2(min(RectTextureSize.x, RectTextureSize.y)) - 2.f;
	Level = min(Level, RectTexture.AtlasMaxLevel);

	RectUV = saturate(RectUV) * RectTexture.AtlasUVScale + RectTexture.AtlasUVOffset;
	return bIsValid ? View.RectLightAtlasTexture.SampleLevel(View.SharedTrilinearClampedSampler, RectUV, bIsReference ? 0 : Level).rgb : 1.f;
#line 62 "/Engine/Private/RectLight.ush"
}


float3 RectIrradianceLambert( float3 N, FRect Rect, out float BaseIrradiance, out float NoL )
{







	float3 LocalPosition;
	LocalPosition.x = dot( Rect.Axis[0], Rect.Origin );
	LocalPosition.y = dot( Rect.Axis[1], Rect.Origin );
	LocalPosition.z = dot( Rect.Axis[2], Rect.Origin );


	float x0 = LocalPosition.x - Rect.Extent.x;
	float x1 = LocalPosition.x + Rect.Extent.x;
	float y0 = LocalPosition.y - Rect.Extent.y;
	float y1 = LocalPosition.y + Rect.Extent.y;
	float z0 = LocalPosition.z;
	float z0Sqr = z0 * z0;


	float3 v0 = float3( x0, y0, z0 );
	float3 v1 = float3( x1, y0, z0 );
	float3 v2 = float3( x1, y1, z0 );
	float3 v3 = float3( x0, y1, z0 );

	float3 L0 = v0 * rsqrt( dot( v0.xy, v0.xy ) + z0Sqr );
	float3 L1 = v1 * rsqrt( dot( v1.xy, v1.xy ) + z0Sqr );
	float3 L2 = v2 * rsqrt( dot( v2.xy, v2.xy ) + z0Sqr );
	float3 L3 = v3 * rsqrt( dot( v3.xy, v3.xy ) + z0Sqr );
#line 109 "/Engine/Private/RectLight.ush"
	float c01 = dot( L0, L1 );
	float c12 = dot( L1, L2 );
	float c23 = dot( L2, L3 );
	float c30 = dot( L3, L0 );
#line 129 "/Engine/Private/RectLight.ush"
	float w01 = ( 1.5708 - 0.175 * c01 ) * rsqrt( c01 + 1 );
	float w12 = ( 1.5708 - 0.175 * c12 ) * rsqrt( c12 + 1 );
	float w23 = ( 1.5708 - 0.175 * c23 ) * rsqrt( c23 + 1 );
	float w30 = ( 1.5708 - 0.175 * c30 ) * rsqrt( c30 + 1 );










	float3 L;
	L = cross( L1, -w01 * L0 + w12 * L2 );
	L += cross( L3, w30 * L0 + -w23 * L2 );




	L = L.x * Rect.Axis[0] + L.y * Rect.Axis[1] + L.z * Rect.Axis[2];

	float LengthSqr = dot( L, L );
	float InvLength = rsqrt( LengthSqr );
	float Length = LengthSqr * InvLength;


	L *= InvLength;

	BaseIrradiance = 0.5 * Length;




	float SinAlphaSqr = BaseIrradiance * (1.0 / PI);

	NoL = SphereHorizonCosWrap( dot( N, L ), SinAlphaSqr );

	return L;
}

float3 RectIrradianceApproxKaris( float3 N, FRect Rect, out float BaseIrradiance, out float NoL )
{
	float2 RectLocal;
	RectLocal.x = SmoothClamp( dot( Rect.Axis[0], -Rect.Origin ), -Rect.Extent.x, Rect.Extent.x, 16 );
	RectLocal.y = SmoothClamp( dot( Rect.Axis[1], -Rect.Origin ), -Rect.Extent.y, Rect.Extent.y, 16 );

	float3 ClosestPoint = Rect.Origin;
	ClosestPoint += Rect.Axis[0] * RectLocal.x;
	ClosestPoint += Rect.Axis[1] * RectLocal.y;

	float3 OppositePoint = 2 * Rect.Origin - ClosestPoint;

	float3 L0 = normalize( ClosestPoint );
	float3 L1 = normalize( OppositePoint );
	float3 L = normalize( L0 + L1 );


	float Distance = dot( Rect.Axis[2], Rect.Origin ) / dot( Rect.Axis[2], L );
	float DistanceSqr = Distance * Distance;



	BaseIrradiance = 4 * Rect.Extent.x * Rect.Extent.y * rsqrt( ( (4 / PI) * Square( Rect.Extent.x ) + DistanceSqr ) * ( (4 / PI) * Square( Rect.Extent.y ) + DistanceSqr ) );
	BaseIrradiance *= saturate( dot( Rect.Axis[2], L ) );




	float SinAlphaSqr = BaseIrradiance * (1.0 / PI);

	NoL = SphereHorizonCosWrap( dot( N, L ), SinAlphaSqr );

	return L;
}

float3 RectIrradianceApproxLagarde( float3 N, FRect Rect, out float BaseIrradiance, out float NoL )
{
	float3 L = normalize( Rect.Origin );

	float3 v0 = Rect.Origin - Rect.Axis[0] * Rect.Extent.x - Rect.Axis[1] * Rect.Extent.y;
	float3 v1 = Rect.Origin + Rect.Axis[0] * Rect.Extent.x - Rect.Axis[1] * Rect.Extent.y;
	float3 v2 = Rect.Origin + Rect.Axis[0] * Rect.Extent.x + Rect.Axis[1] * Rect.Extent.y;
	float3 v3 = Rect.Origin - Rect.Axis[0] * Rect.Extent.x + Rect.Axis[1] * Rect.Extent.y;

	float3 n0 = normalize( cross( v0, v1 ) );
	float3 n1 = normalize( cross( v1, v2 ) );
	float3 n2 = normalize( cross( v2, v3 ) );
	float3 n3 = normalize( cross( v3, v0 ) );

	float g0 = acos( dot( n0, n1 ) );
	float g1 = acos( dot( n1, n2 ) );
	float g2 = acos( dot( n2, n3 ) );
	float g3 = acos( dot( n3, n0 ) );


	BaseIrradiance = g0 + g1 + g2 + g3 - 2*PI;

	NoL = 0.2 * ( saturate( dot( N, L ) ) +
		saturate( dot( N, normalize(v0) ) ) +
		saturate( dot( N, normalize(v1) ) ) +
		saturate( dot( N, normalize(v2) ) ) +
		saturate( dot( N, normalize(v3) ) ) );

	return L;
}

float3 RectIrradianceApproxDrobot( float3 N, FRect Rect, out float BaseIrradiance, out float NoL )
{
#line 252 "/Engine/Private/RectLight.ush"
	float clampCosAngle = 0.001 + saturate( dot( N, Rect.Axis[2] ) );

	float3 d0 = normalize( -Rect.Axis[2] + N * clampCosAngle );

	float3 d1 = normalize( N - Rect.Axis[2] * clampCosAngle );
	float3 dh = normalize( d0 + d1 );



	float3 PointOnPlane = dh * ( dot( Rect.Axis[2], Rect.Origin ) / dot( Rect.Axis[2], dh ) );

	float3 ClosestPoint = Rect.Origin;
	ClosestPoint += Rect.Axis[0] * clamp( dot( Rect.Axis[0], PointOnPlane - Rect.Origin ), -Rect.Extent.x, Rect.Extent.x );
	ClosestPoint += Rect.Axis[1] * clamp( dot( Rect.Axis[1], PointOnPlane - Rect.Origin ), -Rect.Extent.y, Rect.Extent.y );

	float3 v0 = Rect.Origin - Rect.Axis[0] * Rect.Extent.x - Rect.Axis[1] * Rect.Extent.y;
	float3 v1 = Rect.Origin + Rect.Axis[0] * Rect.Extent.x - Rect.Axis[1] * Rect.Extent.y;
	float3 v2 = Rect.Origin + Rect.Axis[0] * Rect.Extent.x + Rect.Axis[1] * Rect.Extent.y;
	float3 v3 = Rect.Origin - Rect.Axis[0] * Rect.Extent.x + Rect.Axis[1] * Rect.Extent.y;

	float3 n0 = normalize( cross( v0, v1 ) );
	float3 n1 = normalize( cross( v1, v2 ) );
	float3 n2 = normalize( cross( v2, v3 ) );
	float3 n3 = normalize( cross( v3, v0 ) );

	float g0 = acos( dot( n0, n1 ) );
	float g1 = acos( dot( n1, n2 ) );
	float g2 = acos( dot( n2, n3 ) );
	float g3 = acos( dot( n3, n0 ) );

	float SolidAngle = g0 + g1 + g2 + g3 - 2*PI;

	float3 L = normalize( ClosestPoint );
#line 297 "/Engine/Private/RectLight.ush"
	BaseIrradiance = SolidAngle;
	NoL = saturate( dot( N, L ) );

	return L;
}


float3 SampleSourceTexture( float3 L, FRect Rect, FRectTexture RectTexture)
{


	L += Rect.Axis[2] * saturate( 0.001 - dot( Rect.Axis[2], L ) );


	float DistToPlane = dot( Rect.Axis[2], Rect.Origin ) / dot( Rect.Axis[2], L );
	float3 PointOnPlane = L * DistToPlane;

	float2 PointInRect;
	PointInRect.x = dot( Rect.Axis[0], PointOnPlane - Rect.Origin );
	PointInRect.y = dot( Rect.Axis[1], PointOnPlane - Rect.Origin );


    float2 RectUV = (PointInRect + Rect.Offset) / Rect.FullExtent * float2(0.5, -0.5) + 0.5;

	float Level = log2( DistToPlane * rsqrt( Rect.FullExtent.x * Rect.FullExtent.y ) );

    return SampleRectTexture(RectTexture, RectUV, Level);
#line 327 "/Engine/Private/RectLight.ush"
}

float IntegrateEdge( float3 L0, float3 L1 )
{
	float c01 = dot( L0, L1 );
#line 344 "/Engine/Private/RectLight.ush"
	float w01 = ( 0.8543985 + (0.4965155 + 0.0145206 * abs(c01)) * abs(c01) ) /
				( 3.4175940 + (4.1616724 + abs(c01)) * abs(c01) );

	w01 = c01 > 0 ? w01 : 0.5 * rsqrt( 1 - c01 * c01 ) - w01;


	return w01;
}


float3 PolygonIrradiance( float3 Poly[4] )
{
	float3 L0 = normalize( Poly[0] );
	float3 L1 = normalize( Poly[1] );
	float3 L2 = normalize( Poly[2] );
	float3 L3 = normalize( Poly[3] );









	float w01 = IntegrateEdge( L0, L1 );
	float w12 = IntegrateEdge( L1, L2 );
	float w23 = IntegrateEdge( L2, L3 );
	float w30 = IntegrateEdge( L3, L0 );








	float3 L;
	L = cross( L1, -w01 * L0 + w12 * L2 );
	L += cross( L3, w30 * L0 + -w23 * L2 );




	return L;
}


float3 RectGGXApproxLTC( float Roughness, float3 SpecularColor,  float3  N, float3 V, FRect Rect, FRectTexture RectTexture )
{

	const float3 F0 = SpecularColor;
	const float3 F90 = saturate(50.0 * SpecularColor);


	if (Rect.Extent.x == 0 || Rect.Extent.y == 0) return 0;

	float NoV = saturate( abs( dot(N, V) ) + 1e-5 );

	float2 UV = float2( Roughness, sqrt( 1 - NoV ) );
	UV = UV * (63.0 / 64.0) + (0.5 / 64.0);

	float4 LTCMat = View.LTCMatTexture.SampleLevel( View.LTCMatSampler, UV, 0 );
	float4 LTCAmp = View.LTCAmpTexture.SampleLevel( View.LTCAmpSampler, UV, 0 );

	float3x3 LTC = {
		float3( LTCMat.x, 0, LTCMat.z ),
		float3( 0, 1, 0 ),
		float3( LTCMat.y, 0, LTCMat.w )
	};

	float LTCDet = LTCMat.x * LTCMat.w - LTCMat.y * LTCMat.z;

	float4 InvLTCMat = LTCMat / LTCDet;
	float3x3 InvLTC = {
		float3( InvLTCMat.w, 0,-InvLTCMat.z ),
		float3( 0, 1, 0 ),
		float3(-InvLTCMat.y, 0, InvLTCMat.x )
	};


	float3 T1 = normalize( V - N * dot( N, V ) );
	float3 T2 = cross( N, T1 );
	float3x3 TangentBasis = float3x3( T1, T2, N );

	LTC = mul( LTC, TangentBasis );
	InvLTC = mul( transpose( TangentBasis ), InvLTC );

	float3 Poly[4];
	Poly[0] = mul( LTC, Rect.Origin - Rect.Axis[0] * Rect.Extent.x - Rect.Axis[1] * Rect.Extent.y );
	Poly[1] = mul( LTC, Rect.Origin + Rect.Axis[0] * Rect.Extent.x - Rect.Axis[1] * Rect.Extent.y );
	Poly[2] = mul( LTC, Rect.Origin + Rect.Axis[0] * Rect.Extent.x + Rect.Axis[1] * Rect.Extent.y );
	Poly[3] = mul( LTC, Rect.Origin - Rect.Axis[0] * Rect.Extent.x + Rect.Axis[1] * Rect.Extent.y );


	float3 L = PolygonIrradiance( Poly );

	float LengthSqr = dot( L, L );
	float InvLength = rsqrt( LengthSqr );
	float Length = LengthSqr * InvLength;


	L *= InvLength;




	float SinAlphaSqr = Length;

	float NoL = SphereHorizonCosWrap( L.z, SinAlphaSqr );
	float Irradiance = SinAlphaSqr * NoL;


	Irradiance = -min(-Irradiance, 0.0);
#line 468 "/Engine/Private/RectLight.ush"
	float3 IrradianceScale = F90 * LTCAmp.y + ( LTCAmp.x - LTCAmp.y ) * F0;


	L = mul( InvLTC, L );

	float3 LightColor = SampleSourceTexture( L, Rect, RectTexture );

	return LightColor * Irradiance * IrradianceScale;
}




struct FSphericalRect
{
	float3x3 Axis;

	float x0;
	float x1;
	float y0;
	float y1;
	float z0;

	float b0;
	float b1;
	float k;
	float SolidAngle;
};


FSphericalRect BuildSphericalRect( FRect Rect )
{
	FSphericalRect SphericalRect;

	SphericalRect.Axis = Rect.Axis;

	float3 LocalPosition;
	LocalPosition.x = dot( Rect.Axis[0], Rect.Origin );
	LocalPosition.y = dot( Rect.Axis[1], Rect.Origin );
	LocalPosition.z = dot( Rect.Axis[2], Rect.Origin );

	SphericalRect.x0 = LocalPosition.x - Rect.Extent.x;
	SphericalRect.x1 = LocalPosition.x + Rect.Extent.x;
	SphericalRect.y0 = LocalPosition.y - Rect.Extent.y;
	SphericalRect.y1 = LocalPosition.y + Rect.Extent.y;
	SphericalRect.z0 = -abs( LocalPosition.z );

	SphericalRect.Axis[2] *= LocalPosition.z > 0 ? -1 : 1;

	float3 v0 = float3( SphericalRect.x0, SphericalRect.y0, SphericalRect.z0 );
	float3 v1 = float3( SphericalRect.x1, SphericalRect.y0, SphericalRect.z0 );
	float3 v2 = float3( SphericalRect.x1, SphericalRect.y1, SphericalRect.z0 );
	float3 v3 = float3( SphericalRect.x0, SphericalRect.y1, SphericalRect.z0 );

	float3 n0 = normalize( cross( v0, v1 ) );
	float3 n1 = normalize( cross( v1, v2 ) );
	float3 n2 = normalize( cross( v2, v3 ) );
	float3 n3 = normalize( cross( v3, v0 ) );

	float g0 = acos( -dot( n0, n1 ) );
	float g1 = acos( -dot( n1, n2 ) );
	float g2 = acos( -dot( n2, n3 ) );
	float g3 = acos( -dot( n3, n0 ) );

	SphericalRect.b0 = n0.z;
	SphericalRect.b1 = n2.z;

	SphericalRect.k = 2*PI - g2 - g3;
	SphericalRect.SolidAngle = g0 + g1 - SphericalRect.k;

	return SphericalRect;
}

struct FSphericalRectSample {
	float3 Direction;
	float2 UV;
};

FSphericalRectSample UniformSampleSphericalRectWithUV(float2 E, FSphericalRect Rect)
{
	float au = E.x * Rect.SolidAngle + Rect.k;
	float fu = (cos(au) * Rect.b0 - Rect.b1) / sin(au);
	float cu = rsqrt(fu * fu + Rect.b0 * Rect.b0) * (fu > 0 ? 1 : -1);
	cu = clamp(cu, -1, 1);

	float xu = -(cu * Rect.z0) * rsqrt(1 - cu * cu);
	xu = clamp(xu, Rect.x0, Rect.x1);

	float d = sqrt(xu * xu + Rect.z0 * Rect.z0);
	float h0 = Rect.y0 * rsqrt(d * d + Rect.y0 * Rect.y0);
	float h1 = Rect.y1 * rsqrt(d * d + Rect.y1 * Rect.y1);
	float hv = h0 + E.y * (h1 - h0);
	float yv = (hv * hv < 1 - 1e-6) ? (hv * d) * rsqrt(1 - hv * hv) : Rect.y1;

	FSphericalRectSample Result;
	Result.Direction = mul(float3(xu, yv, Rect.z0), Rect.Axis);
	Result.UV = float2(xu - Rect.x0, yv - Rect.y0) / float2(Rect.x1 - Rect.x0, Rect.y1 - Rect.y0);

	return Result;
}

float3 UniformSampleSphericalRect( float2 E, FSphericalRect Rect )
{
	return UniformSampleSphericalRectWithUV(E, Rect).Direction;
}

float3 RectIrradianceRef( float3 N, FRect Rect, out float BaseIrradiance, out float NoL )
{
	FSphericalRect SphericalRect = BuildSphericalRect( Rect );

	const uint NumSamples = 32;

	float3 L = 0;
	NoL = 0;

	[loop]
	for( uint i = 0; i < NumSamples; i++ )
	{
		float2 E = Hammersley( i, NumSamples, 0 );
		float3 Ls = normalize( UniformSampleSphericalRect( E, SphericalRect ) );

		L += Ls;
		NoL += saturate( dot(N, Ls) );
	}

	BaseIrradiance = SphericalRect.SolidAngle;
	NoL /= NumSamples;

	return normalize(L);
}

FRect GetRect(
	float3 ToLight,
	float3 LightDataDirection,
	float3 LightDataTangent,
	float LightDataSourceRadius,
	float LightDataSourceLength,
	float LightDataRectLightBarnCosAngle,
	float LightDataRectLightBarnLength,
	bool bComputeVisibleRect)
{

	FRect Rect;
	Rect.Origin = ToLight;
	Rect.Axis[1] = LightDataTangent;
	Rect.Axis[2] = LightDataDirection;
	Rect.Axis[0] = cross( Rect.Axis[1], Rect.Axis[2] );
	Rect.Extent = float2(LightDataSourceRadius, LightDataSourceLength);
	Rect.FullExtent = Rect.Extent;
	Rect.Offset = 0;
#line 639 "/Engine/Private/RectLight.ush"
	if (bComputeVisibleRect && LightDataRectLightBarnCosAngle > 0.035f)
	{
		const float3 LightdPdv = -Rect.Axis[1];
		const float3 LightdPdu = -Rect.Axis[0];
		const float2 LightExtent = float2(LightDataSourceRadius, LightDataSourceLength);
		const float BarnLength = LightDataRectLightBarnLength;


		float3 S_Light = mul(Rect.Axis, ToLight);




		const float CosTheta = LightDataRectLightBarnCosAngle;
		const float SinTheta = sqrt(1 - CosTheta * CosTheta);
		const float BarnDepth = min(S_Light.z, CosTheta * BarnLength);
		const float S_ratio = BarnDepth / (CosTheta * BarnLength);
		const float D_B = SinTheta * BarnLength * S_ratio;


		const float2 SignS = sign(S_Light.xy);
		S_Light.xy = SignS * max(abs(S_Light.xy), LightExtent + D_B.xx);


		const float3 C = float3(SignS * (LightExtent + D_B.xx), BarnDepth);



		const float3 SProj = S_Light - C;
		const float CosEta = max(SProj.z, 0.001f);
		const float2 SinEta = abs(SProj.xy);
		const float2 TanEta = abs(SProj.xy) / CosEta;
		const float2 D_S = BarnDepth * TanEta;




		const float2 MinXY = clamp(-LightExtent + (D_S - D_B.xx) * max(0, -SignS), -LightExtent, LightExtent);
		const float2 MaxXY = clamp( LightExtent - (D_S - D_B.xx) * max(0, SignS), -LightExtent, LightExtent);
		const float2 RectOffset = 0.5f * (MinXY + MaxXY);

		Rect.Extent = 0.5f * (MaxXY - MinXY);
		Rect.Origin = Rect.Origin + LightdPdu * RectOffset.x + LightdPdv * RectOffset.y;
		Rect.Offset = -RectOffset;
		Rect.FullExtent = LightExtent;
	}

	return Rect;
}

bool IsRectVisible(FRect Rect)
{

	return Rect.Extent.x != 0 && Rect.Extent.y != 0;
}
#line 6 "/Engine/Private/AreaLightCommon.ush"

struct FAreaLight
{
	float SphereSinAlpha;
	float SphereSinAlphaSoft;
	float LineCosSubtended;

	float3 FalloffColor;

	FRect Rect;
	FRectTexture Texture;

	uint IsRectAndDiffuseMicroReflWeight;
};

struct FAreaLightIntegrateContext
{
	FAreaLight AreaLight;
	float3 L;
	float NoL;
	float Falloff;
};

void SetIsRectLight(inout FAreaLight AreaLight, bool bIsRectLight)
{
	AreaLight.IsRectAndDiffuseMicroReflWeight = (AreaLight.IsRectAndDiffuseMicroReflWeight & 0xFFFFFFFE) | (bIsRectLight ? 0x1 : 0x0);
}

bool IsRectLight(FAreaLight AreaLight)
{
	return (AreaLight.IsRectAndDiffuseMicroReflWeight & 0x00000001) == 0x1;
}

void SetAreaLightDiffuseMicroReflWeight(inout FAreaLight AreaLight, float Weight)
{

	AreaLight.IsRectAndDiffuseMicroReflWeight = (AreaLight.IsRectAndDiffuseMicroReflWeight & 0x00000001) | (asuint(Weight) << 1);
}

float GetAreaLightDiffuseMicroReflWeight(FAreaLight AreaLight)
{
	return asfloat(AreaLight.IsRectAndDiffuseMicroReflWeight >> 1);
}

bool IsAreaLight(FAreaLight AreaLight)
{
	return IsRectLight(AreaLight) || GetAreaLightDiffuseMicroReflWeight(AreaLight) < 1.0f;
}

FAreaLightIntegrateContext InitAreaLightIntegrateContext()
{

	FAreaLightIntegrateContext Out;
	Out.AreaLight.SphereSinAlpha = 0;
	Out.AreaLight.SphereSinAlphaSoft = 0;
	Out.AreaLight.LineCosSubtended = 0;
	Out.AreaLight.FalloffColor = 0;
	Out.AreaLight.Rect = (FRect)0;
	Out.AreaLight.IsRectAndDiffuseMicroReflWeight = 0;
	Out.AreaLight.Texture = InitRectTexture();
	Out.L = 0;
	Out.NoL = 0;
	Out.Falloff = 0;
	return Out;
}
#line 8 "/Engine/Private/CapsuleLightIntegrate.ush"
#line 1 "ShadingModels.ush"
#line 6 "/Engine/Private/ShadingModels.ush"
#line 1 "BRDF.ush"
#line 9 "/Engine/Private/BRDF.ush"
struct BxDFContext
{
	float  NoV;
	float  NoL;
	float  VoL;
	float  NoH;
	float  VoH;
	float  XoV;
	float  XoL;
	float  XoH;
	float  YoV;
	float  YoL;
	float  YoH;

};

void Init( inout BxDFContext Context,  float3  N,  float3  V,  float3  L )
{
	Context.NoL = dot(N, L);
	Context.NoV = dot(N, V);
	Context.VoL = dot(V, L);
	float InvLenH = rsqrt( 2 + 2 * Context.VoL );
	Context.NoH = saturate( ( Context.NoL + Context.NoV ) * InvLenH );
	Context.VoH = saturate( InvLenH + InvLenH * Context.VoL );



	Context.XoV = 0.0f;
	Context.XoL = 0.0f;
	Context.XoH = 0.0f;
	Context.YoV = 0.0f;
	Context.YoL = 0.0f;
	Context.YoH = 0.0f;
}

void Init( inout BxDFContext Context,  float3  N,  float3  X,  float3  Y,  float3  V,  float3  L )
{
	Context.NoL = dot(N, L);
	Context.NoV = dot(N, V);
	Context.VoL = dot(V, L);
	float InvLenH = rsqrt( 2 + 2 * Context.VoL );
	Context.NoH = saturate( ( Context.NoL + Context.NoV ) * InvLenH );
	Context.VoH = saturate( InvLenH + InvLenH * Context.VoL );



	Context.XoV = dot(X, V);
	Context.XoL = dot(X, L);
	Context.XoH = (Context.XoL + Context.XoV) * InvLenH;
	Context.YoV = dot(Y, V);
	Context.YoL = dot(Y, L);
	Context.YoH = (Context.YoL + Context.YoV) * InvLenH;
}

void InitMobile(inout BxDFContext Context,  float3  N,  float3  V,  float3  L,  float  NoL)
{
	Context.NoL = NoL;
	Context.NoV = dot(N, V);
	Context.VoL = dot(V, L);
	float3 H = normalize(float3(V + L));
	Context.NoH = max(0, dot(N, H));
	Context.VoH = max(0, dot(V, H));




	Context.XoV = 0.0f;
	Context.XoL = 0.0f;
	Context.XoH = 0.0f;
	Context.YoV = 0.0f;
	Context.YoL = 0.0f;
	Context.YoH = 0.0f;
}


void SphereMaxNoH( inout BxDFContext Context, float SinAlpha, bool bNewtonIteration )
{
	if( SinAlpha > 0 )
	{
		float CosAlpha = sqrt( 1 - Pow2( SinAlpha ) );

		float RoL = 2 * Context.NoL * Context.NoV - Context.VoL;
		if( RoL >= CosAlpha )
		{
			Context.NoH = 1;
			Context.XoH = 0;
			Context.YoH = 0;
			Context.VoH = abs( Context.NoV );
		}
		else
		{
			float rInvLengthT = SinAlpha * rsqrt( 1 - RoL*RoL );
			float NoTr = rInvLengthT * ( Context.NoV - RoL * Context.NoL );
#line 107 "/Engine/Private/BRDF.ush"
			float VoTr = rInvLengthT * ( 2 * Context.NoV*Context.NoV - 1 - RoL * Context.VoL );

			if (bNewtonIteration)
			{

				float NxLoV = sqrt( saturate( 1 - Pow2(Context.NoL) - Pow2(Context.NoV) - Pow2(Context.VoL) + 2 * Context.NoL * Context.NoV * Context.VoL ) );

				float NoBr = rInvLengthT * NxLoV;
				float VoBr = rInvLengthT * NxLoV * 2 * Context.NoV;

				float NoLVTr = Context.NoL * CosAlpha + Context.NoV + NoTr;
				float VoLVTr = Context.VoL * CosAlpha + 1 + VoTr;

				float p = NoBr * VoLVTr;
				float q = NoLVTr * VoLVTr;
				float s = VoBr * NoLVTr;

				float xNum = q * ( -0.5 * p + 0.25 * VoBr * NoLVTr );
				float xDenom = p*p + s * (s - 2*p) + NoLVTr * ( (Context.NoL * CosAlpha + Context.NoV) * Pow2(VoLVTr) + q * (-0.5 * (VoLVTr + Context.VoL * CosAlpha) - 0.5) );
				float TwoX1 = 2 * xNum / ( Pow2(xDenom) + Pow2(xNum) );
				float SinTheta = TwoX1 * xDenom;
				float CosTheta = 1.0 - TwoX1 * xNum;
				NoTr = CosTheta * NoTr + SinTheta * NoBr;
				VoTr = CosTheta * VoTr + SinTheta * VoBr;
			}

			Context.NoL = Context.NoL * CosAlpha + NoTr;
#line 139 "/Engine/Private/BRDF.ush"
			Context.VoL = Context.VoL * CosAlpha + VoTr;

			float InvLenH = rsqrt( 2 + 2 * Context.VoL );
			Context.NoH = saturate( ( Context.NoL + Context.NoV ) * InvLenH );
#line 148 "/Engine/Private/BRDF.ush"
			Context.VoH = saturate( InvLenH + InvLenH * Context.VoL );
		}
	}
}
#line 278 "/Engine/Private/BRDF.ush"
float3  Diffuse_Lambert(  float3  DiffuseColor )
{
	return DiffuseColor * (1 / PI);
}


float3 Diffuse_Burley( float3 DiffuseColor, float Roughness, float NoV, float NoL, float VoH )
{
	float FD90 = 0.5 + 2 * VoH * VoH * Roughness;
	float FdV = 1 + (FD90 - 1) * Pow5( 1 - NoV );
	float FdL = 1 + (FD90 - 1) * Pow5( 1 - NoL );
	return DiffuseColor * ( (1 / PI) * FdV * FdL );
}


float3 Diffuse_OrenNayar( float3 DiffuseColor, float Roughness, float NoV, float NoL, float VoH )
{
	float a = Roughness * Roughness;
	float s = a;
	float s2 = s * s;
	float VoL = 2 * VoH * VoH - 1;
	float Cosri = VoL - NoV * NoL;
	float C1 = 1 - 0.5 * s2 / (s2 + 0.33);
	float C2 = 0.45 * s2 / (s2 + 0.09) * Cosri * ( Cosri >= 0 ? rcp( max( NoL, NoV ) ) : 1 );
	return DiffuseColor / PI * ( C1 + C2 ) * ( 1 + Roughness * 0.5 );
}


float3 Diffuse_Gotanda( float3 DiffuseColor, float Roughness, float NoV, float NoL, float VoH )
{
	float a = Roughness * Roughness;
	float a2 = a * a;
	float F0 = 0.04;
	float VoL = 2 * VoH * VoH - 1;
	float Cosri = VoL - NoV * NoL;

	float a2_13 = a2 + 1.36053;
	float Fr = ( 1 - ( 0.542026*a2 + 0.303573*a ) / a2_13 ) * ( 1 - pow( 1 - NoV, 5 - 4*a2 ) / a2_13 ) * ( ( -0.733996*a2*a + 1.50912*a2 - 1.16402*a ) * pow( 1 - NoV, 1 + rcp(39*a2*a2+1) ) + 1 );

	float Lm = ( max( 1 - 2*a, 0 ) * ( 1 - Pow5( 1 - NoL ) ) + min( 2*a, 1 ) ) * ( 1 - 0.5*a * (NoL - 1) ) * NoL;
	float Vd = ( a2 / ( (a2 + 0.09) * (1.31072 + 0.995584 * NoV) ) ) * ( 1 - pow( 1 - NoL, ( 1 - 0.3726732 * NoV * NoV ) / ( 0.188566 + 0.38841 * NoV ) ) );
	float Bp = Cosri < 0 ? 1.4 * NoV * NoL * Cosri : Cosri;
	float Lr = (21.0 / 20.0) * (1 - F0) * ( Fr * Lm + Vd + Bp );
	return DiffuseColor / PI * Lr;
#line 331 "/Engine/Private/BRDF.ush"
}



float3 Diffuse_Chan( float3 DiffuseColor, float a2, float NoV, float NoL, float VoH, float NoH, float RetroReflectivityWeight)
{

	NoV = saturate(NoV);
	NoL = saturate(NoL);
	VoH = saturate(VoH);
	NoH = saturate(NoH);


	float g = saturate( (1.0 / 18.0) * log2( 2 * rcpFast(a2) - 1 ) );

	float F0 = VoH + Pow5( 1 - VoH );
	float FdV = 1 - 0.75 * Pow5( 1 - NoV );
	float FdL = 1 - 0.75 * Pow5( 1 - NoL );


	float Fd = lerp( F0, FdV * FdL, saturate( 2.2 * g - 0.5 ) );


	float Fb = ( (34.5 * g - 59 ) * g + 24.5 ) * VoH * exp2( -max( 73.2 * g - 21.2, 8.9 ) * sqrtFast( NoH ) );

	Fb *= RetroReflectivityWeight;

	return DiffuseColor * ( (1 / PI) * ( Fd + Fb ) );
}


float D_Blinn( float a2, float NoH )
{
	float n = 2 / a2 - 2;
	return (n+2) / (2*PI) * PhongShadingPow( NoH, n );
}


float D_Beckmann( float a2, float NoH )
{
	float NoH2 = NoH * NoH;
	return exp( (NoH2 - 1) / (a2 * NoH2) ) / ( PI * a2 * NoH2 * NoH2 );
}



float D_GGX( float a2, float NoH )
{
	float d = ( NoH * a2 - NoH ) * NoH + 1;
	return a2 / ( PI*d*d );
}



float D_GGXaniso( float ax, float ay, float NoH, float XoH, float YoH )
{


	float a2 = ax * ay;
	float3 V = float3(ay * XoH, ax * YoH, a2 * NoH);
	float S = dot(V, V);

	return (1.0f / PI) * a2 * Square(a2 / S);
#line 398 "/Engine/Private/BRDF.ush"
}

float Vis_Implicit()
{
	return 0.25;
}


float Vis_Neumann( float NoV, float NoL )
{
	return 1 / ( 4 * max( NoL, NoV ) );
}


float Vis_Kelemen( float VoH )
{

	return rcp( 4 * VoH * VoH + 1e-5);
}



float Vis_Schlick( float a2, float NoV, float NoL )
{
	float k = sqrt(a2) * 0.5;
	float Vis_SchlickV = NoV * (1 - k) + k;
	float Vis_SchlickL = NoL * (1 - k) + k;
	return 0.25 / ( Vis_SchlickV * Vis_SchlickL );
}



float Vis_Smith( float a2, float NoV, float NoL )
{
	float Vis_SmithV = NoV + sqrt( NoV * (NoV - NoV * a2) + a2 );
	float Vis_SmithL = NoL + sqrt( NoL * (NoL - NoL * a2) + a2 );
	return rcp( Vis_SmithV * Vis_SmithL );
}



float Vis_SmithJointApprox( float a2, float NoV, float NoL )
{
	float a = sqrt(a2);
	float Vis_SmithV = NoL * ( NoV * ( 1 - a ) + a );
	float Vis_SmithL = NoV * ( NoL * ( 1 - a ) + a );
	return 0.5 * rcp( Vis_SmithV + Vis_SmithL );
}


float Vis_SmithJoint(float a2, float NoV, float NoL)
{
	float Vis_SmithV = NoL * sqrt(NoV * (NoV - NoV * a2) + a2);
	float Vis_SmithL = NoV * sqrt(NoL * (NoL - NoL * a2) + a2);
	return 0.5 * rcp(Vis_SmithV + Vis_SmithL);
}


float Vis_SmithJointAniso(float ax, float ay, float NoV, float NoL, float XoV, float XoL, float YoV, float YoL)
{
	float Vis_SmithV = NoL * length(float3(ax * XoV, ay * YoV, NoV));
	float Vis_SmithL = NoV * length(float3(ax * XoL, ay * YoL, NoL));
	return 0.5 * rcp(Vis_SmithV + Vis_SmithL);
}

float3 F_None( float3 SpecularColor )
{
	return SpecularColor;
}


float3 F_Schlick( float3 SpecularColor, float VoH )
{
	float Fc = Pow5( 1 - VoH );



	return saturate( 50.0 * SpecularColor.g ) * Fc + (1 - Fc) * SpecularColor;
}

float3 F_Schlick(float3 F0, float3 F90, float VoH)
{
	float Fc = Pow5(1 - VoH);
	return F90 * Fc + (1 - Fc) * F0;
}

float3 F_Fresnel( float3 SpecularColor, float VoH )
{
	float3 SpecularColorSqrt = sqrt( clamp( float3(0, 0, 0), float3(0.99, 0.99, 0.99), SpecularColor ) );
	float3 n = ( 1 + SpecularColorSqrt ) / ( 1 - SpecularColorSqrt );
	float3 g = sqrt( n*n + VoH*VoH - 1 );
	return 0.5 * Square( (g - VoH) / (g + VoH) ) * ( 1 + Square( ((g+VoH)*VoH - 1) / ((g-VoH)*VoH + 1) ) );
}






void ModifyGGXAnisotropicNormalRoughness(float3 WorldTangent, float Anisotropy, inout float Roughness, inout float3 N, float3 V)
{
	if (abs(Anisotropy) > 0.0f)
	{
		float3 X = WorldTangent;
		float3 Y = normalize(cross(N, X));

		float3 AnisotropicDir = Anisotropy >= 0.0f ? Y : X;
		float3 AnisotropicT = cross(AnisotropicDir, V);
		float3 AnisotropicN = cross(AnisotropicT, AnisotropicDir);

		float AnisotropicStretch = abs(Anisotropy) * saturate(5.0f * Roughness);
		N = normalize(lerp(N, AnisotropicN, AnisotropicStretch));
#line 513 "/Engine/Private/BRDF.ush"
	}
}


void GetAnisotropicRoughness(float Alpha, float Anisotropy, out float ax, out float ay)
{



	ax = max(Alpha * (1.0 + Anisotropy), 0.001f);
	ay = max(Alpha * (1.0 - Anisotropy), 0.001f);
#line 529 "/Engine/Private/BRDF.ush"
}


float2 GetAnisotropicRoughness(float Roughness, float Anisotropy)
{


	float2 Out = saturate(Roughness);
	Anisotropy = clamp(Anisotropy, -1.0, 1.0);
	Out.x = max(Roughness * sqrt(1.0 + Anisotropy), 0.001f);
	Out.y = max(Roughness * sqrt(1.0 - Anisotropy), 0.001f);
	return Out;
}


void GetAnisotropicFactor(float RoughnessX, float RoughnessY, inout float Anisotropy, inout float OriginalRoughness)
{
	const float MinRoughness = 0.001f;
	float r = Pow2(max(RoughnessX, MinRoughness) / max(RoughnessY, MinRoughness));
	Anisotropy = (r - 1.0) / (r + 1.0);
	OriginalRoughness = (RoughnessX + RoughnessY) / (sqrt(1.0 + Anisotropy) + sqrt(1.0 - Anisotropy));
}


Texture2D PreIntegratedGF;
SamplerState PreIntegratedGFSampler;



float3  EnvBRDF(  float3  SpecularColor,  float  Roughness,  float  NoV )
{

	float2 AB = Texture2DSampleLevel( PreIntegratedGF, PreIntegratedGFSampler, float2( NoV, Roughness ), 0 ).rg;


	float3 GF = SpecularColor * AB.x + saturate( 50.0 * SpecularColor.g ) * AB.y;
	return GF;
}

float3  EnvBRDF( float3  F0,  float3  F90,  float  Roughness,  float  NoV)
{

	float2 AB = Texture2DSampleLevel(PreIntegratedGF, PreIntegratedGFSampler, float2(NoV, Roughness), 0).rg;
	float3 GF = F0 * AB.x + F90 * AB.y;
	return GF;
}

float2  EnvBRDFApproxLazarov( float  Roughness,  float  NoV)
{


	const  float4  c0 = { -1, -0.0275, -0.572, 0.022 };
	const  float4  c1 = { 1, 0.0425, 1.04, -0.04 };
	float4  r = Roughness * c0 + c1;
	float  a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
	float2  AB =  float2 (-1.04, 1.04) * a004 + r.zw;
	return AB;
}

float3  EnvBRDFApprox(  float3  SpecularColor,  float  Roughness,  float  NoV )
{
	float2  AB = EnvBRDFApproxLazarov(Roughness, NoV);



	float F90 = saturate( 50.0 * SpecularColor.g );

	return SpecularColor * AB.x + F90 * AB.y;
}

float3  EnvBRDFApprox( float3  F0,  float3  F90,  float  Roughness,  float  NoV)
{
	float2  AB = EnvBRDFApproxLazarov(Roughness, NoV);
	return F0 * AB.x + F90 * AB.y;
}

float  EnvBRDFApproxNonmetal(  float  Roughness,  float  NoV )
{

	const  float2  c0 = { -1, -0.0275 };
	const  float2  c1 = { 1, 0.0425 };
	float2  r = Roughness * c0 + c1;
	return min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
}

void EnvBRDFApproxFullyRough(inout  float3  DiffuseColor, inout  float3  SpecularColor)
{

	DiffuseColor += SpecularColor * 0.45;
	SpecularColor = 0;

}
void EnvBRDFApproxFullyRough(inout  float3  DiffuseColor, inout  float  SpecularColor)
{
	DiffuseColor += SpecularColor * 0.45;
	SpecularColor = 0;
}
void EnvBRDFApproxFullyRough(inout  float3  DiffuseColor, inout  float3  F0, inout  float3  F90)
{
	DiffuseColor += F0 * 0.45;
	F0 = F90 = 0;
}


float D_InvBlinn( float a2, float NoH )
{
	float A = 4;
	float Cos2h = NoH * NoH;
	float Sin2h = 1 - Cos2h;

	return rcp( PI * (1 + A*a2) ) * ( 1 + A * exp( -Cos2h / a2 ) );
}

float D_InvBeckmann( float a2, float NoH )
{
	float A = 4;
	float Cos2h = NoH * NoH;
	float Sin2h = 1 - Cos2h;
	float Sin4h = Sin2h * Sin2h;
	return rcp( PI * (1 + A*a2) * Sin4h ) * ( Sin4h + A * exp( -Cos2h / (a2 * Sin2h) ) );
}

float D_InvGGX( float a2, float NoH )
{
	float A = 4;
	float d = ( NoH - a2 * NoH ) * NoH + a2;
	return rcp( PI * (1 + A*a2) ) * ( 1 + 4 * a2*a2 / ( d*d ) );
}

float Vis_Cloth( float NoV, float NoL )
{
	return rcp( 4 * ( NoL + NoV - NoL * NoV ) );
}

float D_Charlie(float Roughness, float NoH)
{
	float InvR = 1 / Roughness;
	float Cos2H = NoH * NoH;
	float Sin2H = 1 - Cos2H;
	return (2 + InvR) * pow(Sin2H, InvR * 0.5) / (2 * PI);
}


float Vis_Charlie_L(float x, float r)
{
	r = saturate(r);
	r = 1.0 - (1. - r) * (1. - r);

	float a = lerp(25.3245 , 21.5473 , r);
	float b = lerp( 3.32435, 3.82987, r);
	float c = lerp( 0.16801, 0.19823, r);
	float d = lerp(-1.27393, -1.97760, r);
	float e = lerp(-4.85967, -4.32054, r);

	return a * rcp( (1 + b * pow(x, c)) + d * x + e);
}
float Vis_Charlie(float Roughness, float NoV, float NoL)
{
	float VisV = NoV < 0.5 ? exp(Vis_Charlie_L(NoV, Roughness)) : exp(2 * Vis_Charlie_L(0.5, Roughness) - Vis_Charlie_L(1 - NoV, Roughness));
	float VisL = NoL < 0.5 ? exp(Vis_Charlie_L(NoL, Roughness)) : exp(2 * Vis_Charlie_L(0.5, Roughness) - Vis_Charlie_L(1 - NoL, Roughness));

	return rcp(((1 + VisV + VisL) * (4 * NoV * NoL)));
}

float Vis_Ashikhmin(float NoV, float NoL)
{
	return rcp(4 * (NoL + NoV - NoL * NoV));
}


float3 SimpleClearCoatTransmittance(float NoL, float NoV, float Metallic, float3 BaseColor)
{
	float3 Transmittance = 1.0;

	float ClearCoatCoverage = Metallic;
	if (ClearCoatCoverage > 0.0)
	{
		float LayerThickness = 1.0;



		float ThinDistance = LayerThickness * (rcp(NoV) + rcp(NoL));


		float3 TransmittanceColor = Diffuse_Lambert(BaseColor);


		float3 ExtinctionCoefficient = -log(TransmittanceColor) / (2.0 * LayerThickness);



		float3 OpticalDepth = ExtinctionCoefficient * max(ThinDistance - 2.0 * LayerThickness, 0.0);


		Transmittance = exp(-OpticalDepth);

		Transmittance = lerp(1.0, Transmittance, ClearCoatCoverage);
	}






	return Transmittance;
}
#line 7 "/Engine/Private/ShadingModels.ush"
#line 11 "/Engine/Private/ShadingModels.ush"
#line 1 "TransmissionCommon.ush"
#line 9 "/Engine/Private/TransmissionCommon.ush"
#line 1 "SubsurfaceProfileCommon.ush"
#line 59 "/Engine/Private/SubsurfaceProfileCommon.ush"
float4  GetSubsurfaceProfileTexture(uint SampleIndex, uint SubsurfaceProfileInt)
{




	return View.SSProfilesTexture.Load(int3(SampleIndex, SubsurfaceProfileInt, 0));

}

float4  GetSubsurfaceProfileTexture(Texture2D InSSProfilesTexture, SamplerState InSSProfilesSampler, float4 InSSProfilesTextureSizeAndInvSize, uint SampleIndex, uint SubsurfaceProfileInt)
{




	return InSSProfilesTexture.Load(int3(SampleIndex, SubsurfaceProfileInt, 0));

}

void GetSubsurfaceProfileDualSpecular(uint SubsurfaceProfileInt,  float  Roughness,  float  Opacity, out  float  LobeRoughness0, out  float  LobeRoughness1, out  float  LobeMix)
{
	const  float4  Data = GetSubsurfaceProfileTexture( ( ( ( ( ( 0 +1) +1) +1) +1) +1) , SubsurfaceProfileInt);



	float  MaterialRoughnessToLobeRoughness0 = lerp(1.0f, Data.x *  2.0f , saturate((Opacity -  0.10 ) * 10.0f));
	float  MaterialRoughnessToLobeRoughness1 = lerp(1.0f, Data.y *  2.0f , saturate((Opacity -  0.10 ) * 10.0f));
	LobeMix = Data.z;


	LobeRoughness0 = max(saturate(Roughness * MaterialRoughnessToLobeRoughness0), 0.02f);
	LobeRoughness1 = saturate(Roughness * MaterialRoughnessToLobeRoughness1);
}


float4 GetSubsurfaceProfileSurfaceAlbedo(uint SubsurfaceProfileInt)
{
	return GetSubsurfaceProfileTexture( ( 0 +1) , SubsurfaceProfileInt);
}

float4 GetSubsurfaceProfileDiffuseMeanFreePath(uint SubsurfaceProfileInt)
{
	return GetSubsurfaceProfileTexture( ( ( 0 +1) +1) , SubsurfaceProfileInt);
}

float GetSubsurfaceProfileWorldUnitScale(uint SubsurfaceProfileInt)
{
	return GetSubsurfaceProfileTexture( 0 , SubsurfaceProfileInt).a;
}

float DecodeWorldUnitScale(float EncodedWorldUnitScale)
{
	return EncodedWorldUnitScale *  1/ 0.02f ;
}

float4 DecodeDiffuseMeanFreePath(float4 EncodedDiffuseMeanFreePath)
{
	return EncodedDiffuseMeanFreePath *  1/ (0.01f*0.2f) ;
}

bool GetSubsurfaceTransmittanceProfileUseBurley(uint SubsurfaceProfileInt)
{
	float  Type = GetSubsurfaceProfileTexture( ( ( ( ( 0 +1) +1) +1) +1) , SubsurfaceProfileInt).a;
	return abs(Type -  0 ) < 0.01f;
}

bool GetSubsurfaceProfileUseBurley(uint SubsurfaceProfileInt)
{
	float  Type = GetSubsurfaceProfileTexture( ( ( ( ( 0 +1) +1) +1) +1) , SubsurfaceProfileInt).a;
	return abs(Type -  0 ) < 0.01f;
}

bool GetSubsurfaceProfileUseSeparable(uint SubsurfaceProfileInt)
{
	float  Type = GetSubsurfaceProfileTexture( ( ( ( ( 0 +1) +1) +1) +1) , SubsurfaceProfileInt).a;
	return abs(Type -  1 ) < 0.01f;
}

float4 GetSubsurfaceProfileDMFPInCm(int SubsurfaceProfileInt)
{
	const float4 DiffuseMeanFreePath = DecodeDiffuseMeanFreePath(GetSubsurfaceProfileDiffuseMeanFreePath(SubsurfaceProfileInt));
	const float WorldUnitScale = DecodeWorldUnitScale(GetSubsurfaceProfileWorldUnitScale(SubsurfaceProfileInt));
	return DiffuseMeanFreePath * WorldUnitScale;
}
#line 10 "/Engine/Private/TransmissionCommon.ush"
#line 1 "BurleyNormalizedSSSCommon.ush"
#line 10 "/Engine/Private/BurleyNormalizedSSSCommon.ush"
inline float3 Burley_Profile(float Radius, float3 Albedo, float3 S3D, float L)
{
	float3 D = 1 / S3D;
	float R = Radius / L;
	const float Inv8Pi = 1.0 / (8 * PI);
	float3 NegRbyD = -R / D;
	return Albedo * max((exp(NegRbyD) + exp(NegRbyD / 3.0)) / (D*L)*Inv8Pi, 0);
}





float GetDiffuseReflectProfile(float D, float Radius)
{


	const float Inv8Pi = 1.0 / (8 * PI);
	float NegRbyD = -Radius / D;
	return (exp(NegRbyD) + exp(NegRbyD / 3.0)) / (D*Radius)*Inv8Pi;
}

float3 GetDiffuseReflectProfileWithDiffuseMeanFreePath(float3 L, float3 S3D, float Radius)
{

	float3 D = 1 / S3D;
	float3 R = Radius / L;
	const float Inv8Pi = 1.0 / (8 * PI);
	float3 NegRbyD = -R / D;
	return max((exp(NegRbyD) + exp(NegRbyD / 3.0)) / (D*L)*Inv8Pi, 0);
}

float GetComponentForScalingFactorEstimation(float4 SurfaceAlbedo)
{
	return SurfaceAlbedo.a;
}

float GetDiffuseMeanFreePathForSampling(float4 DiffuseMeanFreePath)
{
	return DiffuseMeanFreePath.a;
}





float GetPerpendicularScalingFactor(float SurfaceAlbedo)
{

	float Value = abs(SurfaceAlbedo - 0.8);
	return 1.85 - SurfaceAlbedo + 7 * Value * Value * Value;
}

float3 GetPerpendicularScalingFactor3D(float3 SurfaceAlbedo)
{
	float3 Value = abs(SurfaceAlbedo - 0.8);
	return 1.85 - SurfaceAlbedo + 7 * Value * Value * Value;
}



float GetDiffuseSurfaceScalingFactor(float SurfaceAlbedo)
{
	float Value = SurfaceAlbedo - 0.8;
	return 1.9 - SurfaceAlbedo + 3.5 * Value * Value;
}

float3 GetDiffuseSurfaceScalingFactor3D(float3 SurfaceAlbedo)
{
	float3 Value = SurfaceAlbedo - 0.8;
	return 1.9 - SurfaceAlbedo + 3.5 * Value * Value;
}



float GetSearchLightDiffuseScalingFactor(float SurfaceAlbedo)
{
	float Value = SurfaceAlbedo - 0.33;
	return 3.5 + 100 * Value * Value * Value * Value;
}

float3 GetSearchLightDiffuseScalingFactor3D(float3 SurfaceAlbedo)
{
	float3 Value = SurfaceAlbedo - 0.33;
	return 3.5 + 100 * Value * Value * Value * Value;
}









float3 GetMFPFromDMFPCoeff(float3 DMFPSurfaceAlbedo, float3 MFPSurfaceAlbedo, float Dmfp2MfpMagicNumber = 0.6f)
{
	return Dmfp2MfpMagicNumber * GetPerpendicularScalingFactor3D(MFPSurfaceAlbedo) / GetSearchLightDiffuseScalingFactor3D(DMFPSurfaceAlbedo);
}

float3 GetMFPFromDMFPApprox(float3 SurfaceAlbedo, float3 TargetSurfaceAlbedo, float3 DMFP)
{
	return GetMFPFromDMFPCoeff(SurfaceAlbedo, TargetSurfaceAlbedo) * DMFP;
}

float3 GetDMFPFromMFPApprox(float3 SurfaceAlbedo, float3 MFP)
{
	float3 MFPFromDMFPCoeff = GetMFPFromDMFPCoeff(SurfaceAlbedo, SurfaceAlbedo);
	return MFP / MFPFromDMFPCoeff;
}


float4 GetSubsurfaceProfileMFPInCm(int SubsurfaceProfileInt)
{
	float4 DMFP = GetSubsurfaceProfileDMFPInCm(SubsurfaceProfileInt);
	float4 SurfaceAlbedo = GetSubsurfaceProfileSurfaceAlbedo(SubsurfaceProfileInt);

	return float4(GetMFPFromDMFPApprox(SurfaceAlbedo.xyz, SurfaceAlbedo.xyz, DMFP.xyz),0.0f);
}

float GetScalingFactor(float A)
{





	float S = GetSearchLightDiffuseScalingFactor(A);

	return S;
}

float3 GetScalingFactor3D(float3 SurfaceAlbedo)
{





	float3 S3D = GetSearchLightDiffuseScalingFactor3D(SurfaceAlbedo);

	return S3D;
}

float3 GetCDF3D(float3 D, float X)
{
	return 1 - 0.25 * exp(-X / D) - 0.75 * exp(-X / (3 * D));
}
#line 181 "/Engine/Private/BurleyNormalizedSSSCommon.ush"
float3 InternalGetBurleyTransmissionProfile(
	float3 SubsurfaceAlebdo,
	float3 MeanFreePathInCm,
	float ThicknessInCm)
{

	const float3 ScalingFactor = GetPerpendicularScalingFactor3D(SubsurfaceAlebdo);
	const float3 r = ThicknessInCm / MeanFreePathInCm.xyz;
	const float3 Output = 0.25 * SubsurfaceAlebdo * (exp(-ScalingFactor * r) + 3 * exp(-ScalingFactor * r / 3));

	return Output;
}

float3 GetBurleyTransmissionProfile(
	float3 SubsurfaceAlebdo,
	float3 MeanFreePathInCm,
	float ThicknessInCm)
{
	const float TransmissionMFPScaleFactor = 100.f;
	const float3 TransmissionThroughput = InternalGetBurleyTransmissionProfile(SubsurfaceAlebdo, MeanFreePathInCm * TransmissionMFPScaleFactor, ThicknessInCm).xyz;
#line 216 "/Engine/Private/BurleyNormalizedSSSCommon.ush"
	const float FadeDistance = 1.0f - saturate(ThicknessInCm *  32  -  5.0f  * ( 32  - 0.5f));

	return TransmissionThroughput * FadeDistance;
}

struct FBurleyParameter
{
	float4 SurfaceAlbedo;
	float4 DiffuseMeanFreePath;
	float WorldUnitScale;
	float SurfaceOpacity;
};
#line 11 "/Engine/Private/TransmissionCommon.ush"

struct FTransmissionProfileParams
{
	float ExtinctionScale;
	float NormalScale;
	float ScatteringDistribution;
	float OneOverIOR;
};

FTransmissionProfileParams InitTransmissionProfileParams()
{
	FTransmissionProfileParams Out;
	Out.ExtinctionScale = 1.0f;
	Out.NormalScale = 0.08f;
	Out.ScatteringDistribution = 0.0f;
	Out.OneOverIOR = 1.0f;
	return Out;
}

FTransmissionProfileParams GetTransmissionProfileParams(uint SubsurfaceProfileInt)
{
	FTransmissionProfileParams Result;


	float4 Data = View.SSProfilesTexture.Load(int3( ( ( ( 0 +1) +1) +1) , SubsurfaceProfileInt, 0));

	Result.ExtinctionScale = Data.x;
	Result.NormalScale = Data.y;
	Result.ScatteringDistribution = Data.z;
	Result.OneOverIOR = Data.w;

	return Result;
}

float4 GetTransmissionProfile(uint SubsurfaceProfileInt, float Thickness)
{

	const float2 TextureSize = View.SSProfilesTextureSizeAndInvSize.xy;
	float ProfileOffset =  ( ( ( ( ( ( ( 0 +1) +1) +1) +1) +1) +1) + ( 13 + 9 + 6 ) ) ;
	float2 uv = float2((ProfileOffset + Thickness /  5.0f  * ( 32  - 1) + 0.5f), SubsurfaceProfileInt + 0.5f) / (TextureSize.xy);
	return Texture2DSampleLevel(View.SSProfilesTexture, View.SSProfilesTransmissionSampler, uv, 0);
}

float EncodeThickness(float Thickness)
{
	return 1 - Thickness;
}

float DecodeThickness(float Thickness)
{
	return 1 - Thickness;
}







float GetSubSurfaceTransmission(float OccluderDistance, float SubsurfaceDensity) { return saturate(FastExp(-OccluderDistance * SubsurfaceDensity)); }
float4 GetSubSurfaceTransmission(float4 OccluderDistance, float SubsurfaceDensity) { return saturate(FastExp(-OccluderDistance * SubsurfaceDensity)); }
#line 12 "/Engine/Private/ShadingModels.ush"
#line 1 "HairBsdf.ush"
#line 5 "/Engine/Private/HairBsdf.ush"
#line 1 "HairShadingCommon.ush"
#line 6 "/Engine/Private/HairShadingCommon.ush"
float3 HairAbsorptionToColor(float3 A, float B=0.3f)
{
	const float b2 = B * B;
	const float b3 = B * b2;
	const float b4 = b2 * b2;
	const float b5 = B * b4;
	const float D = (5.969f - 0.215f * B + 2.532f * b2 - 10.73f * b3 + 5.574f * b4 + 0.245f * b5);
	return exp(-sqrt(A) * D);
}


float3 HairColorToAbsorption(float3 C, float B = 0.3f)
{
	const float b2 = B * B;
	const float b3 = B * b2;
	const float b4 = b2 * b2;
	const float b5 = B * b4;
	const float D = (5.969f - 0.215f * B + 2.532f * b2 - 10.73f * b3 + 5.574f * b4 + 0.245f * b5);
	return Pow2(log(C) / D);
}



float3 GetHairColorFromMelanin(float InMelanin, float InRedness, float3 InDyeColor)
{
	InMelanin = saturate(InMelanin);
	InRedness = saturate(InRedness);
	const float Melanin = -log(max(1 - InMelanin, 0.0001f));
	const float Eumelanin = Melanin * (1 - InRedness);
	const float Pheomelanin = Melanin * InRedness;

	const float3 DyeAbsorption = HairColorToAbsorption(saturate(InDyeColor));
	const float3 Absorption = Eumelanin * float3(0.506f, 0.841f, 1.653f) + Pheomelanin * float3(0.343f, 0.733f, 1.924f);

	return HairAbsorptionToColor(Absorption + DyeAbsorption);
}
#line 6 "/Engine/Private/HairBsdf.ush"









struct FHairTransmittanceData
{
	bool bUseLegacyAbsorption;
	bool bUseSeparableR;
	bool bUseBacklit;

	float OpaqueVisibility;
	float3 LocalScattering;
	float3 GlobalScattering;

	uint ScatteringComponent;
};

FHairTransmittanceData InitHairTransmittanceData(bool bMultipleScatterEnable = true)
{
	FHairTransmittanceData o;
	o.bUseLegacyAbsorption = true;
	o.bUseSeparableR = true;
	o.bUseBacklit = false;

	o.OpaqueVisibility = 1;
	o.LocalScattering = 0;
	o.GlobalScattering = 1;
	o.ScatteringComponent =  0x1u  |  0x2u  |  0x4u  | (bMultipleScatterEnable ?  0x20u  : 0);

	return o;
}

FHairTransmittanceData InitHairStrandsTransmittanceData(bool bMultipleScatterEnable = false)
{
	FHairTransmittanceData o = InitHairTransmittanceData(bMultipleScatterEnable);
	o.bUseLegacyAbsorption = false;
	o.bUseBacklit = true;
	return o;
}




float Hair_g(float B, float Theta)
{
	return exp(-0.5 * Pow2(Theta) / (B * B)) / (sqrt(2 * PI) * B);
}

float Hair_F(float CosTheta)
{
	const float n = 1.55;
	const float F0 = Pow2((1 - n) / (1 + n));
	return F0 + (1 - F0) * Pow5(1 - CosTheta);
}

float3 KajiyaKayDiffuseAttenuation(FGBufferData GBuffer, float3 L, float3 V,  float3  N, float Shadow)
{

	float KajiyaDiffuse = 1 - abs(dot(N, L));

	float3 FakeNormal = normalize(V - N * dot(V, N));

	N = FakeNormal;


	float Wrap = 1;
	float NoL = saturate((dot(N, L) + Wrap) / Square(1 + Wrap));
	float DiffuseScatter = (1 / PI) * lerp(NoL, KajiyaDiffuse, 0.33) * GBuffer.Metallic;
	float Luma = Luminance(GBuffer.BaseColor);
	float3 ScatterTint = pow(abs(GBuffer.BaseColor / Luma), 1 - Shadow);
	return sqrt(abs(GBuffer.BaseColor)) * DiffuseScatter * ScatterTint;
}

float3 EvaluateHairMultipleScattering(
	const FHairTransmittanceData TransmittanceData,
	const float Roughness,
	const float3 Fs)
{
	return TransmittanceData.GlobalScattering * (Fs + TransmittanceData.LocalScattering) * TransmittanceData.OpaqueVisibility;
}
#line 315 "/Engine/Private/HairBsdf.ush"
float3 HairShading( FGBufferData GBuffer, float3 L, float3 V,  float3  N, float Shadow, FHairTransmittanceData HairTransmittance, float InBacklit, float Area, uint2 Random )
{



	float ClampedRoughness = clamp(GBuffer.Roughness, 1/255.0f, 1.0f);


	const float Backlit = min(InBacklit, HairTransmittance.bUseBacklit ? GBuffer.CustomData.z : 1);
#line 341 "/Engine/Private/HairBsdf.ush"
	const float VoL = dot(V,L);
	const float SinThetaL = clamp(dot(N,L), -1.f, 1.f);
	const float SinThetaV = clamp(dot(N,V), -1.f, 1.f);
	float CosThetaD = cos( 0.5 * abs( asinFast( SinThetaV ) - asinFast( SinThetaL ) ) );



	const float3 Lp = L - SinThetaL * N;
	const float3 Vp = V - SinThetaV * N;
	const float CosPhi = dot(Lp,Vp) * rsqrt( dot(Lp,Lp) * dot(Vp,Vp) + 1e-4 );
	const float CosHalfPhi = sqrt( saturate( 0.5 + 0.5 * CosPhi ) );


	float n = 1.55;

	float n_prime = 1.19 / CosThetaD + 0.36 * CosThetaD;

	float Shift = 0.035;
	float Alpha[] =
	{
		-Shift * 2,
		Shift,
		Shift * 4,
	};
	float B[] =
	{
		Area + Pow2(ClampedRoughness),
		Area + Pow2(ClampedRoughness) / 2,
		Area + Pow2(ClampedRoughness) * 2,
	};

	float3 S = 0;
	if (HairTransmittance.ScatteringComponent &  0x1u )
	{
		const float sa = sin(Alpha[0]);
		const float ca = cos(Alpha[0]);
		float ShiftR = 2 * sa * (ca * CosHalfPhi * sqrt(1 - SinThetaV * SinThetaV) + sa * SinThetaV);
		float BScale = HairTransmittance.bUseSeparableR ? sqrt(2.0) * CosHalfPhi : 1;
		float Mp = Hair_g(B[0] * BScale, SinThetaL + SinThetaV - ShiftR);
		float Np = 0.25 * CosHalfPhi;
		float Fp = Hair_F(sqrt(saturate(0.5 + 0.5 * VoL)));
		S += Mp * Np * Fp * (GBuffer.Specular * 2) * lerp(1, Backlit, saturate(-VoL));
#line 387 "/Engine/Private/HairBsdf.ush"
	}


	if (HairTransmittance.ScatteringComponent &  0x2u )
	{
		float Mp = Hair_g( B[1], SinThetaL + SinThetaV - Alpha[1] );

		float a = 1 / n_prime;


		float h = CosHalfPhi * ( 1 + a * ( 0.6 - 0.8 * CosPhi ) );




		float f = Hair_F( CosThetaD * sqrt( saturate( 1 - h*h ) ) );
		float Fp = Pow2(1 - f);


		float3 Tp = 0;
		if (HairTransmittance.bUseLegacyAbsorption)
		{
			Tp = pow(abs(GBuffer.BaseColor), 0.5 * sqrt(1 - Pow2(h * a)) / CosThetaD);
		}
		else
		{

			const float3 AbsorptionColor = HairColorToAbsorption(GBuffer.BaseColor);
			Tp = exp(-AbsorptionColor * 2 * abs(1 - Pow2(h * a) / CosThetaD));
		}







		float Np = exp( -3.65 * CosPhi - 3.98 );

		S += Mp * Np * Fp * Tp * Backlit;
#line 431 "/Engine/Private/HairBsdf.ush"
	}


	if (HairTransmittance.ScatteringComponent &  0x4u )
	{
		float Mp = Hair_g( B[2], SinThetaL + SinThetaV - Alpha[2] );


		float f = Hair_F( CosThetaD * 0.5 );
		float Fp = Pow2(1 - f) * f;

		float3 Tp = pow(abs(GBuffer.BaseColor), 0.8 / CosThetaD );



		float Np = exp( 17 * CosPhi - 16.78 );

		S += Mp * Np * Fp * Tp;
#line 453 "/Engine/Private/HairBsdf.ush"
	}


	if (HairTransmittance.ScatteringComponent &  0x20u )
	{
		S = EvaluateHairMultipleScattering(HairTransmittance, ClampedRoughness, S);



		S += KajiyaKayDiffuseAttenuation(GBuffer, L, V, N, Shadow);

	}

	S = -min(-S, 0.0);
	return S;
}
#line 13 "/Engine/Private/ShadingModels.ush"
#line 1 "ShadingEnergyConservation.ush"
#line 42 "/Engine/Private/ShadingEnergyConservation.ush"
float2 GGXEnergyLookup(float Roughness, float NoV)
{









	return float2(1, 0);

}

float GGXEnergyLookup(float Roughness, float NoV, float Eta)
{








	return 1.0;

}

float2 ClothEnergyLookup(float Roughness, float NoV)
{
#line 85 "/Engine/Private/ShadingEnergyConservation.ush"
	return float2(1, 0);

}

float DiffuseEnergyLookup(float Roughness, float NoV)
{










	return 1.f;

}
#line 117 "/Engine/Private/ShadingEnergyConservation.ush"
#line 1 "ShadingEnergyConservationTemplate.ush"
#line 18 "/Engine/Private/ShadingEnergyConservationTemplate.ush"
float3   GetF0F90RGB (float3 InF0)
{



	return InF0;

}

struct  FBxDFEnergyTermsRGB
{
	float3  W;
	float3  E;
};



FBxDFEnergyTermsRGB   ComputeFresnelEnergyTermsRGB (float2 E, float3 InF0, float3 InF90)
{
	float3  F0 =  GetF0F90RGB (InF0);
	float3  F90 =  GetF0F90RGB (InF90);

	FBxDFEnergyTermsRGB  Result;



	Result.W = View.bShadingEnergyConservation ? (1.0 + F0 * ((1 - E.x) / E.x)) : 1.0f;
#line 51 "/Engine/Private/ShadingEnergyConservationTemplate.ush"
	Result.E = Result.W * (E.x * F0 + E.y * (F90 - F0));
	return Result;
}

FBxDFEnergyTermsRGB   ComputeGGXSpecEnergyTermsRGB (float Roughness, float NoV, float3 F0, float3 F90)
{
	FBxDFEnergyTermsRGB  Out;





	{
		Out.W = 1.0f;
		Out.E =  GetF0F90RGB (F0);
	}

	return Out;
}

FBxDFEnergyTermsRGB   ComputeGGXSpecEnergyTermsRGB (float Roughness, float NoV, float3 F0)
{
	const float F90 = saturate(50.0 * F0.g);
	return  ComputeGGXSpecEnergyTermsRGB (Roughness, NoV, F0, F90);
}

FBxDFEnergyTermsRGB   ComputeClothEnergyTermsRGB (float Roughness, float NoV, float3 F0, float3 F90)
{
	FBxDFEnergyTermsRGB  Out;





	{
		Out.W = 1.0f;
		Out.E =  GetF0F90RGB (F0);
	}

	return Out;
}

FBxDFEnergyTermsRGB   ComputeClothEnergyTermsRGB (float Roughness, float NoV, float3 F0)
{
	const float F90 = saturate(50.0 * F0.g);
	return  ComputeClothEnergyTermsRGB (Roughness, NoV, F0, F90);
}

FBxDFEnergyTermsRGB   ComputeDiffuseEnergyTermsRGB (float Roughness, float NoV)
{
	FBxDFEnergyTermsRGB  Out;





	{
		Out.E = 1.0f;
	}

	Out.W = 1.0f;
	return Out;
}






float ComputeEnergyPreservation( FBxDFEnergyTermsRGB  EnergyTerms)
{







	return 1.0f;

}


float3  ComputeEnergyConservation( FBxDFEnergyTermsRGB  EnergyTerms)
{
	return EnergyTerms.W;
}
#line 118 "/Engine/Private/ShadingEnergyConservation.ush"
#line 126 "/Engine/Private/ShadingEnergyConservation.ush"
#line 1 "ShadingEnergyConservationTemplate.ush"
#line 18 "/Engine/Private/ShadingEnergyConservationTemplate.ush"
float   GetF0F90A (float3 InF0)
{

	return max3(InF0.x, InF0.y, InF0.z);
#line 25 "/Engine/Private/ShadingEnergyConservationTemplate.ush"
}

struct  FBxDFEnergyTermsA
{
	float  W;
	float  E;
};



FBxDFEnergyTermsA   ComputeFresnelEnergyTermsA (float2 E, float3 InF0, float3 InF90)
{
	float  F0 =  GetF0F90A (InF0);
	float  F90 =  GetF0F90A (InF90);

	FBxDFEnergyTermsA  Result;



	Result.W = View.bShadingEnergyConservation ? (1.0 + F0 * ((1 - E.x) / E.x)) : 1.0f;
#line 51 "/Engine/Private/ShadingEnergyConservationTemplate.ush"
	Result.E = Result.W * (E.x * F0 + E.y * (F90 - F0));
	return Result;
}

FBxDFEnergyTermsA   ComputeGGXSpecEnergyTermsA (float Roughness, float NoV, float3 F0, float3 F90)
{
	FBxDFEnergyTermsA  Out;





	{
		Out.W = 1.0f;
		Out.E =  GetF0F90A (F0);
	}

	return Out;
}

FBxDFEnergyTermsA   ComputeGGXSpecEnergyTermsA (float Roughness, float NoV, float3 F0)
{
	const float F90 = saturate(50.0 * F0.g);
	return  ComputeGGXSpecEnergyTermsA (Roughness, NoV, F0, F90);
}

FBxDFEnergyTermsA   ComputeClothEnergyTermsA (float Roughness, float NoV, float3 F0, float3 F90)
{
	FBxDFEnergyTermsA  Out;





	{
		Out.W = 1.0f;
		Out.E =  GetF0F90A (F0);
	}

	return Out;
}

FBxDFEnergyTermsA   ComputeClothEnergyTermsA (float Roughness, float NoV, float3 F0)
{
	const float F90 = saturate(50.0 * F0.g);
	return  ComputeClothEnergyTermsA (Roughness, NoV, F0, F90);
}

FBxDFEnergyTermsA   ComputeDiffuseEnergyTermsA (float Roughness, float NoV)
{
	FBxDFEnergyTermsA  Out;





	{
		Out.E = 1.0f;
	}

	Out.W = 1.0f;
	return Out;
}






float ComputeEnergyPreservation( FBxDFEnergyTermsA  EnergyTerms)
{







	return 1.0f;

}


float  ComputeEnergyConservation( FBxDFEnergyTermsA  EnergyTerms)
{
	return EnergyTerms.W;
}
#line 127 "/Engine/Private/ShadingEnergyConservation.ush"
#line 14 "/Engine/Private/ShadingModels.ush"
#line 1 "ParticipatingMediaCommon.ush"
#line 19 "/Engine/Private/ParticipatingMediaCommon.ush"
struct FParticipatingMedia
{
	float3 ScatteringCoef;
	float3 AbsorptionCoef;
	float3 ExtinctionCoef;
	float3 MeanFreePath;
	float3 Albedo;
	float3 BaseColor;
};





float3 GetBaseColorFromAlbedo(const float3 Albedo, const float g = 0.0f)
{
	const float3 s = sqrt((1 - Albedo) / (1.0f - Albedo * g));
	const float3 BaseColor = ((1.0f - s) * (1 - 0.139 * s)) / (1.0f + 1.17 * s);
	return BaseColor;
}
float3 GetAlbedoFromBaseColor(const float3 BaseColor, const float g = 0.0f)
{
	const float3 s = 4.09712 + 4.20863 * BaseColor - sqrt(9.59217 + 41.6808 * BaseColor + 17.7126 * BaseColor * BaseColor);
	const float3 Albedo = (1.0f - s * s) / (1.0f - g * s * s);
	return Albedo;
}


FParticipatingMedia CreateMediumFromAlbedoMFP(float3 Albedo, float3 MeanFreePathMeters)
{
	FParticipatingMedia PM = (FParticipatingMedia)0;
	PM.Albedo = Albedo;
	PM.BaseColor = GetBaseColorFromAlbedo(Albedo);
	PM.MeanFreePath = MeanFreePathMeters;
	PM.ExtinctionCoef = 1.0f / max( 0.000000000001f , PM.MeanFreePath);
	PM.ScatteringCoef = PM.Albedo * PM.ExtinctionCoef;
	PM.AbsorptionCoef = max(0.0f, PM.ExtinctionCoef - PM.ScatteringCoef);
	return PM;
}


FParticipatingMedia CreateMediumFromBaseColorMFP(float3 BaseColor, float3 MeanFreePathMeters)
{
	FParticipatingMedia PM = (FParticipatingMedia)0;
	PM.Albedo = GetAlbedoFromBaseColor(BaseColor);
	PM.BaseColor = BaseColor;
	PM.MeanFreePath = MeanFreePathMeters;
	PM.ExtinctionCoef = 1.0f / max( 0.000000000001f , PM.MeanFreePath);
	PM.ScatteringCoef = PM.Albedo * PM.ExtinctionCoef;
	PM.AbsorptionCoef = max(0.0f, PM.ExtinctionCoef - PM.ScatteringCoef);
	return PM;
}







float IsotropicPhase()
{
	return 1.0f / (4.0f * PI);
}


float HenyeyGreensteinPhase(float G, float CosTheta)
{


	float Numer = 1.0f - G * G;
	float Denom = 1.0f + G * G + 2.0f * G * CosTheta;
	return Numer / (4.0f * PI * Denom * sqrt(Denom));
}

float RayleighPhase(float CosTheta)
{
	float Factor = 3.0f / (16.0f * PI);
	return Factor * (1.0f + CosTheta * CosTheta);
}


float SchlickPhaseFromK(float K, float CosTheta)
{
	const float SchlickPhaseFactor = 1.0f + K * CosTheta;
	const float PhaseValue = (1.0f - K * K) / (4.0f * PI * SchlickPhaseFactor * SchlickPhaseFactor);
	return PhaseValue;
}
float SchlickPhase(float G, float CosTheta)
{
	const float K = 1.55f * G - 0.55f * G * G * G;
	return SchlickPhaseFromK(K, CosTheta);
}


float HenyeyGreensteinPhaseInvertCDF(float E, float G)
{


	float t0 = (1.0 - G) + G * E;
	float t1 = (1.0 - E) + E * E;
	float t2 = t1 + (G * E) * t0;
	float t3 = (2.0 * E - 1.0) - G * G;
	float Num = t3 + (2.0 * G) * t2;
	float Den = t0 + G * E;
	return Num / (Den * Den);
}


float4 ImportanceSampleHenyeyGreensteinPhase(float2 E, float G)
{
	float Phi = 2.0f * PI * E.x;
	float CosTheta = HenyeyGreensteinPhaseInvertCDF(E.y, G);
	float SinTheta = sqrt(max(0.0f, 1.0f - CosTheta * CosTheta));

	float3 H = float3(SinTheta * sin(Phi), SinTheta * cos(Phi), CosTheta);

	return float4(H, HenyeyGreensteinPhase(G, CosTheta));
}


float RayleighPhaseInvertCdf(float E)
{


	float Z = E * 4.0 - 2.0;
	float InvZ = sqrt(Z * Z + 1.0);
	float u = pow(Z + InvZ, 1.0 / 3.0);
	return u - rcp(u);
}

float4 ImportanceSampleRayleigh(float2 E)
{
	float Phi = 2.0f * PI * E.x;
	float CosTheta = RayleighPhaseInvertCdf(E.y);
	float SinTheta = sqrt(max(0.0f, 1.0f - CosTheta * CosTheta));
	float3 H = float3(SinTheta * sin(Phi), SinTheta * cos(Phi), CosTheta);
	return float4(H, RayleighPhase(CosTheta));
}






float3 TransmittanceToExtinction(in float3 TransmittanceColor, in float ThicknessMeters)
{


	return -log(clamp(TransmittanceColor,  0.000000000001f , 1.0f)) / max( 0.000000000001f , ThicknessMeters);
}

float3 TransmittanceToMeanFreePath(in float3 TransmittanceColor, in float ThicknessMeters)
{
	return 1.0f / max( 0.000000000001f , TransmittanceToExtinction(TransmittanceColor, ThicknessMeters));
}

float3 ExtinctionToTransmittance(in float3 Extinction, in float ThicknessMeters)
{
	return exp(-Extinction * ThicknessMeters);
}





float3 IsotropicMediumSlabDirectionalAlbedoFade(float3 BaseColor, float3 MFP)
{
	float3 Fade;

	const float BaseColorFadesOutBelowPercentage = 10.0f;
	Fade = saturate(BaseColor * BaseColorFadesOutBelowPercentage);

	const float FitLastMeasuredSampleMFP = 20.0f;
	const float AlbedoIsZeroForMFP = 1000.0f;
	Fade*= saturate(1.0f - (MFP - FitLastMeasuredSampleMFP) / (AlbedoIsZeroForMFP - FitLastMeasuredSampleMFP));

	return Fade;
}

float3 IsotropicMediumSlabPunctualDirectionalAlbedo(FParticipatingMedia PM)
{


	const float3 MFP = max(0.01f, PM.MeanFreePath);

	const float3 EvaluateForBaseColor1 = 0.0855674 / (0.237742 + (MFP + ((0.0310849 - MFP) / (1.95492 * MFP + 2.07238))));
	const float3 EvaluateForBaseColor01 = 0.0167964 / (0.541037 * (pow(1.17902, (-4.33046) / MFP) * (-0.294969 + MFP)) + 0.797592);


	float3 FinalEvaluate = lerp(EvaluateForBaseColor01, EvaluateForBaseColor1, (PM.BaseColor - 0.1f) / (1.0f - 0.1f));
	return FinalEvaluate * IsotropicMediumSlabDirectionalAlbedoFade(PM.BaseColor, MFP);
}

float3 IsotropicMediumSlabEnvDirectionalAlbedo(FParticipatingMedia PM)
{


	const float3 MFP = max(0.01f, PM.MeanFreePath);

	const float3 EvaluateForBaseColor1 = 0.00231881 + (0.51379 / (pow(MFP, 1.03577) + 0.510465));
	const float3 EvaluateForBaseColor01 = 0.189167 / (1.55597 + (MFP + pow(0.182843, 0.0666775 + MFP)));


	float3 FinalEvaluate = lerp(EvaluateForBaseColor01, EvaluateForBaseColor1, (PM.BaseColor - 0.1f) / (1.0f - 0.1f));
	return FinalEvaluate * IsotropicMediumSlabDirectionalAlbedoFade(PM.BaseColor, MFP);
}

float3 IsotropicMediumSlabTransmittance(FParticipatingMedia PM, float SlabThickness, float NoV)
{
	const float3 SafeExtinctionThreshold = 0.000001f;
	const float3 SafeExtinctionCoefficients = max(SafeExtinctionThreshold, PM.ExtinctionCoef);

	const float PathLength = SlabThickness / max(0.0001f, abs(NoV));
	const float3 SafePathSegmentTransmittance = exp(-SafeExtinctionCoefficients * PathLength);

	return SafePathSegmentTransmittance;
}
#line 15 "/Engine/Private/ShadingModels.ush"
#line 1 "ColorSpace.ush"
#line 11 "/Engine/Private/ColorSpace.ush"
static const float3x3 sRGB_2_LMS_MAT =
{
    17.8824, 43.5161, 4.1193,
     3.4557, 27.1554, 3.8671,
     0.02996, 0.18431, 1.4670,
};

static const float3x3 LMS_2_sRGB_MAT =
{
    0.0809, -0.1305, 0.1167,
   -0.0102, 0.0540, -0.1136,
   -0.0003, -0.0041, 0.6935,
};

float3 sRGB_2_LMS( float3 RGB )
{
	return mul(sRGB_2_LMS_MAT, RGB);
}

float3 LMS_2_sRGB( float3 LMS )
{
	return mul(LMS_2_sRGB_MAT, LMS);
}






static const float3x3 XYZ_2_LinearRGB_MAT =
{
	 3.2409699419, -1.5373831776, -0.4986107603,
	-0.9692436363, 1.8759675015, 0.0415550574,
	 0.0556300797, -0.2039769589, 1.0569715142,
};

static const float3x3 LinearRGB_2_XYZ_MAT =
{
	0.4124564, 0.3575761, 0.1804375,
	0.2126729, 0.7151522, 0.0721750,
	0.0193339, 0.1191920, 0.9503041,
};

float3 LinearRGB_2_XYZ( float3 LinearRGB )
{
	return mul(LinearRGB_2_XYZ_MAT, LinearRGB);
}

float3 XYZ_2_LinearRGB( float3 XYZ )
{
	return mul(XYZ_2_LinearRGB_MAT, XYZ);
}
#line 75 "/Engine/Private/ColorSpace.ush"
static const float3 XYZ_WHITE_REF_D65 = float3(95.047, 100.0, 108.883);
static const float3 XYZ_WHITE_REF_D50 = float3(96.6797, 100.0, 82.5188);
static const float3 XYZ_WHITE_REF_D65_NOMINAL = float3(0.95047, 1.00, 1.08883);
static const float3 XYZ_WHITE_REF_D50_NOMINAL = float3(0.966797, 1.00, 0.825188);
static const float XYZ_2_LAB_DELTA_SQUARED = 0.04280618311;
static const float XYZ_2_LAB_DELTA_CUBED = 0.00885645167;

float xyz_otherwise(float t)
{
	return (t / (3.0 * XYZ_2_LAB_DELTA_SQUARED)) + 4.0 / 29.0;
}

float3 LinearRGB_2_LAB( float3 LinearRGB, float3 ReferenceWhite )
{
	float3 XYZ = LinearRGB_2_XYZ(LinearRGB);

	float t_X = XYZ.x / ReferenceWhite.x;
	float t_Y = XYZ.y / ReferenceWhite.y;
	float t_Z = XYZ.z / ReferenceWhite.z;

	float f_X = (t_X > XYZ_2_LAB_DELTA_CUBED) ? pow(t_X, 1.0 / 3.0) : xyz_otherwise(t_X);
	float f_Y = (t_Y > XYZ_2_LAB_DELTA_CUBED) ? pow(t_Y, 1.0 / 3.0) : xyz_otherwise(t_Y);
	float f_Z = (t_Z > XYZ_2_LAB_DELTA_CUBED) ? pow(t_Z, 1.0 / 3.0) : xyz_otherwise(t_Z);

	float L = ( 116.0 * f_Y ) - 16.0;
	float a = 500.0 * ( f_X - f_Y );
	float b = 200.0 * ( f_Y - f_Z );

	return float3(L, a, b);
}

float lab_otherwise(float t)
{
	return (3.0 * XYZ_2_LAB_DELTA_SQUARED) * (t - (4.0 / 29.0));
}

float3 LAB_2_LinearRGB( float3 LAB, float3 ReferenceWhite)
{
	float L = LAB.x;
	float a = LAB.y;
	float b = LAB.z;

	float t_y = (L + 16.0) / 116.0;
	float t_x = t_y + (a / 500.0);
	float t_z = t_y - (b / 200.0);

	float f_x = pow(t_x, 3.0);
	float f_y = pow(t_y, 3.0);
	float f_z = pow(t_z, 3.0);

	if (f_x <= XYZ_2_LAB_DELTA_CUBED)
	{
		f_x = lab_otherwise(t_x);
	}

	if (f_y <= XYZ_2_LAB_DELTA_CUBED)
	{
		f_y = lab_otherwise(t_y);
	}

	if (f_z <= XYZ_2_LAB_DELTA_CUBED)
	{
		f_z = lab_otherwise(t_z);
	}

	float X = ReferenceWhite.x * f_x;
	float Y = ReferenceWhite.y * f_y;
	float Z = ReferenceWhite.z * f_z;

	return XYZ_2_LinearRGB(float3(X, Y, Z));
}
#line 159 "/Engine/Private/ColorSpace.ush"
float3 LinearRGB_2_YCoCg(float3 RGB)
{
	float Y = dot(RGB, float3(1, 2, 1));
	float Co = dot(RGB, float3(2, 0, -2));
	float Cg = dot(RGB, float3(-1, 2, -1));

	float3 YCoCg = float3(Y, Co, Cg);
	return YCoCg;
}

float3 YCoCg_2_LinearRGB(float3 YCoCg)
{
	float Y = YCoCg.x * 0.25;
	float Co = YCoCg.y * 0.25;
	float Cg = YCoCg.z * 0.25;

	float R = Y + Co - Cg;
	float G = Y + Cg;
	float B = Y - Co - Cg;

	float3 RGB = float3(R, G, B);
	return RGB;
}

float3 YCoCg_2_LCoCg(float3 YCoCg)
{
	return float3(
		YCoCg.x,
		YCoCg.yz * (YCoCg.x > 0 ? rcp(YCoCg.x) : 0));
}

float3 LCoCg_2_YCoCg(float3 LCoCg)
{
	return float3(LCoCg.x, LCoCg.x * LCoCg.yz);
}

float3 LinearRGB_2_LCoCg(float3 RGB)
{
	return YCoCg_2_LCoCg(LinearRGB_2_YCoCg(RGB));
}

float3 LCoCg_2_LinearRGB(float3 LCoCg)
{
	return YCoCg_2_LinearRGB(LCoCg_2_YCoCg(LCoCg));
}


float3 LinearRGB_2_NormalisedYCoCg(float3 RGB)
{
	return LinearRGB_2_YCoCg(RGB) * float3(1.0f /  4.0 , 0.25f, 0.25f) + float3(0.0f, 0.5f, 0.5f);
}

float3 NormalisedYCoCg_2_LinearRGB(float3 YCoCg)
{
	return YCoCg_2_LinearRGB(YCoCg * float3( 4.0 , 4.0f, 4.0f) + float3(0.0f, -2.0f, -2.0f));
}





float3 HUE_2_LinearRGB(in float H)
{
	float R = abs(H * 6 - 3) - 1;
	float G = 2 - abs(H * 6 - 2);
	float B = 2 - abs(H * 6 - 4);
	return saturate(float3(R, G, B));
}

float3 HSV_2_LinearRGB(in float3 HSV)
{
	float3 RGB = HUE_2_LinearRGB(HSV.x);
	return ((RGB - 1) * HSV.y + 1) * HSV.z;
}

float3 RGB_2_HCV(in float3 RGB)
{

	float4 P = (RGB.g < RGB.b) ? float4(RGB.bg, -1.0f, 2.0f / 3.0f): float4(RGB.gb, 0.0f, -1.0f / 3.0f);
	float4 Q = (RGB.r < P.x) ? float4(P.xyw, RGB.r) : float4(RGB.r, P.yzx);
	float Chroma = Q.x - min(Q.w, Q.y);
	float Hue = abs((Q.w - Q.y) / (6.0f * Chroma + 1e-10f) + Q.z);
	return float3(Hue, Chroma, Q.x);
}

float3 LinearRGB_2_HSV(in float3 RGB)
{
	float3 HCV = RGB_2_HCV(RGB);
	float s = HCV.y / (HCV.z + 1e-10f);
	return float3(HCV.x, s, HCV.z);
}





float3 LAB_2_LCH(float3 LAB)
{
	float3 LCH;
	LCH.x = LAB.x;
	LCH.y = length(LAB.yz);
	float HInDegree0To360 = 0.0f;

	if (LAB.z != 0 || LAB.y != 0)
	{
		HInDegree0To360 = atan2(LAB.z, LAB.y) * 180 / 3.1415926535897932f;
		HInDegree0To360 += lerp(0, 360.0f, HInDegree0To360 < 0);
	}
	LCH.z = HInDegree0To360;
	return LCH;
}
#line 16 "/Engine/Private/ShadingModels.ush"
#line 131 "/Engine/Private/ShadingModels.ush"
struct FDirectLighting
{
	float3 Diffuse;
	float3 Specular;
	float3 Transmission;
};

struct FShadowTerms
{
	float  SurfaceShadow;
	float  TransmissionShadow;
	float  TransmissionThickness;
	FHairTransmittanceData HairTransmittance;
};
FDirectLighting HairBxDF(FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float Falloff,  float  NoL, FAreaLight AreaLight, FShadowTerms Shadow)
{
	const float3 BsdfValue = HairShading(GBuffer, L, V, N, Shadow.TransmissionShadow, Shadow.HairTransmittance, 1, 0, uint2(0, 0));

	FDirectLighting Lighting;
	Lighting.Diffuse = 0;
	Lighting.Specular = 0;
	Lighting.Transmission = AreaLight.FalloffColor * Falloff * BsdfValue;
	return Lighting;
}

float New_a2( float a2, float SinAlpha, float VoH )
{
	return a2 + 0.25 * SinAlpha * (3.0 * sqrtFast(a2) + SinAlpha) / ( VoH + 0.001 );


}

float EnergyNormalization( inout float a2, float VoH, FAreaLight AreaLight )
{
	if( AreaLight.SphereSinAlphaSoft > 0 )
	{

		a2 = saturate( a2 + Pow2( AreaLight.SphereSinAlphaSoft ) / ( VoH * 3.6 + 0.4 ) );
	}

	float Sphere_a2 = a2;
	float Energy = 1;
	if( AreaLight.SphereSinAlpha > 0 )
	{
		Sphere_a2 = New_a2( a2, AreaLight.SphereSinAlpha, VoH );
		Energy = a2 / Sphere_a2;
	}

	if( AreaLight.LineCosSubtended < 1 )
	{

		float LineCosTwoAlpha = AreaLight.LineCosSubtended;
		float LineTanAlpha = sqrt( ( 1.0001 - LineCosTwoAlpha ) / ( 1 + LineCosTwoAlpha ) );
		float Line_a2 = New_a2( Sphere_a2, LineTanAlpha, VoH );
		Energy *= sqrt( Sphere_a2 / Line_a2 );
#line 192 "/Engine/Private/ShadingModels.ush"
	}

	return Energy;
}

float3 SpecularGGX(float Roughness, float Anisotropy, float3 SpecularColor, BxDFContext Context, float NoL, FAreaLight AreaLight)
{
	float Alpha = Roughness * Roughness;
	float a2 = Alpha * Alpha;

	FAreaLight Punctual = AreaLight;
	Punctual.SphereSinAlpha = 0;
	Punctual.SphereSinAlphaSoft = 0;
	Punctual.LineCosSubtended = 1;
	Punctual.Rect = (FRect)0;
	Punctual.IsRectAndDiffuseMicroReflWeight = 0;

	float Energy = EnergyNormalization(a2, Context.VoH, Punctual);

	float ax = 0;
	float ay = 0;
	GetAnisotropicRoughness(Alpha, Anisotropy, ax, ay);


	float3 D = D_GGXaniso(ax, ay, Context.NoH, Context.XoH, Context.YoH) * Energy;
	float3 Vis = Vis_SmithJointAniso(ax, ay, Context.NoV, NoL, Context.XoV, Context.XoL, Context.YoV, Context.YoL);
	float3 F = F_Schlick( SpecularColor, Context.VoH );

	return (D * Vis) * F;
}

float3 SpecularGGX( float Roughness, float3 SpecularColor, BxDFContext Context,  float  NoL, FAreaLight AreaLight )
{
	float a2 = Pow4( Roughness );
	float Energy = EnergyNormalization( a2, Context.VoH, AreaLight );






	float D = D_GGX( a2, Context.NoH ) * Energy;
	float Vis = Vis_SmithJointApprox( a2, Context.NoV, NoL );
	float3 F = F_Schlick( SpecularColor, Context.VoH );

	return (D * Vis) * F;

}

float3  DualSpecularGGX( float  AverageRoughness,  float  Lobe0Roughness,  float  Lobe1Roughness,  float  LobeMix,  float3  SpecularColor, BxDFContext Context,  float  NoL, FAreaLight AreaLight)
{
	float AverageAlpha2 = Pow4(AverageRoughness);
	float Lobe0Alpha2 = Pow4(Lobe0Roughness);
	float Lobe1Alpha2 = Pow4(Lobe1Roughness);

	float Lobe0Energy = EnergyNormalization(Lobe0Alpha2, Context.VoH, AreaLight);
	float Lobe1Energy = EnergyNormalization(Lobe1Alpha2, Context.VoH, AreaLight);







	float D = lerp(D_GGX(Lobe0Alpha2, Context.NoH) * Lobe0Energy, D_GGX(Lobe1Alpha2, Context.NoH) * Lobe1Energy, LobeMix);
	float Vis = Vis_SmithJointApprox(AverageAlpha2, Context.NoV, NoL);
	float3 F = F_Schlick(SpecularColor, Context.VoH);

	return (D * Vis) * F;

}

FDirectLighting DefaultLitBxDF( FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float Falloff,  float  NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	BxDFContext Context;
	FDirectLighting Lighting;




	bool bHasAnisotropy = false;


	float NoV, VoH, NoH;
	[branch]
	if (bHasAnisotropy)
	{
		float3  X = GBuffer.WorldTangent;
		float3  Y = normalize(cross(N, X));
		Init(Context, N, X, Y, V, L);

		NoV = Context.NoV;
		VoH = Context.VoH;
		NoH = Context.NoH;
	}
	else
	{



		Init(Context, N, V, L);


		NoV = Context.NoV;
		VoH = Context.VoH;
		NoH = Context.NoH;

		SphereMaxNoH(Context, AreaLight.SphereSinAlpha, true);
	}

	Context.NoV = saturate(abs( Context.NoV ) + 1e-5);






	Lighting.Diffuse = Diffuse_Lambert(GBuffer.DiffuseColor);

	Lighting.Diffuse *= AreaLight.FalloffColor * (Falloff * NoL);

	[branch]
	if (bHasAnisotropy)
	{

		Lighting.Specular = AreaLight.FalloffColor * (Falloff * NoL) * SpecularGGX(GBuffer.Roughness, GBuffer.Anisotropy, GBuffer.SpecularColor, Context, NoL, AreaLight);
	}
	else
	{
		if( IsRectLight(AreaLight) )
		{
			Lighting.Specular = RectGGXApproxLTC(GBuffer.Roughness, GBuffer.SpecularColor, N, V, AreaLight.Rect, AreaLight.Texture);
		}
		else
		{
			Lighting.Specular = AreaLight.FalloffColor * (Falloff * NoL) * SpecularGGX(GBuffer.Roughness, GBuffer.SpecularColor, Context, NoL, AreaLight);
		}
	}

	FBxDFEnergyTermsRGB  EnergyTerms =  ComputeGGXSpecEnergyTermsRGB (GBuffer.Roughness, Context.NoV, GBuffer.SpecularColor);


	Lighting.Diffuse *= ComputeEnergyPreservation(EnergyTerms);


	Lighting.Specular *= ComputeEnergyConservation(EnergyTerms);

	Lighting.Transmission = 0;
	return Lighting;
}


float3 SimpleShading( float3 DiffuseColor, float3 SpecularColor, float Roughness, float3 L, float3 V,  float3  N )
{
	const float NoV = saturate(dot(N, V));
	const  FBxDFEnergyTermsRGB  EnergyTerms =  ComputeGGXSpecEnergyTermsRGB (Roughness, NoV, SpecularColor);

	float3 H = normalize(V + L);
	float NoH = saturate( dot(N, H) );


	float D = D_GGX( Pow4(Roughness), NoH );
	float Vis = Vis_Implicit();
	float3 F = F_None( SpecularColor );

	return
		Diffuse_Lambert( DiffuseColor ) * ComputeEnergyPreservation(EnergyTerms) +
		(D * Vis) * F * ComputeEnergyConservation(EnergyTerms);
}

float RefractBlend(float VoH, float Eta)
{

	float k = 1.0 - Eta * Eta * (1.0 - VoH * VoH);
	return Eta * VoH - sqrt(k);
}

float  RefractBlendClearCoatApprox( float  VoH)
{

	return (0.63 - 0.22 * VoH) * VoH - 0.745;
}

float3 Refract(float3 V, float3 H, float Eta)
{

	float VoH = dot(V, H);
	return RefractBlend(VoH, Eta) * H - Eta * V;
}

BxDFContext RefractClearCoatContext(BxDFContext Context)
{








	BxDFContext RefractedContext = Context;
	float  Eta = 1.0 / 1.5;
	float  RefractionBlendFactor = RefractBlendClearCoatApprox(Context.VoH);
	float  RefractionProjectionTerm = RefractionBlendFactor * Context.NoH;
	RefractedContext.NoV = clamp(Eta * Context.NoV - RefractionProjectionTerm, 0.001, 1.0);
	RefractedContext.NoL = clamp(Eta * Context.NoL - RefractionProjectionTerm, 0.001, 1.0);
	RefractedContext.VoH = saturate(Eta * Context.VoH - RefractionBlendFactor);
	RefractedContext.VoL = 2.0 * RefractedContext.VoH * RefractedContext.VoH - 1.0;
	RefractedContext.NoH = Context.NoH;
	return RefractedContext;
}

FDirectLighting ClearCoatBxDF( FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float Falloff,  float  NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	const  float  ClearCoat = GBuffer.CustomData.x;
	const  float  ClearCoatRoughness = max(GBuffer.CustomData.y, 0.02f);
	const  float  Film = 1 * ClearCoat;
	const  float  MetalSpec = 0.9;

	FDirectLighting Lighting = {
		float3(0.0, 0.0, 0.0),
		float3(0.0, 0.0, 0.0),
		float3(0.0, 0.0, 0.0)
	};

	BxDFContext Context;
	float3  Nspec = N;

	if ( 0 )
	{
		Nspec = GBuffer.WorldNormal;
	}




	bool bHasAnisotropy = false;


	float3  X = 0;
	float3  Y = 0;






	Init(Context, Nspec, V, L);



	float SphereSinAlpha = AreaLight.SphereSinAlpha;
	float RoughnessCompensation = 1 - Pow2(GBuffer.Roughness);
	float  Alpha = ClearCoatRoughness * ClearCoatRoughness;
	RoughnessCompensation = RoughnessCompensation > 0.0 ? (1 - Alpha) / RoughnessCompensation : 0.0;
	AreaLight.SphereSinAlpha = saturate(AreaLight.SphereSinAlpha * RoughnessCompensation);

	SphereMaxNoH(Context, AreaLight.SphereSinAlpha,  0  == 0);
	Context.NoV = saturate(abs(Context.NoV) + 1e-5);
	const bool bIsRect = IsRectLight(AreaLight);
	Context.VoH = bIsRect ? Context.NoV : Context.VoH;


	float F0 = 0.04;
	float Fc = Pow5(1 - Context.VoH);
	float F = Fc + (1 - Fc) * F0;

	FBxDFEnergyTermsRGB  EnergyTermsCoat =  ComputeGGXSpecEnergyTermsRGB (ClearCoatRoughness, Context.NoV, F0);

	if (bIsRect)
	{
		Lighting.Specular = ClearCoat * RectGGXApproxLTC(ClearCoatRoughness, F0, Nspec, V, AreaLight.Rect, AreaLight.Texture);
	}
	else
	{

		float a2 = Pow2(Alpha);
		float ClearCoatEnergy = EnergyNormalization(a2, Context.VoH, AreaLight);
		float  Vis = Vis_SmithJointApprox(a2, Context.NoV, NoL);




		float D = D_GGX(a2, Context.NoH) * ClearCoatEnergy;

		float  Fr1 = (D * Vis) * F;
		Lighting.Specular = ClearCoat * AreaLight.FalloffColor * (Falloff * NoL * Fr1);
	}
	Lighting.Specular *= ComputeEnergyConservation(EnergyTermsCoat);



	AreaLight.SphereSinAlpha = SphereSinAlpha;
	Alpha = Pow2(GBuffer.Roughness);







	float  FresnelCoeff = 1.0 - F;

	FresnelCoeff *= FresnelCoeff;





	if ( 0 )
	{
		BxDFContext TempContext;

		[branch]
		if (bHasAnisotropy)
		{
			Init(TempContext, N, X, Y, V, L);
		}
		else
		{
			Init(TempContext, Nspec, V, L);
		}


		float3 H = normalize(V + L);
		Context.NoH = saturate(dot(N, H));
		Context.NoV = saturate(dot(N, V));
		Context.NoL = saturate(dot(N, L));
		Context.VoL = saturate(dot(V, L));
		Context.VoH = saturate(dot(V, H));

		Context.XoV = TempContext.XoV;
		Context.XoL = TempContext.XoL;
		Context.XoH = TempContext.XoH;
		Context.YoV = TempContext.YoV;
		Context.YoL = TempContext.YoL;
		Context.YoH = TempContext.YoH;

		if (!bHasAnisotropy)
		{
			bool bNewtonIteration = true;
			SphereMaxNoH(Context, AreaLight.SphereSinAlpha, bNewtonIteration);
		}

		Context.NoV = saturate(abs(Context.NoV) + 1e-5);
	}










	if (bHasAnisotropy)
	{

		X = GBuffer.WorldTangent;
		Y = normalize(cross(N, X));
		Init(Context, Nspec, X, Y, V, L);
	}
	BxDFContext BottomContext = RefractClearCoatContext(Context);
	BottomContext.VoH = bIsRect ? BottomContext.NoV : BottomContext.VoH;

	FBxDFEnergyTermsRGB  EnergyTermsBottom =  ComputeGGXSpecEnergyTermsRGB (GBuffer.Roughness, BottomContext.NoV, GBuffer.SpecularColor);


	float3 Transmission = SimpleClearCoatTransmittance(BottomContext.NoL, BottomContext.NoV, GBuffer.Metallic, GBuffer.BaseColor);


	float3  DefaultDiffuse = (Falloff * NoL) * AreaLight.FalloffColor * Diffuse_Lambert(GBuffer.DiffuseColor) * ComputeEnergyPreservation(EnergyTermsBottom);
	float3  RefractedDiffuse = FresnelCoeff * Transmission * DefaultDiffuse;
	Lighting.Diffuse = lerp(DefaultDiffuse, RefractedDiffuse, ClearCoat);

	if (!bHasAnisotropy && bIsRect)
	{

		float3 DefaultSpecular = RectGGXApproxLTC(GBuffer.Roughness, GBuffer.SpecularColor, N, V, AreaLight.Rect, AreaLight.Texture);
		float3 RefractedSpecular = FresnelCoeff * Transmission * DefaultSpecular;
		Lighting.Specular += lerp(DefaultSpecular, RefractedSpecular, ClearCoat);
	}
	else
	{
		float a2 = Pow4(GBuffer.Roughness);
		float  D2 = 0;
		float  Vis2 = 0;

		[branch]
		if (bHasAnisotropy)
		{
			float ax = 0;
			float ay = 0;
			GetAnisotropicRoughness(Alpha, GBuffer.Anisotropy, ax, ay);

			D2 = D_GGXaniso(ax, ay, Context.NoH, Context.XoH, Context.YoH);
			Vis2 = Vis_SmithJointAniso(ax, ay, BottomContext.NoV, BottomContext.NoL, BottomContext.XoV, BottomContext.XoL, BottomContext.YoV, BottomContext.YoL);
		}
		else
		{

			Vis2 = Vis_SmithJointApprox(a2, BottomContext.NoV, NoL);




			D2 = D_GGX(a2, BottomContext.NoH);

		}
		float3  F_Bot = F_Schlick(GBuffer.SpecularColor, BottomContext.VoH);
		float3  F_DefaultLit = F_Schlick(GBuffer.SpecularColor, Context.VoH);

		float Energy = 0;

		[branch]
		if (bHasAnisotropy)
		{
			FAreaLight Punctual = AreaLight;
			Punctual.SphereSinAlpha = 0;
			Punctual.SphereSinAlphaSoft = 0;
			Punctual.LineCosSubtended = 1;
			Punctual.Rect = (FRect)0;
			Punctual.IsRectAndDiffuseMicroReflWeight = 0;

			Energy = EnergyNormalization(a2, Context.VoH, Punctual);
		}
		else
		{
			Energy = EnergyNormalization(a2, Context.VoH, AreaLight);
		}


		float3 CommonSpecular = (Energy * Falloff * NoL * D2 * Vis2) * AreaLight.FalloffColor;
		float3 DefaultSpecular = F_DefaultLit;
		float3 RefractedSpecular = FresnelCoeff * Transmission * F_Bot;
		Lighting.Specular += CommonSpecular * lerp(DefaultSpecular, RefractedSpecular, ClearCoat);
	}

	return Lighting;
}


float ApproximateHG(float cosJ, float g)
{
	float g2 = g * g;
	float gcos2 = 1.0f - (g * cosJ);
	gcos2 *= gcos2;

	const float ISO_PHASE_FUNC_Normalized = 0.5;

	return (ISO_PHASE_FUNC_Normalized * (1.0f - g2) / max( 1e-5, gcos2));
}

void GetProfileDualSpecular(uint SubsurfaceProfileInt,  float  Roughness,  float  Opacity, out  float  LobeRoughness0, out  float  LobeRoughness1, out  float  LobeMix)
{

	GetSubsurfaceProfileDualSpecular(SubsurfaceProfileInt, Roughness, Opacity, LobeRoughness0, LobeRoughness1, LobeMix);
#line 656 "/Engine/Private/ShadingModels.ush"
}

FDirectLighting SubsurfaceProfileBxDF( FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float Falloff,  float  NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	BxDFContext Context;



	Init( Context, N, V, L );

	SphereMaxNoH( Context, AreaLight.SphereSinAlpha, true );
	Context.NoV = saturate( abs( Context.NoV ) + 1e-5 );

	uint SubsurfaceProfileId = ExtractSubsurfaceProfileInt(GBuffer);
	float  Opacity = GBuffer.CustomData.a;
	float  Roughness = GBuffer.Roughness;

	float  Lobe0Roughness = 0;
	float  Lobe1Roughness = 0;
	float  LobeMix = 0;

	GetProfileDualSpecular(SubsurfaceProfileId, Roughness, Opacity, Lobe0Roughness, Lobe1Roughness, LobeMix);
	float  AverageRoughness = lerp(Lobe0Roughness, Lobe1Roughness, LobeMix);


	const  FBxDFEnergyTermsRGB  EnergyTerms =  ComputeGGXSpecEnergyTermsRGB (AverageRoughness, Context.NoV, GBuffer.SpecularColor);

	FDirectLighting Lighting;
#line 697 "/Engine/Private/ShadingModels.ush"
	Lighting.Diffuse = AreaLight.FalloffColor * (Falloff * NoL) * Diffuse_Burley( GBuffer.DiffuseColor, GBuffer.Roughness, Context.NoV, NoL, Context.VoH );


	if (IsRectLight(AreaLight))
	{
		float3 Lobe0Specular = RectGGXApproxLTC(Lobe0Roughness, GBuffer.SpecularColor, N, V, AreaLight.Rect, AreaLight.Texture);
		float3 Lobe1Specular = RectGGXApproxLTC(Lobe1Roughness, GBuffer.SpecularColor, N, V, AreaLight.Rect, AreaLight.Texture);
		Lighting.Specular = lerp(Lobe0Specular, Lobe1Specular, LobeMix);
	}
	else
	{
		Lighting.Specular = AreaLight.FalloffColor * (Falloff * NoL) * DualSpecularGGX(AverageRoughness, Lobe0Roughness, Lobe1Roughness, LobeMix, GBuffer.SpecularColor, Context, NoL, AreaLight);
	}

	Lighting.Diffuse *= ComputeEnergyPreservation(EnergyTerms);
	Lighting.Specular *= ComputeEnergyConservation(EnergyTerms);
#line 730 "/Engine/Private/ShadingModels.ush"
	Lighting.Transmission = 0;



	return Lighting;
}

FDirectLighting ClothBxDF( FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float Falloff,  float  NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	const float3 FuzzColor = ExtractSubsurfaceColor(GBuffer);
	const float Cloth = saturate(GBuffer.CustomData.a);

	BxDFContext Context;



	Init( Context, N, V, L );

	SphereMaxNoH( Context, AreaLight.SphereSinAlpha, true );
	Context.NoV = saturate( abs( Context.NoV ) + 1e-5 );

	float3 Spec1;
	if(IsRectLight(AreaLight))
		Spec1 = RectGGXApproxLTC( GBuffer.Roughness, GBuffer.SpecularColor, N, V, AreaLight.Rect, AreaLight.Texture );
	else
		Spec1 = AreaLight.FalloffColor * (Falloff * NoL) * SpecularGGX( GBuffer.Roughness, GBuffer.SpecularColor, Context, NoL, AreaLight );

	const  FBxDFEnergyTermsRGB  EnergyTerms1 =  ComputeGGXSpecEnergyTermsRGB (GBuffer.Roughness, Context.NoV, GBuffer.SpecularColor);
	Spec1 *= ComputeEnergyConservation(EnergyTerms1);


	float D2 = D_InvGGX( Pow4( GBuffer.Roughness ), Context.NoH );
	float Vis2 = Vis_Cloth( Context.NoV, NoL );
#line 766 "/Engine/Private/ShadingModels.ush"
	float3 F2 = F_Schlick( FuzzColor, Context.VoH );
	float3 Spec2 = AreaLight.FalloffColor * (Falloff * NoL) * (D2 * Vis2) * F2;

	const  FBxDFEnergyTermsRGB  EnergyTerms2 =  ComputeClothEnergyTermsRGB (GBuffer.Roughness, Context.NoV, FuzzColor);
	Spec2 *= ComputeEnergyConservation(EnergyTerms2);

	FDirectLighting Lighting;
	Lighting.Diffuse = AreaLight.FalloffColor * (Falloff * NoL) * Diffuse_Lambert( GBuffer.DiffuseColor );
	Lighting.Specular = lerp( Spec1, Spec2, Cloth );
	Lighting.Transmission = 0;

	Lighting.Diffuse *= lerp(ComputeEnergyPreservation(EnergyTerms1), ComputeEnergyPreservation(EnergyTerms2), Cloth);

	return Lighting;
}

FDirectLighting SubsurfaceBxDF(FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float Falloff,  float  NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	FDirectLighting Lighting = DefaultLitBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow);

	float3  SubsurfaceColor = ExtractSubsurfaceColor(GBuffer);
	float  Opacity = GBuffer.CustomData.a;



	float  InScatter = pow(saturate(dot(L, -V)), 12) * lerp(3, .1f, Opacity);







	const  float  WrappedDiffuse = pow(saturate(dot(N, L) * (1.f / 1.5f) + (0.5f / 1.5f)), 1.5f) * (2.5f / 1.5f);
	const  float  NormalContribution = lerp(1.f, WrappedDiffuse, Opacity);
	const  float  BackScatter = GBuffer.GBufferAO * NormalContribution / (PI * 2);






	const  float3  ExtinctionCoefficients = TransmittanceToExtinction(SubsurfaceColor, View.SubSurfaceColorAsTransmittanceAtDistanceInMeters);
	const  float3  RawTransmittedColor = ExtinctionToTransmittance(ExtinctionCoefficients, 1.0f );
	const  float3  TransmittedColor = HSV_2_LinearRGB( float3 (LinearRGB_2_HSV(RawTransmittedColor).xy, LinearRGB_2_HSV(SubsurfaceColor).z));


	Lighting.Transmission = AreaLight.FalloffColor * (Falloff * lerp(BackScatter, 1, InScatter)) * lerp(TransmittedColor, SubsurfaceColor, Shadow.TransmissionThickness);

	return Lighting;
}

FDirectLighting TwoSidedBxDF( FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float Falloff,  float  NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	FDirectLighting Lighting = DefaultLitBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );

	float3  SubsurfaceColor = ExtractSubsurfaceColor(GBuffer);


	float  Wrap = 0.5;
	float  WrapNoL = saturate( ( -dot(N, L) + Wrap ) / Square( 1 + Wrap ) );


	float  VoL = dot(V, L);



	float Scatter = D_GGX( 0.6*0.6, saturate( -VoL ) );


	Lighting.Transmission = AreaLight.FalloffColor * (Falloff * WrapNoL * Scatter) * SubsurfaceColor;

	return Lighting;
}

FDirectLighting EyeBxDF( FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float Falloff,  float  NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{









	const float3 IrisNormal = OctahedronToUnitVector( GBuffer.CustomData.yz * 2 - 1 );
	const float IrisDistance = GBuffer.StoredMetallic;
	const float IrisMask = 1.0f - GBuffer.CustomData.w;





	const float3 CausticNormal = normalize(lerp(IrisNormal, -N, IrisMask*IrisDistance));


	BxDFContext Context;



	Init( Context, N, V, L );

	SphereMaxNoH( Context, AreaLight.SphereSinAlpha, false );
	Context.NoV = saturate( abs( Context.NoV ) + 1e-5 );
	const bool bIsRect = IsRectLight(AreaLight);
	Context.VoH = bIsRect ? Context.NoV : Context.VoH;


	float F0 = GBuffer.Specular * 0.08;
	float Fc = Pow5( 1 - Context.VoH );
	float F = Fc + (1 - Fc) * F0;

	const  FBxDFEnergyTermsRGB  EnergyTerms =  ComputeGGXSpecEnergyTermsRGB (GBuffer.Roughness, Context.NoV, F0);

	FDirectLighting Lighting;

	if( bIsRect )
	{
		Lighting.Specular = RectGGXApproxLTC( GBuffer.Roughness, F0, N, V, AreaLight.Rect, AreaLight.Texture );
	}
	else
	{
		float a2 = Pow4( GBuffer.Roughness );
		float Energy = EnergyNormalization( a2, Context.VoH, AreaLight );

		float Vis = Vis_SmithJointApprox(a2, Context.NoV, NoL);




		float D = D_GGX(a2, Context.NoH) * Energy;

		Lighting.Specular = AreaLight.FalloffColor * (Falloff * NoL) * D * Vis * F;
	}

	float IrisNoL = saturate( dot( IrisNormal, L ) );
	float Power = lerp( 12, 1, IrisNoL );
	float Caustic = 0.8 + 0.2 * ( Power + 1 ) * pow( saturate( dot( CausticNormal, L ) ), Power );
	float Iris = IrisNoL * Caustic;
	float Sclera = NoL;

	Lighting.Specular *= ComputeEnergyConservation(EnergyTerms);





	const float EnergyPreservation = 1.0f - F;


	Lighting.Diffuse = 0;
	Lighting.Transmission = AreaLight.FalloffColor * ( Falloff * lerp( Sclera, Iris, IrisMask ) * EnergyPreservation ) * Diffuse_Lambert( GBuffer.DiffuseColor );
#line 939 "/Engine/Private/ShadingModels.ush"
	return Lighting;
}

FDirectLighting PreintegratedSkinBxDF( FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float Falloff,  float  NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	FDirectLighting Lighting = DefaultLitBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );

	float3  SubsurfaceColor = ExtractSubsurfaceColor(GBuffer);
	float  Opacity = GBuffer.CustomData.a;

	float3  PreintegratedBRDF = Texture2DSampleLevel(View.PreIntegratedBRDF, View.PreIntegratedBRDFSampler, float2(saturate(dot(N, L) * .5 + .5), 1 - Opacity), 0).rgb;
	Lighting.Transmission = AreaLight.FalloffColor * Falloff * PreintegratedBRDF * SubsurfaceColor;

	return Lighting;
}

FDirectLighting IntegrateBxDF( FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float Falloff,  float  NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	switch( GBuffer.ShadingModelID )
	{
		case  1 :
		case  10 :
		case  11 :
			return DefaultLitBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case  2 :
			return SubsurfaceBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case  3 :
			return PreintegratedSkinBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case  4 :
			return ClearCoatBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case  5 :
			return SubsurfaceProfileBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case  6 :
			return TwoSidedBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case  7 :
			return HairBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case  8 :
			return ClothBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case  9 :
			return EyeBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		default:
			return (FDirectLighting)0;
	}
}

FDirectLighting EvaluateBxDF( FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float NoL, FShadowTerms Shadow )
{
	FAreaLight AreaLight;
	AreaLight.SphereSinAlpha = 0;
	AreaLight.SphereSinAlphaSoft = 0;
	AreaLight.LineCosSubtended = 1;
	AreaLight.FalloffColor = 1;
	AreaLight.Rect = (FRect)0;
	AreaLight.IsRectAndDiffuseMicroReflWeight = 0;
	AreaLight.Texture = InitRectTexture();

	return IntegrateBxDF( GBuffer, N, V, L, 1, NoL, AreaLight, Shadow );
}
#line 9 "/Engine/Private/CapsuleLightIntegrate.ush"
#line 10 "/Engine/Private/CapsuleLightIntegrate.ush"
#line 1 "CapsuleLightSampling.ush"
#line 7 "/Engine/Private/CapsuleLightSampling.ush"
float SqrtOneMinusX(float x)
{
	return x < 0.01 ? 1 - x * (0.5 + x * 0.125) : sqrt(1 - x);
}



struct FCapsuleSphericalBounds
{
	FSphericalRect SphericalRect;
	float3 ConeAxis;
	float ConeSinThetaMax2;
	float ConeSolidAngle;
};


float GetCapsuleBoundsSolidAngle(FCapsuleSphericalBounds Bounds)
{
	return min(Bounds.SphericalRect.SolidAngle, Bounds.ConeSolidAngle);
}


float4 SampleCapsuleBounds(FCapsuleSphericalBounds Bounds, float2 E)
{
	if (Bounds.ConeSolidAngle < Bounds.SphericalRect.SolidAngle)
	{
		return float4(TangentToWorld(UniformSampleConeRobust(E, Bounds.ConeSinThetaMax2).xyz, Bounds.ConeAxis), Bounds.ConeSolidAngle);
	}
	else
	{
		return float4(normalize(UniformSampleSphericalRect(E, Bounds.SphericalRect)), Bounds.SphericalRect.SolidAngle);
	}
}


FCapsuleSphericalBounds CapsuleGetSphericalBounds(float3 Origin, float3 Axis, float Radius, float Length)
{
	float h = dot(Axis, Origin);
	float3 ClosestPointOnAxis = Origin - Axis * h;

	float DistanceToAxisSqr = dot(ClosestPointOnAxis, ClosestPointOnAxis);
	float RadiusSqr = Pow2(Radius);

	if (DistanceToAxisSqr <= RadiusSqr)
	{

		float3 CapCenter = Origin - Axis * Length * 0.5 * sign(h);
		float LightDistanceSquared = dot(CapCenter, CapCenter);
		float SinThetaMax2 = saturate(RadiusSqr / LightDistanceSquared);

		FCapsuleSphericalBounds Result;
		Result.SphericalRect = (FSphericalRect)0;
		Result.SphericalRect.SolidAngle =  (asfloat(0x7F800000)) ;
		Result.ConeAxis = normalize(CapCenter);
		Result.ConeSinThetaMax2 = SinThetaMax2;
		Result.ConeSolidAngle = UniformConeSolidAngle(SinThetaMax2);
		return Result;
	}


	FRect Rect;
	Rect.Origin = Origin;
	Rect.Axis[1] = Axis;
	Rect.Axis[2] = normalize(-ClosestPointOnAxis);
	Rect.Axis[0] = cross(Rect.Axis[1], Rect.Axis[2]);

	float SinCylinderAngle = Radius * rsqrt(DistanceToAxisSqr);

	float RectRadius = Radius * rsqrt(1 - Pow2(SinCylinderAngle));

	float Extension[2];
	for (int i = 0; i < 2; i++)
	{
		float hi = Length * (i > 0 ? 0.5 : -0.5);
		float3 PointPos = Origin + Axis * hi;

		float InverseDist = rsqrt(dot(PointPos, PointPos));

		float SinSphereAngle = saturate(Radius * InverseDist);
		float CosSphereAngle = SqrtOneMinusX(Pow2(SinSphereAngle));

		float CosAxisAngle = -dot(Axis, PointPos) * InverseDist;
		CosAxisAngle = sign(CosAxisAngle * hi) * saturate(abs(CosAxisAngle));
		float SinAxisAngle = SqrtOneMinusX(Pow2(CosAxisAngle));

		float CosExtension = SinAxisAngle * CosSphereAngle + CosAxisAngle * SinSphereAngle;
		Extension[i] = Radius / CosExtension;
	}

	float Translate = 0.5 * (Extension[1] - Extension[0]);
	float Extend = 0.5 * (Extension[0] + Extension[1]);

	Rect.Origin += Translate * Rect.Axis[1];
	Rect.Extent = float2(RectRadius, 0.5 * Length + Extend);


	float3 R0 = Rect.Origin - Rect.Axis[1] * Rect.Extent.y;
	float3 R1 = Rect.Origin + Rect.Axis[1] * Rect.Extent.y;
	float InvDistR0 = rsqrt(dot(R0, R0));
	float InvDistR1 = rsqrt(dot(R1, R1));

	FCapsuleSphericalBounds Result;
	Result.SphericalRect = BuildSphericalRect(Rect);
	Result.ConeAxis = normalize(lerp(R0, R1, saturate(InvDistR1 / (InvDistR0 + InvDistR1))));
	Result.ConeSinThetaMax2 = saturate(0.5 - 0.5 * dot(R0, R1) * InvDistR0 * InvDistR1);
	Result.ConeSolidAngle = UniformConeSolidAngle(Result.ConeSinThetaMax2);
	return Result;
}




float CapsuleIntersect(float3 Rd, float3 Center, float3 Axis, float Radius2, float Length)
{
	float3 ba = Axis;
	float3 oa = -Center;
	float bard = dot(ba, Rd);
	float baoa = dot(ba, oa);
	float rdoa = dot(Rd, oa);
	float oaoa = dot(oa, oa);
	float a = 1 - bard * bard;
	float b = rdoa - baoa * bard;
	float c = oaoa - baoa * baoa - Radius2;
	float h = b * b - a * c;
	if (h >= 0.0)
	{
		float t = (-b - sqrt(h)) / a;
		float y = baoa + t * bard;

		if (abs(y) < 0.5 * Length)
		{
			return t;
		}


		float3 oc = oa - (sign(y) * 0.5 * Length) * ba;
		b = dot(Rd, oc);
		h = Radius2 - length2(oc - b * Rd);
		if (h > 0.0)
		{
			return -b - sqrt(h);
		}
	}
	return -1.0;
}



float CapsuleTest(float3 Rd, float3 Center, float3 Axis, float Radius2, float Length)
{

	float B = dot(Rd, Axis);
	float t = clamp(dot(Center, B * Rd - Axis) / (1 - B * B), -0.5 * Length, 0.5 * Length);
	float3 ToSphere = Center + t * Axis;
	float3 C = cross(Rd, ToSphere);
	return dot(C, C) <= Radius2 ? length(ToSphere) : -1.0;
}
#line 11 "/Engine/Private/CapsuleLightIntegrate.ush"
#line 1 "SobolRandom.ush"
#line 24 "/Engine/Private/SobolRandom.ush"
uint2 SobolPixel(uint2 Pixel)
{

	int3 SobolLo = int3(Pixel & 0xfu, 0);
	int3 SobolHi = int3((Pixel >> 4u) & 0xfu, 0) + int3(16, 0, 0);
	uint Packed = View.SobolSamplingTexture.Load(SobolLo) ^ View.SobolSamplingTexture.Load(SobolHi);
	return uint2(Packed, Packed << 8u) & 0xff00u;
}






uint2 SobolIndex(uint2 Base, int Index, int Bits = 10)
{
	uint2 SobolNumbers[10] = {
		uint2(0x8680u, 0x4c80u), uint2(0xf240u, 0x9240u), uint2(0x8220u, 0x0e20u), uint2(0x4110u, 0x1610u), uint2(0xa608u, 0x7608u),
		uint2(0x8a02u, 0x280au), uint2(0xe204u, 0x9e04u), uint2(0xa400u, 0x4682u), uint2(0xe300u, 0xa74du), uint2(0xb700u, 0x9817u),
	};

	uint2 Result = Base;
	[unroll]  for (int b = 0; b < 10 && b < Bits; ++b)
	{
		Result ^= (Index & (1u << b)) ? SobolNumbers[b] : 0;
	}
	return Result;
}


uint2 ComputePixelUniqueSobolRandSample(uint2 PixelCoord)
{
	const uint TemporalBits = 10;
	uint FrameIndexMod1024 = ReverseBitsN(GetPowerOfTwoModulatedFrameIndex(1u << TemporalBits), TemporalBits);

	uint2 SobolBase = SobolPixel(PixelCoord);
	return SobolIndex(SobolBase, FrameIndexMod1024, TemporalBits);
}


float2 SobolIndexToUniformUnitSquare(uint2 SobolRand)
{
	return float2(SobolRand) * rcp(65536.0) + rcp(65536.0 * 2.0);
}
#line 12 "/Engine/Private/CapsuleLightIntegrate.ush"


float IntegrateLight( FCapsuleLight Capsule, bool bInverseSquared )
{
	float Falloff;

	[branch]
	if( Capsule.Length > 0 )
	{
		float NoL;
		float LineCosSubtended = 1;
		LineIrradiance( 0, Capsule.LightPos[0], Capsule.LightPos[1], Capsule.DistBiasSqr, LineCosSubtended, Falloff, NoL );
	}
	else
	{
		float3 ToLight = Capsule.LightPos[0];
		float DistSqr = dot( ToLight, ToLight );
		Falloff = rcp( DistSqr + Capsule.DistBiasSqr );
	}

	Falloff = bInverseSquared ? Falloff : 1;

	return Falloff;
}

FAreaLightIntegrateContext CreateCapsuleIntegrateContext(float Roughness,  float3  N,  float3  V, FCapsuleLight Capsule, bool bInverseSquared )
{
	FAreaLightIntegrateContext Out = InitAreaLightIntegrateContext();

	float NoL;
	float Falloff;
	float LineCosSubtended = 1;







	[branch]
	if( Capsule.Length > 0 )
	{
		LineIrradiance( N, Capsule.LightPos[0], Capsule.LightPos[1], Capsule.DistBiasSqr, LineCosSubtended, Falloff, NoL );
	}
	else
	{
		float DistSqr = dot( Capsule.LightPos[0], Capsule.LightPos[0] );
		Falloff = rcp( DistSqr + Capsule.DistBiasSqr );

		float3 L = Capsule.LightPos[0] * rsqrt( DistSqr );
		NoL = dot( N, L );
	}

	if( Capsule.Radius > 0 )
	{

		float SinAlphaSqr = saturate( Pow2( Capsule.Radius ) * Falloff );
		NoL = SphereHorizonCosWrap( NoL, SinAlphaSqr );
	}

	NoL = saturate( NoL );
	Falloff = bInverseSquared ? Falloff : 1;

	float3 ToLight = Capsule.LightPos[0];
	if( Capsule.Length > 0 )
	{
		float3 R = reflect( -V, N );
#line 88 "/Engine/Private/CapsuleLightIntegrate.ush"
		ToLight = ClosestPointLineToRay( Capsule.LightPos[0], Capsule.LightPos[1], Capsule.Length, R );
	}

	float DistSqr = dot( ToLight, ToLight );
	float InvDist = rsqrt( DistSqr );
	float3 L = ToLight * InvDist;

	Roughness = max( Roughness, View.MinRoughness );
	float a = Pow2( Roughness );



	const float SizeFadesOutDiffuseMicroRefl = 20.0;

	Out.AreaLight.SphereSinAlpha = saturate( Capsule.Radius * InvDist * (1 - a) );
	Out.AreaLight.SphereSinAlphaSoft = saturate( Capsule.SoftRadius * InvDist );
	Out.AreaLight.LineCosSubtended = LineCosSubtended;
	Out.AreaLight.FalloffColor = 1;
	Out.AreaLight.Rect = (FRect)0;
	Out.AreaLight.Texture = InitRectTexture();
	Out.AreaLight.IsRectAndDiffuseMicroReflWeight = 0;
	SetIsRectLight(Out.AreaLight, false);
	SetAreaLightDiffuseMicroReflWeight(Out.AreaLight, saturate(1.0f - max(Capsule.Length, Capsule.Radius) / SizeFadesOutDiffuseMicroRefl));
	Out.NoL = NoL;
	Out.Falloff = Falloff;
	Out.L = L;
	return Out;
}


FDirectLighting IntegrateBxDF( FGBufferData GBuffer,  float3  N,  float3  V, FCapsuleLight Capsule, FShadowTerms Shadow, bool bInverseSquared )
{
	GBuffer.Roughness = max( GBuffer.Roughness, View.MinRoughness );
	FAreaLightIntegrateContext Context = CreateCapsuleIntegrateContext(GBuffer.Roughness, N, V, Capsule, bInverseSquared);
	return IntegrateBxDF( GBuffer, N, V, Context.L, Context.Falloff, Context.NoL, Context.AreaLight, Shadow );
}

FDirectLighting IntegrateBxDF( FGBufferData GBuffer,  float3  N,  float3  V, FCapsuleLight Capsule, FShadowTerms Shadow, uint2 SVPos )
{
	FDirectLighting Lighting = (FDirectLighting)0;

	Capsule.Radius = max( 1, Capsule.Radius );

	const float SphereArea = (4*PI) * Pow2( Capsule.Radius );
	const float CylinderArea = (2*PI) * Capsule.Radius * Capsule.Length;
	const float SurfaceArea = SphereArea + CylinderArea;
	const float SurfaceColor = 4.0 / SurfaceArea;

	float3 ToLight = 0.5 * ( Capsule.LightPos[0] + Capsule.LightPos[1] );
	float3 CapsuleAxis = normalize( Capsule.LightPos[1] - Capsule.LightPos[0] );

	float DistanceSqr = dot( ToLight, ToLight );
	float3 ConeAxis = ToLight * rsqrt( DistanceSqr );
	float SineConeSqr = saturate(Pow2(Capsule.Radius) / DistanceSqr);

	FCapsuleSphericalBounds CapsuleBounds = CapsuleGetSphericalBounds(ToLight, CapsuleAxis, Capsule.Radius, Capsule.Length);

	const uint NumSets = 3;
	const uint NumSamples[ NumSets ] =
	{
		0,
		16,
		16,
	};

	uint2 SobolBase = SobolPixel( SVPos );
	uint2 SobolFrame = SobolIndex( SobolBase, View.StateFrameIndexMod8, 3 );

	[unroll]
	for( uint Set = 0; Set < NumSets; Set++ )
	{
		[loop]
		for( uint i = 0; i < NumSamples[ Set ]; i++ )
		{
			uint2 Random = Rand3DPCG16( uint3( SVPos.xy, View.Random ^ Set ) ).xy;

			float2 E = float2( SobolIndex( SobolFrame, i << 3 ) ) / 0x10000;



			float3 L, H;
			if( Set == 0 )
			{
				L = TangentToWorld( CosineSampleHemisphere( E ).xyz, N );
				H = normalize(V + L);
			}
			else if( Set == 1 )
			{
				H = TangentToWorld( ImportanceSampleGGX( E, Pow4(GBuffer.Roughness) ).xyz, N );
				L = 2 * dot( V, H ) * H - V;
			}
			else
			{
#line 229 "/Engine/Private/CapsuleLightIntegrate.ush"
				if( Capsule.Length > 0 )
				{
					float3 ToArea = SampleCapsuleBounds(CapsuleBounds, E).xyz;
					L = normalize( ToArea );
					H = normalize( V + L );
				}
				else
				{
					L = TangentToWorld( UniformSampleConeRobust( E, SineConeSqr).xyz, ConeAxis );
					H = normalize(V + L);
				}
			}

			float NoL = saturate( dot(N, L) );
			float NoH = saturate( dot(N, H) );
			float VoH = saturate( dot(V, H) );

			if( NoL > 0 && VoH > 0 )
			{
				{
					if (CapsuleTest(L, ToLight, CapsuleAxis, Pow2(Capsule.Radius), Capsule.Length) > 0)
					{

						continue;
					}
				}

				float PDF[] =
				{
					NoL / PI,
					D_GGX(Pow4(GBuffer.Roughness), NoH) * NoH / (4 * VoH),
					1.0 / GetCapsuleBoundsSolidAngle(CapsuleBounds)
				};

				if( Capsule.Length == 0 )
				{
					PDF[2] = 1.0 / UniformConeSolidAngle(SineConeSqr);
				}


				float InvWeight = 0;
				[unroll]  for( uint j = 0; j < NumSets; j++ )
				{
					InvWeight += Square( PDF[j] * NumSamples[j] );
				}
				float Weight = rcp( InvWeight ) * PDF[Set] * NumSamples[Set];

				FDirectLighting LightingSample = EvaluateBxDF( GBuffer, N, V, L, NoL, Shadow );

				Lighting.Diffuse += SurfaceColor * Weight * LightingSample.Diffuse;
				Lighting.Specular += SurfaceColor * Weight * LightingSample.Specular;
				Lighting.Transmission += SurfaceColor * Weight * LightingSample.Transmission;
			}
		}
	}

	return Lighting;
}
#line 13 "/Engine/Private/DeferredLightingCommon.ush"
#line 1 "RectLightIntegrate.ush"










float3 ClampToRect( float3 L, FRect Rect )
{





	float3 PointOnPlane = L * ( dot( Rect.Axis[2], Rect.Origin ) / dot( Rect.Axis[2], L ) );


	float2 PointInRect;
	PointInRect.x = dot( Rect.Axis[0], PointOnPlane - Rect.Origin );
	PointInRect.y = dot( Rect.Axis[1], PointOnPlane - Rect.Origin );


	PointInRect = clamp( PointInRect, -Rect.Extent, Rect.Extent );

	float3 ToRect = Rect.Origin;
	ToRect += PointInRect.x * Rect.Axis[0];
	ToRect += PointInRect.y * Rect.Axis[1];

	return normalize( ToRect );
}

bool RayHitRect( float3 L, FRect Rect )
{

	float t = dot( Rect.Axis[2], Rect.Origin ) / dot( Rect.Axis[2], L );
	float3 PointOnPlane = L * t;

	bool InExtentX = abs( dot( Rect.Axis[0], PointOnPlane - Rect.Origin ) ) <= Rect.Extent.x;
	bool InExtentY = abs( dot( Rect.Axis[1], PointOnPlane - Rect.Origin ) ) <= Rect.Extent.y;

	return t >= 0 && InExtentX && InExtentY;
}

float IntegrateLight( FRect Rect )
{

	if (Rect.Extent.x == 0 || Rect.Extent.y == 0) return 0;

	float NoL;
	float Falloff;




	float3 L = RectIrradianceLambert( 0, Rect, Falloff, NoL );
#line 67 "/Engine/Private/RectLightIntegrate.ush"
	return Falloff;
}

FAreaLightIntegrateContext CreateRectIntegrateContext( float Roughness,  float3  N,  float3  V, FRect Rect, FRectTexture SourceTexture )
{
	float NoL = 0;
	float Falloff = 0;

	FAreaLightIntegrateContext Out = InitAreaLightIntegrateContext();




	float3 L = RectIrradianceLambert( N, Rect, Falloff, NoL );
#line 237 "/Engine/Private/RectLightIntegrate.ush"
	float3 FalloffColor = SampleSourceTexture( L, Rect, SourceTexture );

	Out.AreaLight.SphereSinAlpha = 0;
	Out.AreaLight.SphereSinAlphaSoft = 0;
	Out.AreaLight.LineCosSubtended = 1;
	Out.AreaLight.FalloffColor = FalloffColor;
	Out.AreaLight.Rect = Rect;
	Out.AreaLight.Texture = SourceTexture;
	Out.AreaLight.IsRectAndDiffuseMicroReflWeight = 0;
	SetIsRectLight(Out.AreaLight, true);
	SetAreaLightDiffuseMicroReflWeight(Out.AreaLight, 0.0);
	Out.L = L;
	Out.NoL = NoL;
	Out.Falloff = Falloff;

	return Out;
}

FDirectLighting IntegrateBxDF(FGBufferData GBuffer,  float3  N,  float3  V, FRect Rect, FShadowTerms Shadow, FRectTexture SourceTexture)
{

	FDirectLighting Out = (FDirectLighting)0;
	if (IsRectVisible(Rect))
	{
		FAreaLightIntegrateContext Context = CreateRectIntegrateContext(GBuffer.Roughness, N, V, Rect, SourceTexture);
#line 265 "/Engine/Private/RectLightIntegrate.ush"
		Out = IntegrateBxDF(GBuffer, N, V, Context.L, Context.Falloff, Context.NoL, Context.AreaLight, Shadow);
	}
	return Out;
}

FDirectLighting IntegrateBxDF( FGBufferData GBuffer,  float3  N,  float3  V, FRect Rect, FShadowTerms Shadow, FRectTexture SourceTexture, uint2 SVPos )
{
	FDirectLighting Lighting = (FDirectLighting)0;

	const float SurfaceArea = 4 * Rect.Extent.x * Rect.Extent.y;
	const float SurfaceColor = 2.0 / SurfaceArea;


	if( dot( Rect.Axis[2], Rect.Origin ) < 0 )
		return Lighting;


	if (!IsRectVisible(Rect))
		return Lighting;

	FSphericalRect SphericalRect = BuildSphericalRect( Rect );

	const uint NumSets = 4;
	const uint NumSamples[ NumSets ] =
	{
		0,
		16,
		0,
		16,
	};

	uint2 SobolBase = SobolPixel( SVPos );
	uint2 SobolFrame = SobolIndex( SobolBase, View.StateFrameIndexMod8, 3 );

	[unroll]
	for( uint Set = 0; Set < NumSets; Set++ )
	{
		[loop]
		for( uint i = 0; i < NumSamples[ Set ]; i++ )
		{
			uint2 Random = Rand3DPCG16( uint3( SVPos.xy, View.Random ^ Set ) ).xy;

			float2 E = float2( SobolIndex( SobolFrame, i << 3 ) ) / 0x10000;



			float3 L, H;
			switch( Set )
			{
				case 0:
				{
					L = TangentToWorld( CosineSampleHemisphere( E ).xyz, N );
					H = normalize( V + L );
					break;
				}
				case 1:
				{
					H = TangentToWorld( ImportanceSampleGGX( E, Pow4(GBuffer.Roughness) ).xyz, N );
					L = 2 * dot( V, H ) * H - V;
					break;
				}
				case 2:
				{
					float3 ToArea = Rect.Origin;
					ToArea += (E.x * 2 - 1) * Rect.Axis[0] * Rect.Extent.x;
					ToArea += (E.y * 2 - 1) * Rect.Axis[1] * Rect.Extent.y;
					L = normalize( ToArea );
					H = normalize( V + L );
					break;
				}
				case 3:
				{
					float3 ToArea = UniformSampleSphericalRect( E, SphericalRect );
					L = normalize( ToArea );
					H = normalize( V + L );
					break;
				}
			}

			float NoL = saturate( dot(N, L) );
			float NoH = saturate( dot(N, H) );
			float VoH = saturate( dot(V, H) );

			if( NoL > 0 && VoH > 0 )
			{

				float t = dot( Rect.Axis[2], Rect.Origin ) / dot( Rect.Axis[2], L );
				float3 PointOnPlane = L * t;

				float2 PointInRect;
				PointInRect.x = dot( Rect.Axis[0], PointOnPlane - Rect.Origin );
				PointInRect.y = dot( Rect.Axis[1], PointOnPlane - Rect.Origin );

				float2 RectUV = PointInRect / Rect.Extent * float2( 0.5, -0.5 ) + 0.5;
				float3 LightColor = SampleRectTexture(SourceTexture, RectUV, 0, true);

				if( Set == 0 || Set == 1 )
				{
					bool InExtentX = abs( PointInRect.x ) <= Rect.Extent.x;
					bool InExtentY = abs( PointInRect.y ) <= Rect.Extent.y;

					[branch]
					if( t < 0 || !InExtentX || !InExtentY )
					{

						continue;
					}
				}

				float PDF[] =
				{
					NoL * (1 / PI),
					D_GGX( Pow4(GBuffer.Roughness), NoH ) * NoH / (4 * VoH),
					dot( PointOnPlane, PointOnPlane ) / ( SurfaceArea * abs( dot( L, Rect.Axis[2] ) ) ),
					1.0 / SphericalRect.SolidAngle,
				};


				float InvWeight = 0;
				[unroll]  for( uint j = 0; j < NumSets; j++ )
				{
					InvWeight += Square( PDF[j] * NumSamples[j] );
				}
				float Weight = rcp( InvWeight ) * PDF[Set] * NumSamples[Set];

				FDirectLighting LightingSample = EvaluateBxDF( GBuffer, N, V, L, NoL, Shadow );

				Lighting.Diffuse += ( LightColor * Weight ) * LightingSample.Diffuse;
				Lighting.Specular += ( LightColor * Weight ) * LightingSample.Specular;
				Lighting.Transmission += ( LightColor * Weight ) * LightingSample.Transmission;
			}
		}
	}

	return Lighting;
}
#line 14 "/Engine/Private/DeferredLightingCommon.ush"
#line 1 "Strata/Strata.ush"
#line 15 "/Engine/Private/DeferredLightingCommon.ush"
#line 35 "/Engine/Private/DeferredLightingCommon.ush"
struct FDeferredLightData
{
	float3 TranslatedWorldPosition;
	float  InvRadius;

	float3 Color;
	float  FalloffExponent;
	float3 Direction;
	float3 Tangent;
	float SoftSourceRadius;
	float2  SpotAngles;
	float SourceRadius;
	float SourceLength;
	float  SpecularScale;
	float ContactShadowLength;

	float ContactShadowNonShadowCastingIntensity;
	float2 DistanceFadeMAD;
	float4  ShadowMapChannelMask;

	bool ContactShadowLengthInWS;

	bool bInverseSquared;

	bool bRadialLight;

	bool bSpotLight;
	bool bRectLight;

	uint ShadowedBits;
	float RectLightBarnCosAngle;
	float RectLightBarnLength;

	float2 RectLightAtlasUVOffset;
	float2 RectLightAtlasUVScale;
	float RectLightAtlasMaxLevel;
	FHairTransmittanceData HairTransmittance;
};


struct FSimpleDeferredLightData
{
	float3 TranslatedWorldPosition;
	float InvRadius;
	float3 Color;
	float FalloffExponent;

	bool bInverseSquared;
};



FRectTexture InitRectTexture(FDeferredLightData In)
{
	FRectTexture Output;
	Output.AtlasUVOffset = In.RectLightAtlasUVOffset;
	Output.AtlasUVScale = In.RectLightAtlasUVScale;
	Output.AtlasMaxLevel = In.RectLightAtlasMaxLevel;
	return Output;
}


float DistanceFromCameraFade(float SceneDepth, FDeferredLightData LightData)
{

	float Fade = saturate(SceneDepth * LightData.DistanceFadeMAD.x + LightData.DistanceFadeMAD.y);
	return Fade * Fade;
}
#line 186 "/Engine/Private/DeferredLightingCommon.ush"
void GetShadowTerms(float SceneDepth,  float4  PrecomputedShadowFactors, uint ShadingModelID, float ContactShadowOpacity, FDeferredLightData LightData, float3 TranslatedWorldPosition,  float3  L,  float4  LightAttenuation, float Dither, inout FShadowTerms Shadow)
{
	float ContactShadowLength = 0.0f;
	const float ContactShadowLengthScreenScale = View.ClipToView[1][1] * SceneDepth;

	[branch]
	if (LightData.ShadowedBits)
	{






		float  UsesStaticShadowMap = dot(LightData.ShadowMapChannelMask,  float4 (1, 1, 1, 1));
		float  StaticShadowing = lerp(1, dot(PrecomputedShadowFactors, LightData.ShadowMapChannelMask), UsesStaticShadowMap);
#line 206 "/Engine/Private/DeferredLightingCommon.ush"
		if (LightData.bRadialLight ||  0 )
		{


			Shadow.SurfaceShadow = LightAttenuation.z * StaticShadowing;


			Shadow.TransmissionShadow = LightAttenuation.w * StaticShadowing;

			Shadow.TransmissionThickness = LightAttenuation.w;
		}
		else
		{




			float DynamicShadowFraction = DistanceFromCameraFade(SceneDepth, LightData);

			Shadow.SurfaceShadow = lerp(LightAttenuation.x, StaticShadowing, DynamicShadowFraction);

			Shadow.TransmissionShadow = min(lerp(LightAttenuation.y, StaticShadowing, DynamicShadowFraction), LightAttenuation.w);

			Shadow.SurfaceShadow *= LightAttenuation.z;
			Shadow.TransmissionShadow *= LightAttenuation.z;


			Shadow.TransmissionThickness = min(LightAttenuation.y, LightAttenuation.w);
		}

		[flatten]
		if (LightData.ShadowedBits > 1 && LightData.ContactShadowLength > 0)
		{
			ContactShadowLength = LightData.ContactShadowLength * (LightData.ContactShadowLengthInWS ? 1.0f : ContactShadowLengthScreenScale);
		}
	}
#line 300 "/Engine/Private/DeferredLightingCommon.ush"
	Shadow.HairTransmittance = LightData.HairTransmittance;
	Shadow.HairTransmittance.OpaqueVisibility = Shadow.SurfaceShadow;
}

float GetLocalLightAttenuation(
	float3 TranslatedWorldPosition,
	FDeferredLightData LightData,
	inout float3 ToLight,
	inout float3 L)
{
	ToLight = LightData.TranslatedWorldPosition - TranslatedWorldPosition;

	float DistanceSqr = dot( ToLight, ToLight );
	L = ToLight * rsqrt( DistanceSqr );

	float LightMask;
	if (LightData.bInverseSquared)
	{
		LightMask = Square( saturate( 1 - Square( DistanceSqr * Square(LightData.InvRadius) ) ) );
#line 322 "/Engine/Private/DeferredLightingCommon.ush"
	}
	else
	{
		LightMask = RadialAttenuation(ToLight * LightData.InvRadius, LightData.FalloffExponent);
	}

	if (LightData.bSpotLight)
	{
		LightMask *= SpotAttenuation(L, -LightData.Direction, LightData.SpotAngles);
	}

	if( LightData.bRectLight )
	{

		LightMask = dot( LightData.Direction, L ) < 0 ? 0 : LightMask;
	}

	return LightMask;
}



FRect GetRect(float3 ToLight, FDeferredLightData LightData)
{
	return GetRect(
		ToLight,
		LightData.Direction,
		LightData.Tangent,
		LightData.SourceRadius,
		LightData.SourceLength,
		LightData.RectLightBarnCosAngle,
		LightData.RectLightBarnLength,
		1 );
}

FCapsuleLight GetCapsule( float3 ToLight, FDeferredLightData LightData )
{
	FCapsuleLight Capsule;
	Capsule.Length = LightData.SourceLength;
	Capsule.Radius = LightData.SourceRadius;
	Capsule.SoftRadius = LightData.SoftSourceRadius;
	Capsule.DistBiasSqr = 1;
	Capsule.LightPos[0] = ToLight - 0.5 * Capsule.Length * LightData.Tangent;
	Capsule.LightPos[1] = ToLight + 0.5 * Capsule.Length * LightData.Tangent;
	return Capsule;
}

FLightAccumulator AccumulateDynamicLighting(
	float3 TranslatedWorldPosition,  float3  CameraVector, FGBufferData GBuffer,  float  AmbientOcclusion, uint ShadingModelID,
	FDeferredLightData LightData,  float4  LightAttenuation, float Dither, uint2 SVPos,
	inout float SurfaceShadow)
{
	FLightAccumulator LightAccumulator = (FLightAccumulator)0;

	float3  V = -CameraVector;
	float3  N = GBuffer.WorldNormal;
	[branch]  if( GBuffer.ShadingModelID ==  4  &&  0 )
	{
		const float2 oct1 = ((float2(GBuffer.CustomData.a, GBuffer.CustomData.z) * 4) - (512.0/255.0)) + UnitVectorToOctahedron(GBuffer.WorldNormal);
		N = OctahedronToUnitVector(oct1);
	}

	float3 L = LightData.Direction;
	float3 ToLight = L;
	float3 MaskedLightColor = LightData.Color;
	float LightMask = 1;
	if (LightData.bRadialLight)
	{
		LightMask = GetLocalLightAttenuation( TranslatedWorldPosition, LightData, ToLight, L );
		MaskedLightColor *= LightMask;
	}

	LightAccumulator.EstimatedCost += 0.3f;

	[branch]
	if( LightMask > 0 )
	{
		FShadowTerms Shadow;
		Shadow.SurfaceShadow = AmbientOcclusion;
		Shadow.TransmissionShadow = 1;
		Shadow.TransmissionThickness = 1;
		Shadow.HairTransmittance.OpaqueVisibility = 1;
		const float ContactShadowOpacity = GBuffer.CustomData.a;
		GetShadowTerms(GBuffer.Depth, GBuffer.PrecomputedShadowFactors, GBuffer.ShadingModelID, ContactShadowOpacity,
			LightData, TranslatedWorldPosition, L, LightAttenuation, Dither, Shadow);
		SurfaceShadow = Shadow.SurfaceShadow;

		LightAccumulator.EstimatedCost += 0.3f;
#line 427 "/Engine/Private/DeferredLightingCommon.ush"
		[branch]
		if( Shadow.SurfaceShadow + Shadow.TransmissionShadow > 0 )
		{
			const bool bNeedsSeparateSubsurfaceLightAccumulation = UseSubsurfaceProfile(GBuffer.ShadingModelID);
#line 451 "/Engine/Private/DeferredLightingCommon.ush"
			FDirectLighting Lighting;

			if (LightData.bRectLight)
			{
				FRect Rect = GetRect( ToLight, LightData );
				const FRectTexture SourceTexture = InitRectTexture(LightData);




					Lighting = IntegrateBxDF( GBuffer, N, V, Rect, Shadow, SourceTexture);

			}
			else
			{
				FCapsuleLight Capsule = GetCapsule( ToLight, LightData );




					Lighting = IntegrateBxDF( GBuffer, N, V, Capsule, Shadow, LightData.bInverseSquared );

			}

			Lighting.Specular *= LightData.SpecularScale;

			LightAccumulator_AddSplit( LightAccumulator, Lighting.Diffuse, Lighting.Specular, Lighting.Diffuse, MaskedLightColor * Shadow.SurfaceShadow, bNeedsSeparateSubsurfaceLightAccumulation );
			LightAccumulator_AddSplit( LightAccumulator, Lighting.Transmission, 0.0f, Lighting.Transmission, MaskedLightColor * Shadow.TransmissionShadow, bNeedsSeparateSubsurfaceLightAccumulation );

			LightAccumulator.EstimatedCost += 0.4f;

		}

	}
	return LightAccumulator;
}


FDeferredLightingSplit GetDynamicLightingSplit(
	float3 TranslatedWorldPosition, float3 CameraVector, FGBufferData GBuffer, float AmbientOcclusion, uint ShadingModelID,
	FDeferredLightData LightData, float4 LightAttenuation, float Dither, uint2 SVPos,
	inout float SurfaceShadow)
{
	FLightAccumulator LightAccumulator = AccumulateDynamicLighting(TranslatedWorldPosition, CameraVector, GBuffer, AmbientOcclusion, ShadingModelID, LightData, LightAttenuation, Dither, SVPos, SurfaceShadow);
	return LightAccumulator_GetResultSplit(LightAccumulator);
}

float4 GetDynamicLighting(
	float3 TranslatedWorldPosition, float3 CameraVector, FGBufferData GBuffer, float AmbientOcclusion, uint ShadingModelID,
	FDeferredLightData LightData, float4 LightAttenuation, float Dither, uint2 SVPos,
	inout float SurfaceShadow)
{
	FDeferredLightingSplit SplitLighting = GetDynamicLightingSplit(
		TranslatedWorldPosition, CameraVector, GBuffer, AmbientOcclusion, ShadingModelID,
		LightData, LightAttenuation, Dither, SVPos,
		SurfaceShadow);

	return SplitLighting.SpecularLighting + SplitLighting.DiffuseLighting;
}
#line 516 "/Engine/Private/DeferredLightingCommon.ush"
float3 GetSimpleDynamicLighting(float3 TranslatedWorldPosition, float3 CameraVector, float3 WorldNormal, float AmbientOcclusion, float3 DiffuseColor, float3 SpecularColor, float Roughness, FSimpleDeferredLightData LightData)
{
	float3 V = -CameraVector;
	float3 N = WorldNormal;
	float3 ToLight = LightData.TranslatedWorldPosition - TranslatedWorldPosition;
	float DistanceAttenuation = 1;

	float DistanceSqr = dot( ToLight, ToLight );
	float3 L = ToLight * rsqrt( DistanceSqr );
	float NoL = saturate( dot( N, L ) );

	if (LightData.bInverseSquared)
	{

		DistanceAttenuation = 1 / ( DistanceSqr + 1 );

		float LightRadiusMask = Square( saturate( 1 - Square( DistanceSqr * Square(LightData.InvRadius) ) ) );
		DistanceAttenuation *= LightRadiusMask;
	}
	else
	{
		DistanceAttenuation = RadialAttenuation(ToLight * LightData.InvRadius, LightData.FalloffExponent);
	}

	float3 OutLighting = 0;

	[branch]
	if (DistanceAttenuation > 0)
	{
		const float3 LightColor = LightData.Color;


		float Attenuation = DistanceAttenuation * AmbientOcclusion;





			OutLighting += LightColor * (NoL * Attenuation) * SimpleShading(DiffuseColor, SpecularColor, max(Roughness, .04f), L, V, N);

	}

	return OutLighting;
}
#line 6 "/Engine/Private/Lumen/LumenSceneDirectLightingCulling.usf"
#line 7 "/Engine/Private/Lumen/LumenSceneDirectLightingCulling.usf"
#line 1 "LumenCardCommon.ush"
#line 11 "/Engine/Private/Lumen/LumenCardCommon.ush"
struct FLumenCardData
{

	float3x3 MeshCardsToLocalRotation;
	float3 MeshCardsOrigin;
	float3 MeshCardsExtent;


	float3x3 WorldToLocalRotation;
	float3 Origin;
	float3 LocalExtent;

	uint2 SizeInPages;
	uint PageTableOffset;

	uint2 HiResSizeInPages;
	uint HiResPageTableOffset;


	uint2 ResLevelToResLevelXYBias;

	bool bVisible;
	bool bHeightfield;
	uint AxisAlignedDirection;
	uint LightingChannelMask;


	float TexelSize;
};
#line 56 "/Engine/Private/Lumen/LumenCardCommon.ush"
FLumenCardData GetLumenCardData(uint CardId)
{
	FLumenCardData CardData = (FLumenCardData)0;

	uint BaseOffset = CardId *  9 ;
	float4 Vector0 =  LumenCardScene.CardData [BaseOffset + 0];
	float4 Vector1 =  LumenCardScene.CardData [BaseOffset + 1];
	float4 Vector2 =  LumenCardScene.CardData [BaseOffset + 2];
	float4 Vector3 =  LumenCardScene.CardData [BaseOffset + 3];
	float4 Vector4 =  LumenCardScene.CardData [BaseOffset + 4];
	float4 Vector5 =  LumenCardScene.CardData [BaseOffset + 5];
	float4 Vector6 =  LumenCardScene.CardData [BaseOffset + 6];
	float4 Vector7 =  LumenCardScene.CardData [BaseOffset + 7];
	float4 Vector8 =  LumenCardScene.CardData [BaseOffset + 8];

	CardData.WorldToLocalRotation[0] = Vector0.xyz;
	CardData.WorldToLocalRotation[1] = Vector1.xyz;
	CardData.WorldToLocalRotation[2] = Vector2.xyz;
	CardData.Origin = float3(Vector0.w, Vector1.w, Vector2.w);

	CardData.LocalExtent = abs(Vector3.xyz);

	uint Packed3W = asuint(Vector3.w);
	CardData.ResLevelToResLevelXYBias.x = (Packed3W >> 0) & 0xFF;
	CardData.ResLevelToResLevelXYBias.y = (Packed3W >> 8) & 0xFF;
	CardData.AxisAlignedDirection = (Packed3W >> 16) & 0xF;
	CardData.LightingChannelMask = (Packed3W >> 20) & 0xF;
	CardData.bVisible = (Packed3W >> 24) & 1;
	CardData.bHeightfield = (Packed3W >> 25) & 1;

	CardData.SizeInPages.x = (asuint(Vector4.x) >> 0) & 0xFFFF;
	CardData.SizeInPages.y = (asuint(Vector4.x) >> 16) & 0xFFFF;
	CardData.PageTableOffset = asuint(Vector4.y);
	CardData.HiResSizeInPages.x = (asuint(Vector4.z) >> 0) & 0xFFFF;
	CardData.HiResSizeInPages.y = (asuint(Vector4.z) >> 16) & 0xFFFF;
	CardData.HiResPageTableOffset = asuint(Vector4.w);

	CardData.MeshCardsToLocalRotation[0] = Vector5.xyz;
	CardData.MeshCardsToLocalRotation[1] = Vector6.xyz;
	CardData.MeshCardsToLocalRotation[2] = Vector7.xyz;
	CardData.MeshCardsOrigin = float3(Vector5.w, Vector6.w, Vector7.w);
	CardData.MeshCardsExtent = Vector8.xyz;
	CardData.TexelSize = Vector8.w;

	return CardData;
}

struct FLumenCardPageData
{
	uint CardIndex;
	bool bMapped;

	uint ResLevelPageTableOffset;
	uint2 ResLevelSizeInTiles;

	float2 SizeInTexels;
	float2 PhysicalAtlasCoord;

	float4 CardUVRect;
	float4 PhysicalAtlasUVRect;
	float2 CardUVTexelScale;
	float2 PhysicalAtlasUVTexelScale;

	uint LastDirectLightingUpdateFrameIndex;
	uint LastIndirectLightingUpdateFrameIndex;


	uint IndirectLightingTemporalIndex;
};

RWStructuredBuffer<float4> RWLumenCardPageDataBuffer;







FLumenCardPageData GetLumenCardPageData(uint CardPageId)
{
	FLumenCardPageData CardPageData = (FLumenCardPageData) 0;

	uint BaseOffset = CardPageId *  5 ;
	float4 Vector0 =  LumenCardScene.CardPageData [BaseOffset + 0];
	float4 Vector1 =  LumenCardScene.CardPageData [BaseOffset + 1];
	float4 Vector2 =  LumenCardScene.CardPageData [BaseOffset + 2];
	float4 Vector3 =  LumenCardScene.CardPageData [BaseOffset + 3];
	float4 Vector4 =  LumenCardScene.CardPageData [BaseOffset + 4];

	CardPageData.CardIndex = asuint(Vector0.x);
	CardPageData.ResLevelPageTableOffset = asuint(Vector0.y);
	CardPageData.SizeInTexels = Vector0.zw;
	CardPageData.CardUVRect = Vector1;
	CardPageData.PhysicalAtlasUVRect = Vector2;
	CardPageData.CardUVTexelScale = Vector3.xy;
	CardPageData.ResLevelSizeInTiles = asuint(Vector3.zw);

	CardPageData.LastDirectLightingUpdateFrameIndex = asuint(Vector4.x);
	CardPageData.LastIndirectLightingUpdateFrameIndex = asuint(Vector4.y);
	CardPageData.IndirectLightingTemporalIndex = asuint(Vector4.z);


	CardPageData.bMapped = CardPageData.SizeInTexels.x > 0;
	CardPageData.PhysicalAtlasCoord = CardPageData.PhysicalAtlasUVRect.xy * LumenCardScene.PhysicalAtlasSize;
	CardPageData.PhysicalAtlasUVTexelScale = LumenCardScene.InvPhysicalAtlasSize;

	return CardPageData;
}


void SetCardPageUpdateData(uint CardPageId, FLumenCardPageData CardPageData)
{


	uint4 Vector4;
	Vector4.x = CardPageData.LastDirectLightingUpdateFrameIndex;
	Vector4.y = CardPageData.LastIndirectLightingUpdateFrameIndex;
	Vector4.z = CardPageData.IndirectLightingTemporalIndex;
	Vector4.w = 0;

	uint BaseOffset = CardPageId *  5 ;
	RWLumenCardPageDataBuffer[BaseOffset + 4] = asfloat(Vector4);
}

struct FCardVSToPS
{
	float2 AtlasUV : ATTRIBUTE0;
	float2 IndirectLightingAtlasUV : ATTRIBUTE1;
	float2 CardUV : ATTRIBUTE2;
	nointerpolation uint CardTileIndex : CARD_TILE_INDEX;
	nointerpolation uint CardPageIndex : CARD_PAGE_INDEX;
};







struct FLumenMeshCardsData
{
	float3 WorldOrigin;
	float3x3 WorldToLocalRotation;

	float3 MinMeshCardsPosition;
	float3 MaxMeshCardsPosition;

	uint NumCards;
	uint CardOffset;

	bool bHeightfield;

	uint CardLookup[6];
};


FLumenMeshCardsData GetLumenMeshCardsData(uint MeshCardsId)
{
	uint BaseOffset = MeshCardsId *  7 ;

	FLumenMeshCardsData MeshCardsData;

	float4 V0 = LumenCardScene.MeshCardsData[BaseOffset + 0];
	float4 V1 = LumenCardScene.MeshCardsData[BaseOffset + 1];
	float4 V2 = LumenCardScene.MeshCardsData[BaseOffset + 2];

	MeshCardsData.WorldToLocalRotation[0] = V0.xyz;
	MeshCardsData.WorldToLocalRotation[1] = V1.xyz;
	MeshCardsData.WorldToLocalRotation[2] = V2.xyz;
	MeshCardsData.WorldOrigin = float3(V0.w, V1.w, V2.w);

	uint4 V3 = asuint(LumenCardScene.MeshCardsData[BaseOffset + 3]);
	uint4 V4 = asuint(LumenCardScene.MeshCardsData[BaseOffset + 4]);

	MeshCardsData.CardOffset = V3.x;
	MeshCardsData.NumCards = V3.y & 0xFFFF;
	MeshCardsData.bHeightfield = V3.y & 0x10000 ? true : false;
	MeshCardsData.CardLookup[0] = V3.z;
	MeshCardsData.CardLookup[1] = V3.w;
	MeshCardsData.CardLookup[2] = V4.x;
	MeshCardsData.CardLookup[3] = V4.y;
	MeshCardsData.CardLookup[4] = V4.z;
	MeshCardsData.CardLookup[5] = V4.w;

	float4 V5 = LumenCardScene.MeshCardsData[BaseOffset + 5];
	float4 V6 = LumenCardScene.MeshCardsData[BaseOffset + 6];

	MeshCardsData.MinMeshCardsPosition = V5.xyz;
	MeshCardsData.MaxMeshCardsPosition = V6.xyz;

	return MeshCardsData;
}




struct FLumenHeightfieldData
{
	FLWCVector3 BoundsCenter;
	float3 BoundsExtent;
	uint MeshCardsIndex;
	bool bValid;
};


FLumenHeightfieldData GetLumenHeightfieldData(uint HeightfieldId)
{
	uint BaseOffset = HeightfieldId *  3 ;

	FLumenHeightfieldData LumenHeightfield;

	float4 V0 = LumenCardScene.HeightfieldData[BaseOffset + 0];
	float4 V1 = LumenCardScene.HeightfieldData[BaseOffset + 1];
	float4 V2 = LumenCardScene.HeightfieldData[BaseOffset + 2];

	LumenHeightfield.BoundsCenter = MakeLWCVector3(V0.xyz, V1.xyz);
	LumenHeightfield.BoundsExtent = V2.xyz;

	LumenHeightfield.MeshCardsIndex = asuint(V0.w);
	LumenHeightfield.bValid = LumenHeightfield.MeshCardsIndex < LumenCardScene.NumMeshCards;

	return LumenHeightfield;
}

float3 GetCardLocalPosition(float3 CardLocalExtent, float2 CardUV, float Depth)
{
	CardUV.x = 1.0f - CardUV.x;

	float3 LocalPosition;
	LocalPosition.xy = CardLocalExtent.xy * (1.0f - 2.0f * CardUV);
	LocalPosition.z = -(2.0f * Depth - 1.0f) * CardLocalExtent.z;

	return LocalPosition;
}

void GetCardLocalBBox(FLumenCardPageData CardPage, FLumenCardData Card, float2 UVMin, float2 UVMax, out float3 CardPageLocalCenter, out float3 CardPageLocalExtent)
{
	float2 CardUVMin = lerp(CardPage.CardUVRect.xw, CardPage.CardUVRect.zy, UVMin);
	float2 CardUVMax = lerp(CardPage.CardUVRect.xw, CardPage.CardUVRect.zy, UVMax);
	float3 CardPageLocalBoxMin = GetCardLocalPosition(Card.LocalExtent, CardUVMin, 1.0f);
	float3 CardPageLocalBoxMax = GetCardLocalPosition(Card.LocalExtent, CardUVMax, 0.0f);

	CardPageLocalCenter = 0.5f * (CardPageLocalBoxMax + CardPageLocalBoxMin);
	CardPageLocalExtent = 0.5f * (CardPageLocalBoxMax - CardPageLocalBoxMin);
}

void GetCardPageLocalBBox(FLumenCardPageData CardPage, FLumenCardData Card, out float3 CardPageLocalCenter, out float3 CardPageLocalExtent)
{
	GetCardLocalBBox(CardPage, Card, 0, 1, CardPageLocalCenter, CardPageLocalExtent);
}

float3 GetCardWorldPosition(FLumenCardData Card, float2 CardUV, float Depth)
{
	float3 LocalPosition = GetCardLocalPosition(Card.LocalExtent, CardUV, Depth);
	float3 WorldPosition = mul(Card.WorldToLocalRotation, LocalPosition) + Card.Origin;
	return WorldPosition;
}

uint2 GetCardPageSizeInTexels(FLumenCardPageData CardPage, uint2 AtlasSize)
{
	float2 AtlasSizeInUV = CardPage.PhysicalAtlasUVRect.zw - CardPage.PhysicalAtlasUVRect.xy;
	return uint2(AtlasSizeInUV * AtlasSize);
}

float2 CardPageUVToCardUV(FLumenCardPageData CardPage, float2 CardPageUV)
{
	float2 CardUV = lerp(CardPage.CardUVRect.xy, CardPage.CardUVRect.zw, CardPageUV);
	return CardUV;
}

float2 CardPageUVToAtlasUV(FLumenCardPageData CardPage, float2 CardPageUV)
{
	float2 AtlasUV = lerp(CardPage.PhysicalAtlasUVRect.xy, CardPage.PhysicalAtlasUVRect.zw, CardPageUV);
	return AtlasUV;
}

float2 SamplePositonToCardUV(FLumenCardData Card, float2 LocalSamplePosition)
{
	float2 CardUV = saturate(float2(+0.5f, -0.5f) * (LocalSamplePosition / Card.LocalExtent.xy) + 0.5f);
	return CardUV;
}

uint GetMeshCardsIndexFromSceneInstanceIndex(uint SceneInstanceIndex)
{
	const uint MeshCardsIndex = LumenCardScene.SceneInstanceIndexToMeshCardsIndexBuffer.Load(4 * SceneInstanceIndex);
	return MeshCardsIndex;
}
#line 8 "/Engine/Private/Lumen/LumenSceneDirectLightingCulling.usf"
#line 1 "LumenCardTile.ush"
#line 12 "/Engine/Private/Lumen/LumenCardTile.ush"
struct FCardTileData
{
	uint CardPageIndex;
	uint2 TileCoord;
};

FCardTileData UnpackCardTileData(uint PackedTile)
{
	FCardTileData TileData;
	TileData.CardPageIndex = PackedTile & 0xFFFFFF;
	TileData.TileCoord.x = (PackedTile >> 24) & 0xF;
	TileData.TileCoord.y = (PackedTile >> 28) & 0xF;
	return TileData;
}

uint PackCardTileData(FCardTileData CardTile)
{
	uint PackedTile = CardTile.CardPageIndex;
	PackedTile |= (CardTile.TileCoord.x << 24);
	PackedTile |= (CardTile.TileCoord.y << 28);
	return PackedTile;
}

struct FLightTileForCompactionPass
{
	uint LightIndex;
	uint ViewIndex;
	uint bHasShadowMask;
	uint CardTileIndex;
	uint CulledLightIndex;
};

struct FLightTileForShadowMaskPass
{
	uint LightIndex;
	uint ViewIndex;
	uint CardPageIndex;
	uint2 TileCoord;
};

struct FLightTileForLightPass
{
	uint LightIndex;
	uint ViewIndex;
	uint ShadowMaskIndex;
};

FLightTileForCompactionPass UnpackLightTileForCompactionPass(uint2 PackedTile)
{
	FLightTileForCompactionPass Tile;
	Tile.LightIndex = BitFieldExtractU32(PackedTile.x, 28, 0);
	Tile.ViewIndex = BitFieldExtractU32(PackedTile.x, 3, 28);
	Tile.bHasShadowMask = BitFieldExtractU32(PackedTile.x, 1, 31);
	Tile.CardTileIndex = BitFieldExtractU32(PackedTile.y, 24, 0);
	Tile.CulledLightIndex = BitFieldExtractU32(PackedTile.y, 8, 24);
	return Tile;
}

FLightTileForShadowMaskPass UnpackLightTileForShadowMaskPass(uint2 PackedTile)
{
	FLightTileForShadowMaskPass Tile;
	Tile.LightIndex = BitFieldExtractU32(PackedTile.x, 28, 0);
	Tile.ViewIndex = BitFieldExtractU32(PackedTile.x, 4, 28);
	Tile.CardPageIndex = BitFieldExtractU32(PackedTile.y, 24, 0);
	Tile.TileCoord.x = BitFieldExtractU32(PackedTile.y, 4, 24);
	Tile.TileCoord.y = BitFieldExtractU32(PackedTile.y, 4, 28);
	return Tile;
}

FLightTileForLightPass UnpackLightTileForLightPass(uint2 PackedTile)
{
	FLightTileForLightPass Tile;
	Tile.LightIndex = BitFieldExtractU32(PackedTile.x, 28, 0);
	Tile.ViewIndex = BitFieldExtractU32(PackedTile.x, 4, 28);
	Tile.ShadowMaskIndex = PackedTile.y;
	return Tile;
}

uint2 PackLightTileForCompactionPass(FLightTileForCompactionPass Tile)
{
	uint2 PackedTile;
	PackedTile.x = Tile.LightIndex | (Tile.ViewIndex << 28) | (Tile.bHasShadowMask << 31);
	PackedTile.y = Tile.CardTileIndex | (Tile.CulledLightIndex << 24);
	return PackedTile;
}

uint2 PackLightTileForShadowMaskPass(FLightTileForShadowMaskPass Tile)
{
	uint2 PackedTile;
	PackedTile.x = Tile.LightIndex | (Tile.ViewIndex << 28);
	PackedTile.y = Tile.CardPageIndex;
	PackedTile.y |= (Tile.TileCoord.x << 24);
	PackedTile.y |= (Tile.TileCoord.y << 28);
	return PackedTile;
}

uint2 PackLightTileForLightPass(FLightTileForLightPass Tile)
{
	uint2 PackedTile;
	PackedTile.x = Tile.LightIndex | (Tile.ViewIndex << 28);
	PackedTile.y = Tile.ShadowMaskIndex;
	return PackedTile;
}

float4x4 WorldToClip[2];
float4 PreViewTranslation[2];

uint GetCardViewIndex(FLumenCardPageData CardPage, FLumenCardData Card, float2 UVMin, float2 UVMax, uint NumViews, bool bPrioritizeWhenInFrustum)
{
	float3 CardPageLocalCenter;
	float3 CardPageLocalExtent;
	GetCardLocalBBox(CardPage, Card, UVMin, UVMax, CardPageLocalCenter, CardPageLocalExtent);

	float3 CardPageWorldCenter = mul(Card.WorldToLocalRotation, CardPageLocalCenter) + Card.Origin;
	float3 CardPageWorldExtent = mul(abs(Card.WorldToLocalRotation), CardPageLocalExtent);

	uint ViewIndex = 0;

	if (NumViews > 1)
	{
		float View0Distance = length(CardPageWorldCenter - -PreViewTranslation[0].xyz);
		float View1Distance = length(CardPageWorldCenter - -PreViewTranslation[1].xyz);



		if (bPrioritizeWhenInFrustum)
		{
			float4 CardOriginClipSpace0 = mul(float4(CardPageWorldCenter, 1.0f), WorldToClip[0]);

			if (all(CardOriginClipSpace0.xy >= CardOriginClipSpace0.w) && all(CardOriginClipSpace0.xy <= CardOriginClipSpace0.w) && CardOriginClipSpace0.z < 1.0f)
			{
				View0Distance = .5f * CardOriginClipSpace0.w;
			}

			float4 CardOriginClipSpace1 = mul(float4(CardPageWorldCenter, 1.0f), WorldToClip[1]);

			if (all(CardOriginClipSpace1.xy >= CardOriginClipSpace1.w) && all(CardOriginClipSpace1.xy <= CardOriginClipSpace1.w) && CardOriginClipSpace1.z < 1.0f)
			{
				View1Distance = .5f * CardOriginClipSpace1.w;
			}
		}

		ViewIndex = View0Distance < View1Distance ? 0 : 1;
	}

	return ViewIndex;
}
#line 9 "/Engine/Private/Lumen/LumenSceneDirectLightingCulling.usf"
#line 1 "LumenSceneDirectLighting.ush"
#line 5 "/Engine/Private/Lumen/LumenSceneDirectLighting.ush"
#line 1 "LumenSceneLighting.ush"
#line 22 "/Engine/Private/Lumen/LumenSceneLighting.ush"
float CalculateDistanceBasedHeightfieldBias(float SurfaceBias, float3 WorldPosition, float3 WorldCameraOrigin)
{
		float DistanceBasedHeightfieldBias = SurfaceBias;
		float WorldPositionDistanceToCamera = length(WorldPosition - WorldCameraOrigin);
		DistanceBasedHeightfieldBias = SurfaceBias * WorldPositionDistanceToCamera;

		return clamp(DistanceBasedHeightfieldBias, 0.01, 100.0);
}

float GetCardBiasForShadowing(float3 L, float3 WorldNormal, float BiasValue)
{
	float SurfaceBias = BiasValue;
	float SlopeScaledSurfaceBias = 2.0f * BiasValue;
	return SurfaceBias + SlopeScaledSurfaceBias * saturate(1 - dot(L, WorldNormal));
}

float3 GetCardWorldPositionForShadowing(float3 WorldPosition, float3 L, float3 WorldNormal, float BiasValue)
{
	return WorldPosition + L * GetCardBiasForShadowing(L, WorldNormal, BiasValue);
}
#line 6 "/Engine/Private/Lumen/LumenSceneDirectLighting.ush"







RWStructuredBuffer<uint> RWShadowMaskTiles;
StructuredBuffer<uint> ShadowMaskTiles;

struct FShadowTrace
{
	uint LightTileIndex;
	uint2 LightTileCoord;
};

FShadowTrace UnpackShadowTrace(uint PackedValue)
{
	FShadowTrace ShadowTrace;
	ShadowTrace.LightTileIndex = PackedValue & 0xFFFFFF;
	ShadowTrace.LightTileCoord.x = (PackedValue >> 24) & 0xF;
	ShadowTrace.LightTileCoord.y = (PackedValue >> 28) & 0xF;
	return ShadowTrace;
}

uint PackShadowTrace(FShadowTrace ShadowTrace)
{
	uint PackedValue = 0;
	PackedValue = ShadowTrace.LightTileIndex & 0xFFFFFF;
	PackedValue |= (ShadowTrace.LightTileCoord.x & 0xF) << 24;
	PackedValue |= (ShadowTrace.LightTileCoord.y & 0xF) << 28;
	return PackedValue;
}









struct FShadowMaskRay
{
	float ShadowFactor;
	bool bShadowFactorComplete;
};

void ReadShadowMaskRayRW(uint CardTileIndex, uint2 CoordInCardTile, inout FShadowMaskRay ShadowMaskRay)
{
	uint BitOffset =  8  * (CoordInCardTile.x + CoordInCardTile.y *  8 );

	uint ShadowMask = RWShadowMaskTiles[ ( 8 * 8 * 8 / 32)  * CardTileIndex + BitOffset / 32];
	ShadowMask = ShadowMask >> (BitOffset % 32);

	ShadowMaskRay.ShadowFactor = float(ShadowMask &  ((1u << 7 ) - 1) ) /  ((1u << 7 ) - 1) ;
	ShadowMaskRay.bShadowFactorComplete = (ShadowMask &  (((1u << 1 ) - 1) << 7 ) ) != 0;
}

void ReadShadowMaskRay(uint CardTileIndex, uint2 CoordInCardTile, inout FShadowMaskRay ShadowMaskRay)
{
	uint BitOffset =  8  * (CoordInCardTile.x + CoordInCardTile.y *  8 );

	uint ShadowMask = ShadowMaskTiles[ ( 8 * 8 * 8 / 32)  * CardTileIndex + BitOffset / 32];
	ShadowMask = ShadowMask >> (BitOffset % 32);

	ShadowMaskRay.ShadowFactor = float(ShadowMask &  ((1u << 7 ) - 1) ) /  ((1u << 7 ) - 1) ;
	ShadowMaskRay.bShadowFactorComplete = (ShadowMask &  (((1u << 1 ) - 1) << 7 ) ) != 0;
}

void WriteShadowMaskRay(FShadowMaskRay Ray, uint CardTileIndex, uint2 CoordInCardTile, const bool bClearExistingMask)
{
	uint Mask = uint(Ray.ShadowFactor *  ((1u << 7 ) - 1) );

	if (Ray.bShadowFactorComplete)
	{
		Mask |=  (((1u << 1 ) - 1) << 7 ) ;
	}

	uint BitOffset =  8  * (CoordInCardTile.x + CoordInCardTile.y *  8 );

	if (bClearExistingMask)
	{
		InterlockedAnd(RWShadowMaskTiles[ ( 8 * 8 * 8 / 32)  * CardTileIndex + BitOffset / 32], ~( ((1u << 8 ) - 1)  << (BitOffset % 32)));
	}

	if (Mask != 0)
	{
		InterlockedOr(RWShadowMaskTiles[ ( 8 * 8 * 8 / 32)  * CardTileIndex + BitOffset / 32], Mask << (BitOffset % 32));
	}
}

FDeferredLightData LoadLightData(uint LightType)
{
	FDeferredLightData LightData = (FDeferredLightData)0;

	LightData.TranslatedWorldPosition = DeferredLightUniforms.TranslatedWorldPosition;
	LightData.InvRadius = DeferredLightUniforms.InvRadius;
	LightData.Color = DeferredLightUniforms.Color;
	LightData.FalloffExponent = DeferredLightUniforms.FalloffExponent;
	LightData.Direction = DeferredLightUniforms.Direction;
	LightData.Tangent = DeferredLightUniforms.Tangent;
	LightData.SpotAngles = DeferredLightUniforms.SpotAngles;
	LightData.SourceRadius = DeferredLightUniforms.SourceRadius;
	LightData.SourceLength = DeferredLightUniforms.SourceLength;
	LightData.SoftSourceRadius = DeferredLightUniforms.SoftSourceRadius;
	LightData.SpecularScale = DeferredLightUniforms.SpecularScale;
	LightData.ContactShadowLength = abs(DeferredLightUniforms.ContactShadowLength);
	LightData.ContactShadowLengthInWS = DeferredLightUniforms.ContactShadowLength < 0.0f;
	LightData.DistanceFadeMAD = DeferredLightUniforms.DistanceFadeMAD;
	LightData.ShadowMapChannelMask = DeferredLightUniforms.ShadowMapChannelMask;
	LightData.ShadowedBits = DeferredLightUniforms.ShadowedBits;
	LightData.RectLightBarnCosAngle = DeferredLightUniforms.RectLightBarnCosAngle;
	LightData.RectLightBarnLength = DeferredLightUniforms.RectLightBarnLength;
	LightData.RectLightAtlasUVOffset = DeferredLightUniforms.RectLightAtlasUVOffset;
	LightData.RectLightAtlasUVScale = DeferredLightUniforms.RectLightAtlasUVScale;
	LightData.RectLightAtlasMaxLevel = DeferredLightUniforms.RectLightAtlasMaxLevel;

	LightData.bInverseSquared = LightData.FalloffExponent == 0.0f;
	LightData.bRadialLight = LightType !=  0 ;
	LightData.bSpotLight = LightType ==  2 ;
	LightData.bRectLight = LightType ==  3 ;

	return LightData;
}


struct FLumenPackedLight
{
	float3 WorldPosition;
	float InvRadius;

	float3 Color;
	float FalloffExponent;

	float3 Direction;
	float SpecularScale;

	float3 Tangent;
	float SourceRadius;

	float2 SpotAngles;
	float SoftSourceRadius;
	float SourceLength;

	float RectLightBarnCosAngle;
	float RectLightBarnLength;
	uint LightType;
	uint VirtualShadowMapId;

	float4 InfluenceSphere;

	float3 ProxyPosition;
	float ProxyRadius;

	float3 ProxyDirection;
	float RectLightAtlasMaxLevel;

	float2 SinCosConeAngleOrRectLightAtlasUVScale;
	float2 RectLightAtlasUVOffset;

	uint LightingChannelMask;
	uint bHasShadowMask;
	uint Padding[2];
};

struct FLumenLight
{
	FDeferredLightData DeferredLightData;

	float4 InfluenceSphere;
	float3 ProxyPosition;
	float3 ProxyDirection;
	float ProxyRadius;
	float CosConeAngle;
	float SinConeAngle;

	uint VirtualShadowMapId;
	uint LightingChannelMask;
	uint bHasShadowMask;
	uint Type;
};

StructuredBuffer<FLumenPackedLight> LumenPackedLights;

FLumenLight LoadLumenLight(uint LightIndex, float3 PreViewTranslation)
{
	FLumenPackedLight PackedLight = LumenPackedLights[LightIndex];

	FDeferredLightData DeferredLightData = (FDeferredLightData)0;
	DeferredLightData.TranslatedWorldPosition = PackedLight.WorldPosition + PreViewTranslation;
	DeferredLightData.InvRadius = PackedLight.InvRadius;
	DeferredLightData.Color = PackedLight.Color;
	DeferredLightData.FalloffExponent = PackedLight.FalloffExponent;
	DeferredLightData.Direction = PackedLight.Direction;
	DeferredLightData.Tangent = PackedLight.Tangent;
	DeferredLightData.SpotAngles = PackedLight.SpotAngles;
	DeferredLightData.SourceRadius = PackedLight.SourceRadius;
	DeferredLightData.SourceLength = PackedLight.SourceLength;
	DeferredLightData.SoftSourceRadius = PackedLight.SoftSourceRadius;
	DeferredLightData.SpecularScale = PackedLight.SpecularScale;
	DeferredLightData.ContactShadowLength = 0.0f;
	DeferredLightData.ContactShadowLengthInWS = false;
	DeferredLightData.DistanceFadeMAD = 0.0f;
	DeferredLightData.ShadowMapChannelMask = 0.0f;
	DeferredLightData.ShadowedBits = 0;
	DeferredLightData.RectLightBarnCosAngle = PackedLight.RectLightBarnCosAngle;
	DeferredLightData.RectLightBarnLength = PackedLight.RectLightBarnLength;
	DeferredLightData.RectLightAtlasUVScale = PackedLight.SinCosConeAngleOrRectLightAtlasUVScale;
	DeferredLightData.RectLightAtlasUVOffset = PackedLight.RectLightAtlasUVOffset;
	DeferredLightData.RectLightAtlasMaxLevel = PackedLight.RectLightAtlasMaxLevel;
	DeferredLightData.bInverseSquared = PackedLight.FalloffExponent == 0.0f;
	DeferredLightData.bRadialLight = PackedLight.LightType !=  0 ;
	DeferredLightData.bSpotLight = PackedLight.LightType ==  2 ;
	DeferredLightData.bRectLight = PackedLight.LightType ==  3 ;

	FLumenLight LumenLight = (FLumenLight)0;
	LumenLight.DeferredLightData = DeferredLightData;
	LumenLight.InfluenceSphere = PackedLight.InfluenceSphere;
	LumenLight.ProxyPosition = PackedLight.ProxyPosition;
	LumenLight.ProxyRadius = PackedLight.ProxyRadius;
	LumenLight.ProxyDirection = PackedLight.ProxyDirection;
	LumenLight.CosConeAngle = PackedLight.SinCosConeAngleOrRectLightAtlasUVScale.y;
	LumenLight.SinConeAngle = PackedLight.SinCosConeAngleOrRectLightAtlasUVScale.x;
	LumenLight.VirtualShadowMapId = PackedLight.VirtualShadowMapId;
	LumenLight.bHasShadowMask = PackedLight.bHasShadowMask;
	LumenLight.LightingChannelMask = PackedLight.LightingChannelMask;
	LumenLight.Type = PackedLight.LightType;
	return LumenLight;
}
#line 10 "/Engine/Private/Lumen/LumenSceneDirectLightingCulling.usf"
#line 19 "/Engine/Private/Lumen/LumenSceneDirectLightingCulling.usf"
StructuredBuffer<uint> CardPageIndexAllocator;
StructuredBuffer<uint> CardPageIndexData;
RWStructuredBuffer<uint> RWCardTileAllocator;
RWStructuredBuffer<uint> RWCardTiles;

groupshared uint SharedTileAllocator;
groupshared uint SharedTiles[ 64  *  64 ];
groupshared uint SharedGlobalTileOffset;
#line 31 "/Engine/Private/Lumen/LumenSceneDirectLightingCulling.usf"
[numthreads( 64 ,  64 , 1)]
void SpliceCardPagesIntoTilesCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint LinearThreadIndex = GroupThreadId.x + GroupThreadId.y *  64 ;
	if (all(GroupThreadId == 0))
	{
		SharedTileAllocator = 0;
		SharedGlobalTileOffset = 0;
		SharedTiles[0] = 0;
	}

	GroupMemoryBarrierWithGroupSync();


	uint LinearLightTileOffset = (GroupId.x % 4);
	uint IndexInIndexBuffer = GroupId.x / 4;


	uint2 TileOffset = ZOrder2D(LinearThreadIndex, log2(8));

	uint2 TileCoord;
	TileCoord.x = (LinearLightTileOffset % 2) * 8 + TileOffset.x;
	TileCoord.y = (LinearLightTileOffset / 2) * 8 + TileOffset.y;

	if (IndexInIndexBuffer < CardPageIndexAllocator[0])
	{
		uint CardPageIndex = CardPageIndexData[IndexInIndexBuffer];
		FLumenCardPageData CardPage = GetLumenCardPageData(CardPageIndex);
		if (CardPage.CardIndex >= 0)
		{
			FLumenCardData Card = GetLumenCardData(CardPage.CardIndex);

			const uint2 SizeInTiles = CardPage.SizeInTexels /  8 ;

			if (all(TileCoord < SizeInTiles))
			{
				FCardTileData CardTile;
				CardTile.CardPageIndex = CardPageIndex;
				CardTile.TileCoord = TileCoord;

				uint CardTileIndex = 0;
				InterlockedAdd(SharedTileAllocator, 1, CardTileIndex);
				SharedTiles[CardTileIndex] = PackCardTileData(CardTile);
			}
		}
	}

	GroupMemoryBarrierWithGroupSync();

	if (all(GroupThreadId == 0) && SharedTileAllocator > 0)
	{
		InterlockedAdd(RWCardTileAllocator[0], SharedTileAllocator, SharedGlobalTileOffset);
	}

	GroupMemoryBarrierWithGroupSync();

	if (LinearThreadIndex < SharedTileAllocator)
	{
		RWCardTiles[SharedGlobalTileOffset + LinearThreadIndex] = SharedTiles[LinearThreadIndex];
	}
}

StructuredBuffer<uint> CardTileAllocator;
StructuredBuffer<uint> CardTiles;
RWBuffer<uint> RWDispatchCardTilesIndirectArgs;

[numthreads( 64 , 1, 1)]
void InitializeCardTileIndirectArgsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	if (DispatchThreadId.x == 0)
	{
		uint NumCardTiles = CardTileAllocator[0];


		RWDispatchCardTilesIndirectArgs[0] = (NumCardTiles + 63) / 64;
		RWDispatchCardTilesIndirectArgs[1] = 1;
		RWDispatchCardTilesIndirectArgs[2] = 1;


		RWDispatchCardTilesIndirectArgs[3] = NumCardTiles;
		RWDispatchCardTilesIndirectArgs[4] = 1;
		RWDispatchCardTilesIndirectArgs[5] = 1;
	}
}

bool SphereIntersectCone(float4 SphereCenterAndRadius, float3 ConeVertex, float3 ConeAxis, float ConeAngleCos, float ConeAngleSin)
{
	float3 U = ConeVertex - (SphereCenterAndRadius.w / ConeAngleSin) * ConeAxis;
	float3 D = SphereCenterAndRadius.xyz - U;
	float DSizeSq = dot(D, D);
	float E = dot(ConeAxis, D);

	if (E > 0 && E * E >= DSizeSq * ConeAngleCos * ConeAngleCos)
	{
		D = SphereCenterAndRadius.xyz - ConeVertex;
		DSizeSq = dot(D, D);
		E = -dot(ConeAxis, D);

		if (E > 0 && E * E >= DSizeSq * ConeAngleSin * ConeAngleSin)
		{
			return DSizeSq <= SphereCenterAndRadius.w * SphereCenterAndRadius.w;
		}
		else
		{
			return true;
		}
	}

	return false;
}

bool DoesLightAffectCardPageUVRange(FLumenLight LumenLight, FLumenCardPageData CardPage, FLumenCardData Card, float2 UVMin, float2 UVMax, inout float3 OutCardPageWorldCenter)
{

	if (!(Card.LightingChannelMask & LumenLight.LightingChannelMask))
	{
		return false;
	}

	float3 CardPageLocalCenter;
	float3 CardPageLocalExtent;
	GetCardLocalBBox(CardPage, Card, UVMin, UVMax, CardPageLocalCenter, CardPageLocalExtent);

	float3 CardPageWorldCenter = mul(Card.WorldToLocalRotation, CardPageLocalCenter) + Card.Origin;
	float3 CardPageWorldExtent = mul(abs(Card.WorldToLocalRotation), CardPageLocalExtent);
	float CardPageWorldBoundingSphere = length(CardPageLocalExtent);
	OutCardPageWorldCenter = CardPageWorldCenter;

	float4 InfluenceSphere = LumenLight.InfluenceSphere;
	float3 LightInfluenceSphereLocalCenter = mul(InfluenceSphere.xyz - Card.Origin, Card.WorldToLocalRotation);
	const float BoxDistanceSq = ComputeSquaredDistanceFromBoxToPoint(CardPageLocalCenter, CardPageLocalExtent, LightInfluenceSphereLocalCenter);
	const bool bCardAffectedByInfluenceSphere = BoxDistanceSq < InfluenceSphere.w * InfluenceSphere.w;

	const uint LightType = LumenLight.Type;
	const float3 LightPosition = LumenLight.ProxyPosition;
	const float3 LightDirection = LumenLight.ProxyDirection;
	const float LightRadius = LumenLight.ProxyRadius;


	if (LightType !=  0  && !bCardAffectedByInfluenceSphere)
	{
		return false;
	}

	if (LightType ==  0 )
	{
		return true;
	}
	else if (LightType ==  1 )
	{

		return bCardAffectedByInfluenceSphere;
	}
	else if (LightType ==  2 )
	{
		float CosConeAngle = LumenLight.CosConeAngle;
		float SinConeAngle = LumenLight.SinConeAngle;

		float ConeAxisDistance = dot(CardPageWorldCenter - LightPosition, LightDirection);
		float2 ConeAxisDistanceMinMax = float2(ConeAxisDistance + CardPageWorldBoundingSphere, ConeAxisDistance - CardPageWorldBoundingSphere);


		return bCardAffectedByInfluenceSphere
			&& SphereIntersectCone(float4(CardPageWorldCenter, CardPageWorldBoundingSphere), LightPosition, LightDirection, CosConeAngle, SinConeAngle)
			&& ConeAxisDistanceMinMax.x > 0 && ConeAxisDistanceMinMax.y < LightRadius;
	}
	else if (LightType ==  3 )
	{

		float4 BackPlane = float4(LightDirection, dot(LightPosition, LightDirection));
		float DistanceFromBoxCenterToPlane = dot(BackPlane.xyz, CardPageWorldCenter) - BackPlane.w;
		float MaxExtent = dot(CardPageWorldExtent, abs(BackPlane.xyz));
		bool bInFrontOfPlane = DistanceFromBoxCenterToPlane + MaxExtent > 0.0f;
		return bCardAffectedByInfluenceSphere && bInFrontOfPlane;
	}


	return false;
}

RWStructuredBuffer<uint> RWLightTileAllocator;
RWStructuredBuffer<uint2> RWLightTiles;
RWStructuredBuffer<uint> RWLightTileAllocatorPerLight;
RWStructuredBuffer<uint> RWLightAllocatorPerTile;
RWStructuredBuffer<uint> RWLightTileAllocatorForPerCardTileDispatch;
RWStructuredBuffer<uint> RWLightTileOffsetNumPerCardTile;

uint MaxLightsPerTile;
               
              

struct FLightSample
{
	float Weight;
	uint LightIndex;
	bool bHasShadowMask;
};

struct FLightSampleAccumulator
{
	uint PackedSamples[ 1 ];
};

FLightSampleAccumulator InitLightSampleAccumulator()
{
	FLightSampleAccumulator LightSampleAccumulator = (FLightSampleAccumulator)0;
	for (uint PackedSampleIndex = 0; PackedSampleIndex <  1 ; ++PackedSampleIndex)
	{
		LightSampleAccumulator.PackedSamples[PackedSampleIndex] = 0;
	}
	return LightSampleAccumulator;
}

uint PackLightSample(FLightSample LightSample)
{
	uint PackedLightSample = LightSample.LightIndex & 0x3FFF;
	PackedLightSample |= LightSample.bHasShadowMask ? 0x4000 : 0;
	PackedLightSample |= 0x8000;
	PackedLightSample |= asuint(LightSample.Weight) & 0xFFFF0000;
	return PackedLightSample;
}

FLightSample UnpackLightSample(uint PackedLightSample)
{
	FLightSample LightSample = (FLightSample)0;
	LightSample.LightIndex = PackedLightSample & 0x3FFF;
	LightSample.bHasShadowMask = PackedLightSample & 0x4000 ? true : false;
	LightSample.Weight = 0.0f;
	return LightSample;
}

void AddLightSample(inout FLightSampleAccumulator LightSampleAccumulator, FLightSample LightSample)
{
	uint PackedLightSample = PackLightSample(LightSample);

	uint MinPackedLightSample = 0xFFFFFFFF;
	for (uint PackedSampleIndex = 0; PackedSampleIndex <  1 ; ++PackedSampleIndex)
	{
		MinPackedLightSample = min(MinPackedLightSample, LightSampleAccumulator.PackedSamples[PackedSampleIndex]);
	}


	if (PackedLightSample > MinPackedLightSample)
	{
		for (uint PackedSampleIndex = 0; PackedSampleIndex <  1 ; ++PackedSampleIndex)
		{
			if (LightSampleAccumulator.PackedSamples[PackedSampleIndex] == MinPackedLightSample)
			{
				LightSampleAccumulator.PackedSamples[PackedSampleIndex] = PackedLightSample;
				break;
			}
		}
	}
}

float GetLightWeight(FLumenLight LumenLight, float3 TranslatedWorldPosition)
{
	FDeferredLightData LightData = LumenLight.DeferredLightData;
	float Weight = Luminance(LightData.Color);

	if (LightData.bRadialLight)
	{
		float3 L = LightData.Direction;
		float3 ToLight = L;
		Weight *= GetLocalLightAttenuation(TranslatedWorldPosition, LightData, ToLight, L);

		float Attenuation = 1.0f;
		if (LightData.bRectLight)
		{
			FRect Rect = GetRect(ToLight, LightData);
			Attenuation = IntegrateLight(Rect);
		}
		else
		{
			FCapsuleLight Capsule = GetCapsule(ToLight, LightData);
			Capsule.DistBiasSqr = 0;
			Attenuation = IntegrateLight(Capsule, LightData.bInverseSquared);
		}
		Weight *= Attenuation;
	}

	return Weight;
}
#line 321 "/Engine/Private/Lumen/LumenSceneDirectLightingCulling.usf"
[numthreads( 64 , 1, 1)]
void BuildLightTilesCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{

	uint CardTileIndex = DispatchThreadId.x;

	FLightSampleAccumulator LightSampleAccumulator = InitLightSampleAccumulator();

	if (CardTileIndex < CardTileAllocator[0])
	{
		FCardTileData CardTile = UnpackCardTileData(CardTiles[CardTileIndex]);
		FLumenCardPageData CardPage = GetLumenCardPageData(CardTile.CardPageIndex);
		uint PackedOffsetNum = 0;

		if (CardPage.CardIndex >= 0)
		{
			FLumenCardData Card = GetLumenCardData(CardPage.CardIndex);

			const uint2 SizeInTiles = CardPage.SizeInTexels /  8 ;
			float2 UVMin = float2(CardTile.TileCoord) / SizeInTiles;
			float2 UVMax = float2(CardTile.TileCoord + 1) / SizeInTiles;

			float SwapY = UVMin.y;
			UVMin.y = 1.0f - UVMax.y;
			UVMax.y = 1.0f - SwapY;

			uint ViewIndex = GetCardViewIndex(CardPage, Card, UVMin, UVMax, NumViews, true);


			for (uint LightIndex = 0; LightIndex < NumLights; ++LightIndex)
			{
				FLumenLight LumenLight = LoadLumenLight(LightIndex, PreViewTranslation[ViewIndex].xyz);

				float3 CardPageWorldCenter = 0.0f;
				bool bLightAffectsCard = DoesLightAffectCardPageUVRange(LumenLight, CardPage, Card, UVMin, UVMax, CardPageWorldCenter);
				if (bLightAffectsCard)
				{

					float3 TranslatedWorldPosition = CardPageWorldCenter +  LWCToFloat( GetPrimaryView() .PreViewTranslation) ;

					FLightSample LightSample;
					LightSample.Weight = GetLightWeight(LumenLight, TranslatedWorldPosition);
					LightSample.LightIndex = LightIndex;
					LightSample.bHasShadowMask = LumenLight.bHasShadowMask;
					AddLightSample(LightSampleAccumulator, LightSample);
				}
			}

			uint NumPackedLightSamples = 0;
			for (uint PackedSampleIndex = 0; PackedSampleIndex <  1 ; ++PackedSampleIndex)
			{
				if (LightSampleAccumulator.PackedSamples[PackedSampleIndex] > 0)
				{
					++NumPackedLightSamples;
				}
			}

			uint LightTileOffset = 0;
			if (NumPackedLightSamples > 0)
			{
				InterlockedAdd(RWLightTileAllocator[0], NumPackedLightSamples, LightTileOffset);
			}

			for (uint LightSampleIndex = 0; LightSampleIndex < NumPackedLightSamples; ++LightSampleIndex)
			{
				FLightSample LightSample = UnpackLightSample(LightSampleAccumulator.PackedSamples[LightSampleIndex]);


				FLightTileForCompactionPass LightTile;
				LightTile.LightIndex = LightSample.LightIndex;
				LightTile.ViewIndex = ViewIndex;
				LightTile.bHasShadowMask = LightSample.bHasShadowMask;
				LightTile.CardTileIndex = CardTileIndex;
				LightTile.CulledLightIndex = LightSampleIndex;
				RWLightTiles[LightTileOffset + LightSampleIndex] = PackLightTileForCompactionPass(LightTile);

				InterlockedAdd(RWLightTileAllocatorPerLight[LightSample.LightIndex * NumViews + ViewIndex], 1);
			}

			if (NumPackedLightSamples > 0)
			{
				uint CardLightTilesOffset;
				InterlockedAdd(RWLightTileAllocatorForPerCardTileDispatch[0], NumPackedLightSamples, CardLightTilesOffset);
				PackedOffsetNum = (NumPackedLightSamples << 24) | CardLightTilesOffset;
			}
		}

		RWLightTileOffsetNumPerCardTile[CardTileIndex] = PackedOffsetNum;
	}
}

StructuredBuffer<uint> LightTileAllocatorPerLight;
RWStructuredBuffer<uint> RWLightTileOffsetsPerLight;
#line 421 "/Engine/Private/Lumen/LumenSceneDirectLightingCulling.usf"
[numthreads( 64 , 1, 1)]
void ComputeLightTileOffsetsPerLightCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	if (DispatchThreadId.x == 0)
	{
		uint TileOffset = 0;

		for (uint ViewIndex = 0; ViewIndex < NumViews; ViewIndex++)
		{
			for (uint LightIndex = 0; LightIndex < NumLights; ++LightIndex)
			{
				RWLightTileOffsetsPerLight[LightIndex * NumViews + ViewIndex] = TileOffset;
				TileOffset += LightTileAllocatorPerLight[LightIndex * NumViews + ViewIndex];
			}
		}
	}
}

RWStructuredBuffer<uint2> RWCompactedLightTiles;
RWStructuredBuffer<uint2> RWLightTilesPerCardTile;
RWStructuredBuffer<uint> RWCompactedLightTileAllocatorPerLight;
StructuredBuffer<uint> LightTileAllocator;
StructuredBuffer<uint2> LightTiles;
StructuredBuffer<uint> LightTileOffsetsPerLight;
StructuredBuffer<uint> LightTileOffsetNumPerCardTile;
#line 450 "/Engine/Private/Lumen/LumenSceneDirectLightingCulling.usf"
[numthreads( 64 , 1, 1)]
void CompactLightTilesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	const uint LightTileIndex = DispatchThreadId.x;

	if (LightTileIndex < LightTileAllocator[0])
	{
		FLightTileForCompactionPass LightTile = UnpackLightTileForCompactionPass(LightTiles[LightTileIndex]);

		uint CompactedLightTileIndex = 0;
		InterlockedAdd(RWCompactedLightTileAllocatorPerLight[LightTile.LightIndex * NumViews + LightTile.ViewIndex], 1, CompactedLightTileIndex);
		CompactedLightTileIndex += LightTileOffsetsPerLight[LightTile.LightIndex * NumViews + LightTile.ViewIndex];

		uint CardTileIndex = LightTile.CardTileIndex;
		FCardTileData CardTile = UnpackCardTileData(CardTiles[CardTileIndex]);

		FLightTileForShadowMaskPass TileForLight;
		TileForLight.LightIndex = LightTile.LightIndex;
		TileForLight.ViewIndex = LightTile.ViewIndex;
		TileForLight.CardPageIndex = CardTile.CardPageIndex;
		TileForLight.TileCoord = CardTile.TileCoord;
		uint2 PackedLightTile = PackLightTileForShadowMaskPass(TileForLight);
		RWCompactedLightTiles[CompactedLightTileIndex] = PackedLightTile;

		uint PackedOffsetNum = LightTileOffsetNumPerCardTile[CardTileIndex];
		uint LightTileOffset = (PackedOffsetNum & 0x00ffffff) + LightTile.CulledLightIndex;
		FLightTileForLightPass TileForCardTile;
		TileForCardTile.LightIndex = LightTile.LightIndex;
		TileForCardTile.ViewIndex = LightTile.ViewIndex;
		TileForCardTile.ShadowMaskIndex = LightTile.bHasShadowMask ? CompactedLightTileIndex : 0xffffffff;
		PackedLightTile = PackLightTileForLightPass(TileForCardTile);
		RWLightTilesPerCardTile[LightTileOffset] = PackedLightTile;
	}
}

RWBuffer<uint> RWDispatchLightTilesIndirectArgs;
RWBuffer<uint> RWDrawTilesPerLightIndirectArgs;
RWBuffer<uint> RWDispatchTilesPerLightIndirectArgs;

uint VertexCountPerInstanceIndirect;
uint PerLightDispatchFactor;

[numthreads( 64 , 1, 1)]
void InitializeLightTileIndirectArgsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint PerViewLightIndex = DispatchThreadId.x;


	if (PerViewLightIndex == 0)
	{
		uint NumLightTiles = LightTileAllocator[0];


		RWDispatchLightTilesIndirectArgs[0] = NumLightTiles;
		RWDispatchLightTilesIndirectArgs[1] = 1;
		RWDispatchLightTilesIndirectArgs[2] = 1;


		RWDispatchLightTilesIndirectArgs[3 + 0] = (NumLightTiles + 63) / 64;
		RWDispatchLightTilesIndirectArgs[3 + 1] = 1;
		RWDispatchLightTilesIndirectArgs[3 + 2] = 1;
	}


	if (PerViewLightIndex < NumLights * NumViews)
	{
		uint NumLightTilesPerLight = LightTileAllocatorPerLight[PerViewLightIndex];


		RWDispatchTilesPerLightIndirectArgs[3 * PerViewLightIndex + 0] = PerLightDispatchFactor * NumLightTilesPerLight;
		RWDispatchTilesPerLightIndirectArgs[3 * PerViewLightIndex + 1] = 1;
		RWDispatchTilesPerLightIndirectArgs[3 * PerViewLightIndex + 2] = 1;


		RWDrawTilesPerLightIndirectArgs[4 * PerViewLightIndex + 0] = VertexCountPerInstanceIndirect;
		RWDrawTilesPerLightIndirectArgs[4 * PerViewLightIndex + 1] = NumLightTilesPerLight;
		RWDrawTilesPerLightIndirectArgs[4 * PerViewLightIndex + 2] = 0;
		RWDrawTilesPerLightIndirectArgs[4 * PerViewLightIndex + 3] = 0;
	}
}

uint LightIndex;
uint ViewIndex;

void RasterizeToLightTilesVS(
	uint VertexId : SV_VertexID,
	uint InstanceId : SV_InstanceID,
	out FCardVSToPS CardInterpolants,
	out float4 OutPosition : SV_POSITION
)
{
	float2 TexCoord = float2(0.0f, 0.0f);
	TexCoord.x += VertexId == 1 || VertexId == 2 || VertexId == 4 ? 1.0f : 0.0f;
	TexCoord.y += VertexId == 2 || VertexId == 4 || VertexId == 5 ? 1.0f : 0.0f;

	uint LightTileIndex = InstanceId.x + LightTileOffsetsPerLight[LightIndex * NumViews + ViewIndex];
	uint NumLightTiles = LightTileAllocator[0];

	CardInterpolants = (FCardVSToPS)0;
	OutPosition = 0;

	if (LightTileIndex < NumLightTiles)
	{
		FLightTileForShadowMaskPass LightTile = UnpackLightTileForShadowMaskPass(LightTiles[LightTileIndex]);
		FLumenCardPageData CardPage = GetLumenCardPageData(LightTile.CardPageIndex);

		float2 AtlasUV = CardPage.PhysicalAtlasUVRect.xy + CardPage.PhysicalAtlasUVTexelScale *  8  * (LightTile.TileCoord + TexCoord);
		float2 CardUV = CardPage.CardUVRect.xy + CardPage.CardUVTexelScale *  8  * (LightTile.TileCoord + TexCoord);

		float2 ScreenPosition = float2(2.0f, -2.0f) * AtlasUV + float2(-1.0f, 1.0f);
		OutPosition = float4(ScreenPosition, 0, 1);

		CardInterpolants.AtlasUV = AtlasUV;
		CardInterpolants.IndirectLightingAtlasUV = float2(0.0f, 0.0f);
		CardInterpolants.CardUV = CardUV;
		CardInterpolants.CardTileIndex = LightTileIndex;
		CardInterpolants.CardPageIndex = LightTile.CardPageIndex;
	}
}

#if 0 /*BEGIN_RESOURCE_TABLES*/
View, 331027882
Strata, 158337041
DrawRectangleParameters, 3145984
InstancedView, 297796353
SceneTexturesStruct, 158928480
MobileSceneTextures, 11010716
DeferredLightUniforms, 10486016
RaytracingLightsDataPacked, 89133352
LumenCardScene, 433658056
NULL, 0
View_MaterialTextureBilinearWrapedSampler, View, 8, 0
View_MaterialTextureBilinearClampedSampler, View, 8, 1
View_VolumetricLightmapIndirectionTexture, View, 5, 2
View_VolumetricLightmapBrickAmbientVector, View, 5, 3
View_VolumetricLightmapBrickSHCoefficients0, View, 5, 4
View_VolumetricLightmapBrickSHCoefficients1, View, 5, 5
View_VolumetricLightmapBrickSHCoefficients2, View, 5, 6
View_VolumetricLightmapBrickSHCoefficients3, View, 5, 7
View_VolumetricLightmapBrickSHCoefficients4, View, 5, 8
View_VolumetricLightmapBrickSHCoefficients5, View, 5, 9
View_SkyBentNormalBrickTexture, View, 5, 10
View_DirectionalLightShadowingBrickTexture, View, 5, 11
View_VolumetricLightmapBrickAmbientVectorSampler, View, 8, 12
View_VolumetricLightmapTextureSampler0, View, 8, 13
View_VolumetricLightmapTextureSampler1, View, 8, 14
View_VolumetricLightmapTextureSampler2, View, 8, 15
View_VolumetricLightmapTextureSampler3, View, 8, 16
View_VolumetricLightmapTextureSampler4, View, 8, 17
View_VolumetricLightmapTextureSampler5, View, 8, 18
View_SkyBentNormalTextureSampler, View, 8, 19
View_DirectionalLightShadowingTextureSampler, View, 8, 20
View_GlobalDistanceFieldPageAtlasTexture, View, 5, 21
View_GlobalDistanceFieldCoverageAtlasTexture, View, 5, 22
View_GlobalDistanceFieldPageTableTexture, View, 5, 23
View_GlobalDistanceFieldMipTexture, View, 5, 24
View_AtmosphereTransmittanceTexture, View, 5, 25
View_AtmosphereTransmittanceTextureSampler, View, 8, 26
View_AtmosphereIrradianceTexture, View, 5, 27
View_AtmosphereIrradianceTextureSampler, View, 8, 28
View_AtmosphereInscatterTexture, View, 5, 29
View_AtmosphereInscatterTextureSampler, View, 8, 30
View_PerlinNoiseGradientTexture, View, 5, 31
View_PerlinNoiseGradientTextureSampler, View, 8, 32
View_PerlinNoise3DTexture, View, 5, 33
View_PerlinNoise3DTextureSampler, View, 8, 34
View_SobolSamplingTexture, View, 5, 35
View_SharedPointWrappedSampler, View, 8, 36
View_SharedPointClampedSampler, View, 8, 37
View_SharedBilinearWrappedSampler, View, 8, 38
View_SharedBilinearClampedSampler, View, 8, 39
View_SharedBilinearAnisoClampedSampler, View, 8, 40
View_SharedTrilinearWrappedSampler, View, 8, 41
View_SharedTrilinearClampedSampler, View, 8, 42
View_PreIntegratedBRDF, View, 5, 43
View_PreIntegratedBRDFSampler, View, 8, 44
View_PrimitiveSceneData, View, 6, 45
View_InstanceSceneData, View, 6, 46
View_InstancePayloadData, View, 6, 47
View_LightmapSceneData, View, 6, 48
View_SkyIrradianceEnvironmentMap, View, 6, 49
View_TransmittanceLutTexture, View, 5, 50
View_TransmittanceLutTextureSampler, View, 8, 51
View_SkyViewLutTexture, View, 5, 52
View_SkyViewLutTextureSampler, View, 8, 53
View_DistantSkyLightLutTexture, View, 5, 54
View_DistantSkyLightLutTextureSampler, View, 8, 55
View_CameraAerialPerspectiveVolume, View, 5, 56
View_CameraAerialPerspectiveVolumeSampler, View, 8, 57
View_HairScatteringLUTTexture, View, 5, 58
View_HairScatteringLUTSampler, View, 8, 59
View_LTCMatTexture, View, 5, 60
View_LTCMatSampler, View, 8, 61
View_LTCAmpTexture, View, 5, 62
View_LTCAmpSampler, View, 8, 63
View_ShadingEnergyGGXSpecTexture, View, 5, 64
View_ShadingEnergyGGXGlassTexture, View, 5, 65
View_ShadingEnergyClothSpecTexture, View, 5, 66
View_ShadingEnergyDiffuseTexture, View, 5, 67
View_ShadingEnergySampler, View, 8, 68
View_SSProfilesTexture, View, 5, 69
View_SSProfilesSampler, View, 8, 70
View_SSProfilesTransmissionSampler, View, 8, 71
View_SSProfilesPreIntegratedTexture, View, 5, 72
View_SSProfilesPreIntegratedSampler, View, 8, 73
View_WaterIndirection, View, 6, 74
View_WaterData, View, 6, 75
View_RectLightAtlasTexture, View, 5, 76
View_RectLightAtlasSampler, View, 8, 77
View_LandscapeWeightmapSampler, View, 8, 78
View_LandscapeIndirection, View, 6, 79
View_LandscapePerComponentData, View, 6, 80
View_VTFeedbackBuffer, View, 7, 81
View_EditorVisualizeLevelInstanceIds, View, 6, 82
View_EditorSelectedHitProxyIds, View, 6, 83
View_PhysicsFieldClipmapBuffer, View, 6, 84
Strata_MaterialTextureArray, Strata, 9, 0
Strata_TopLayerTexture, Strata, 9, 1
Strata_OpaqueRoughRefractionTexture, Strata, 9, 2
Strata_BSDFOffsetTexture, Strata, 9, 3
Strata_BSDFTileTexture, Strata, 9, 4
Strata_BSDFTileCountBuffer, Strata, 16, 5
SceneTexturesStruct_SceneColorTexture, SceneTexturesStruct, 9, 0
SceneTexturesStruct_SceneDepthTexture, SceneTexturesStruct, 9, 1
SceneTexturesStruct_GBufferATexture, SceneTexturesStruct, 9, 2
SceneTexturesStruct_GBufferBTexture, SceneTexturesStruct, 9, 3
SceneTexturesStruct_GBufferCTexture, SceneTexturesStruct, 9, 4
SceneTexturesStruct_GBufferDTexture, SceneTexturesStruct, 9, 5
SceneTexturesStruct_GBufferETexture, SceneTexturesStruct, 9, 6
SceneTexturesStruct_GBufferFTexture, SceneTexturesStruct, 9, 7
SceneTexturesStruct_GBufferVelocityTexture, SceneTexturesStruct, 9, 8
SceneTexturesStruct_ScreenSpaceAOTexture, SceneTexturesStruct, 9, 9
SceneTexturesStruct_CustomDepthTexture, SceneTexturesStruct, 9, 10
SceneTexturesStruct_CustomStencilTexture, SceneTexturesStruct, 12, 11
SceneTexturesStruct_PointClampSampler, SceneTexturesStruct, 8, 12
MobileSceneTextures_SceneColorTexture, MobileSceneTextures, 9, 0
MobileSceneTextures_SceneColorTextureSampler, MobileSceneTextures, 8, 1
MobileSceneTextures_SceneDepthTexture, MobileSceneTextures, 9, 2
MobileSceneTextures_SceneDepthTextureSampler, MobileSceneTextures, 8, 3
MobileSceneTextures_CustomDepthTexture, MobileSceneTextures, 9, 4
MobileSceneTextures_CustomDepthTextureSampler, MobileSceneTextures, 8, 5
MobileSceneTextures_CustomStencilTexture, MobileSceneTextures, 12, 6
MobileSceneTextures_SceneVelocityTexture, MobileSceneTextures, 9, 7
MobileSceneTextures_SceneVelocityTextureSampler, MobileSceneTextures, 8, 8
MobileSceneTextures_GBufferATexture, MobileSceneTextures, 9, 9
MobileSceneTextures_GBufferBTexture, MobileSceneTextures, 9, 10
MobileSceneTextures_GBufferCTexture, MobileSceneTextures, 9, 11
MobileSceneTextures_GBufferDTexture, MobileSceneTextures, 9, 12
MobileSceneTextures_SceneDepthAuxTexture, MobileSceneTextures, 9, 13
MobileSceneTextures_GBufferATextureSampler, MobileSceneTextures, 8, 14
MobileSceneTextures_GBufferBTextureSampler, MobileSceneTextures, 8, 15
MobileSceneTextures_GBufferCTextureSampler, MobileSceneTextures, 8, 16
MobileSceneTextures_GBufferDTextureSampler, MobileSceneTextures, 8, 17
MobileSceneTextures_SceneDepthAuxTextureSampler, MobileSceneTextures, 8, 18
RaytracingLightsDataPacked_IESLightProfileTextureSampler, RaytracingLightsDataPacked, 8, 0
RaytracingLightsDataPacked_IESLightProfileTexture, RaytracingLightsDataPacked, 5, 1
RaytracingLightsDataPacked_LightDataBuffer, RaytracingLightsDataPacked, 16, 2
RaytracingLightsDataPacked_LightIndices, RaytracingLightsDataPacked, 16, 3
RaytracingLightsDataPacked_LightCullingVolume, RaytracingLightsDataPacked, 16, 4
LumenCardScene_CardData, LumenCardScene, 16, 0
LumenCardScene_CardPageData, LumenCardScene, 16, 1
LumenCardScene_MeshCardsData, LumenCardScene, 16, 2
LumenCardScene_HeightfieldData, LumenCardScene, 16, 3
LumenCardScene_PageTableBuffer, LumenCardScene, 16, 4
LumenCardScene_SceneInstanceIndexToMeshCardsIndexBuffer, LumenCardScene, 16, 5
LumenCardScene_AlbedoAtlas, LumenCardScene, 9, 6
LumenCardScene_OpacityAtlas, LumenCardScene, 9, 7
LumenCardScene_NormalAtlas, LumenCardScene, 9, 8
LumenCardScene_EmissiveAtlas, LumenCardScene, 9, 9
LumenCardScene_DepthAtlas, LumenCardScene, 9, 10
NULL, NULL, 0, 0
#endif /*END_RESOURCE_TABLES*/
#if 0 /*DIRECT COMPILE*/
-directcompile -format=PCD3D_SM6 -entry=ComputeLightTileOffsetsPerLightCS -shaderPlatformName=PCD3D_SM6 -cs D:/Programming II/Compulsory1/P2Compulsory1/Saved/ShaderDebugInfo/PCD3D_SM6/Global/FComputeLightTileOffsetsPerLightCS/0/LumenSceneDirectLightingCulling.usf -cflags=537923584 -nocrashreports
#endif /*DIRECT COMPILE*/
//
